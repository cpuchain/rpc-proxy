#!/usr/bin/env node
'use strict';

var process$1 = require('process');
var cluster = require('cluster');
var tty = require('node:tty');
var os = require('os');
var require$$0$2 = require('fs');
var promises = require('fs/promises');
var path = require('path');
var require$$7 = require('url');
var require$$0$4 = require('node:events');
var require$$0$3 = require('node:util');
var require$$0$5 = require('node:http');
var require$$1$2 = require('node:diagnostics_channel');
var require$$1$1 = require('node:https');
var require$$2 = require('node:http2');
var require$$3$2 = require('node:dns');
var require$$0$6 = require('node:os');
var require$$1$5 = require('node:stream');
var require$$0$7 = require('events');
var require$$1$3 = require('util');
var require$$5 = require('assert');
var require$$2$1 = require('worker_threads');
var require$$0$9 = require('module');
var require$$1$4 = require('node:path');
var require$$0$8 = require('buffer');
var require$$0$a = require('node:async_hooks');
var require$$0$b = require('node:assert');
var require$$1$6 = require('node:url');
var require$$0$c = require('node:crypto');
var require$$1$8 = require('https');
var require$$2$2 = require('http');
var require$$3$3 = require('net');
var require$$4 = require('tls');
var require$$1$7 = require('crypto');
var require$$0$e = require('stream');
var require$$0$d = require('zlib');
var require$$0$f = require('node:fs');
var require$$1$9 = require('tty');
var require$$5$1 = require('node:fs/promises');
var require$$2$3 = require('node:string_decoder');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
// eslint-disable-next-line no-warning-comments
// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)
// Lots of optionals here to support Deno.
const hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;

const format$2 = (open, close) => {
	if (!hasColors) {
		return input => input;
	}

	const openCode = `\u001B[${open}m`;
	const closeCode = `\u001B[${close}m`;

	return input => {
		const string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.
		let index = string.indexOf(closeCode);

		if (index === -1) {
			// Note: Intentionally not using string interpolation for performance reasons.
			return openCode + string + closeCode;
		}

		// Handle nested colors.

		// We could have done this, but it's too slow (as of Node.js 22).
		// return openCode + string.replaceAll(closeCode, openCode) + closeCode;

		let result = openCode;
		let lastIndex = 0;

		while (index !== -1) {
			result += string.slice(lastIndex, index) + openCode;
			lastIndex = index + closeCode.length;
			index = string.indexOf(closeCode, lastIndex);
		}

		result += string.slice(lastIndex) + closeCode;

		return result;
	};
};
const bold = format$2(1, 22);
const italic = format$2(3, 23);
const underline = format$2(4, 24);
const red = format$2(31, 39);
const green = format$2(32, 39);
const yellow = format$2(33, 39);
const cyan = format$2(36, 39);
const gray = format$2(90, 39);
const blueBright = format$2(94, 39);

function cap(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function pad(n) {
  return n < 10 ? "0" + n : n.toString();
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
var severityValues = /* @__PURE__ */ ((severityValues2) => {
  severityValues2[severityValues2["debug"] = 1] = "debug";
  severityValues2[severityValues2["info"] = 2] = "info";
  severityValues2[severityValues2["warning"] = 3] = "warning";
  severityValues2[severityValues2["error"] = 4] = "error";
  severityValues2[severityValues2["special"] = 5] = "special";
  return severityValues2;
})(severityValues || {});
function severityToColor(severity, text) {
  switch (severity) {
    case "debug":
      return green(text);
    case "info":
      return blueBright(text);
    case "warning":
      return yellow(text);
    case "error":
      return red(text);
    case "special":
      return cyan(underline(text));
    default:
      console.log("Unknown severity " + severity);
      return italic(text);
  }
}
class Logger {
  logColors;
  logLevelInt;
  logSystem;
  logComponent;
  constructor(config, logSystem, logComponent) {
    this.logColors = typeof config?.logColors !== "undefined" ? config.logColors : true;
    this.logLevelInt = severityValues[config?.logLevel || "debug"];
    this.logSystem = logSystem;
    this.logComponent = logComponent;
  }
  log(severity, system, component, text, subcat) {
    if (severityValues[severity] < this.logLevelInt) {
      return;
    }
    let entryDesc = formatDate(/* @__PURE__ */ new Date()) + " [" + system + "]	";
    let logString = "";
    if (this.logColors) {
      entryDesc = severityToColor(severity, entryDesc);
      logString = entryDesc;
      if (component) {
        logString += italic("[" + component + "] ");
      }
      if (subcat) {
        logString += gray(bold("(" + subcat + ") "));
      }
      if (!component) {
        logString += text;
      } else {
        logString += gray(text);
      }
    } else {
      logString = entryDesc;
      if (component) {
        logString += "[" + component + "] ";
      }
      if (subcat) {
        logString += "(" + subcat + ") ";
      }
      logString += text;
    }
    console.log(logString);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handleLog(logLevel, ...args) {
    const logSystem = this.logSystem;
    const logComponent = this.logComponent;
    if (!logSystem && args.length === 1) {
      return this.log(logLevel, cap(logLevel), logComponent, args[0]);
    }
    if (!logSystem && args.length === 2) {
      return this.log(logLevel, args[0], logComponent, args[1]);
    }
    if (logSystem && args.length === 1) {
      return this.log(logLevel, logSystem, logComponent, args[0]);
    }
    if (logSystem && args.length === 2) {
      return this.log(logLevel, logSystem, args[0], args[1]);
    }
    if (args.length === 3) {
      return this.log(logLevel, args[0], args[1], args[2]);
    }
    return this.log(logLevel, args[0], args[1], args[2], args[3]);
  }
  debug(...args) {
    this.handleLog("debug", ...args);
  }
  info(...args) {
    this.handleLog("info", ...args);
  }
  warning(...args) {
    this.handleLog("warning", ...args);
  }
  error(...args) {
    this.handleLog("error", ...args);
  }
  special(...args) {
    this.handleLog("special", ...args);
  }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var ajv = {exports: {}};

var core$1 = {};

var validate = {};

var boolSchema = {};

var errors$4 = {};

var codegen = {};

var code$1 = {};

var hasRequiredCode$1;

function requireCode$1 () {
	if (hasRequiredCode$1) return code$1;
	hasRequiredCode$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$1));
	return code$1;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$1();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$1();
		const scope_1 = requireScope();
		var code_2 = requireCode$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util$1 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode$1();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util$1.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util$1.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util$1.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util$1.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util$1.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util$1.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util$1.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util$1.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util$1.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util$1.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util$1.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util$1.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util$1.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util$1.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util$1.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util$1.checkStrictMode = checkStrictMode;
	
	return util$1;
}

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

var hasRequiredErrors$4;

function requireErrors$4 () {
	if (hasRequiredErrors$4) return errors$4;
	hasRequiredErrors$4 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const names_1 = requireNames();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors$4));
	return errors$4;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors$4();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	Object.defineProperty(rules, "__esModule", { value: true });
	rules.getRules = rules.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules.getRules = getRules;
	
	return rules;
}

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;
	Object.defineProperty(dataType, "__esModule", { value: true });
	dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
	const rules_1 = requireRules();
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors$4();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const names_1 = requireNames();
	const util_2 = requireUtil$1();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = requireErrors$4();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve = {};

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	Object.defineProperty(resolve, "__esModule", { value: true });
	resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
	const util_1 = requireUtil$1();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve.getSchemaRefs = getSchemaRefs;
	
	return resolve;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = requireDataType();
	const applicability_1 = requireApplicability();
	const dataType_2 = requireDataType();
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const errors_1 = requireErrors$4();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = requireResolve();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
	const codegen_1 = requireCodegen();
	const validation_error_1 = requireValidation_error();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const validate_1 = requireValidate();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$2 = "object";
var required$1 = [
	"$data"
];
var properties$3 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$2,
	required: required$1,
	properties: properties$3,
	additionalProperties: additionalProperties$1
};

var uri = {};

var fastUri = {exports: {}};

var scopedChars;
var hasRequiredScopedChars;

function requireScopedChars () {
	if (hasRequiredScopedChars) return scopedChars;
	hasRequiredScopedChars = 1;

	const HEX = {
	  0: 0,
	  1: 1,
	  2: 2,
	  3: 3,
	  4: 4,
	  5: 5,
	  6: 6,
	  7: 7,
	  8: 8,
	  9: 9,
	  a: 10,
	  A: 10,
	  b: 11,
	  B: 11,
	  c: 12,
	  C: 12,
	  d: 13,
	  D: 13,
	  e: 14,
	  E: 14,
	  f: 15,
	  F: 15
	};

	scopedChars = {
	  HEX
	};
	return scopedChars;
}

var utils$2;
var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;

	const { HEX } = requireScopedChars();

	const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;

	function normalizeIPv4 (host) {
	  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
	  const matches = host.match(IPV4_REG) || [];
	  const [address] = matches;
	  if (address) {
	    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
	  } else {
	    return { host, isIPV4: false }
	  }
	}

	/**
	 * @param {string[]} input
	 * @param {boolean} [keepZero=false]
	 * @returns {string|undefined}
	 */
	function stringArrayToHexStripped (input, keepZero = false) {
	  let acc = '';
	  let strip = true;
	  for (const c of input) {
	    if (HEX[c] === undefined) return undefined
	    if (c !== '0' && strip === true) strip = false;
	    if (!strip) acc += c;
	  }
	  if (keepZero && acc.length === 0) acc = '0';
	  return acc
	}

	function getIPV6 (input) {
	  let tokenCount = 0;
	  const output = { error: false, address: '', zone: '' };
	  const address = [];
	  const buffer = [];
	  let isZone = false;
	  let endipv6Encountered = false;
	  let endIpv6 = false;

	  function consume () {
	    if (buffer.length) {
	      if (isZone === false) {
	        const hex = stringArrayToHexStripped(buffer);
	        if (hex !== undefined) {
	          address.push(hex);
	        } else {
	          output.error = true;
	          return false
	        }
	      }
	      buffer.length = 0;
	    }
	    return true
	  }

	  for (let i = 0; i < input.length; i++) {
	    const cursor = input[i];
	    if (cursor === '[' || cursor === ']') { continue }
	    if (cursor === ':') {
	      if (endipv6Encountered === true) {
	        endIpv6 = true;
	      }
	      if (!consume()) { break }
	      tokenCount++;
	      address.push(':');
	      if (tokenCount > 7) {
	        // not valid
	        output.error = true;
	        break
	      }
	      if (i - 1 >= 0 && input[i - 1] === ':') {
	        endipv6Encountered = true;
	      }
	      continue
	    } else if (cursor === '%') {
	      if (!consume()) { break }
	      // switch to zone detection
	      isZone = true;
	    } else {
	      buffer.push(cursor);
	      continue
	    }
	  }
	  if (buffer.length) {
	    if (isZone) {
	      output.zone = buffer.join('');
	    } else if (endIpv6) {
	      address.push(buffer.join(''));
	    } else {
	      address.push(stringArrayToHexStripped(buffer));
	    }
	  }
	  output.address = address.join('');
	  return output
	}

	function normalizeIPv6 (host) {
	  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
	  const ipv6 = getIPV6(host);

	  if (!ipv6.error) {
	    let newHost = ipv6.address;
	    let escapedHost = ipv6.address;
	    if (ipv6.zone) {
	      newHost += '%' + ipv6.zone;
	      escapedHost += '%25' + ipv6.zone;
	    }
	    return { host: newHost, escapedHost, isIPV6: true }
	  } else {
	    return { host, isIPV6: false }
	  }
	}

	function stripLeadingZeros (str, token) {
	  let out = '';
	  let skip = true;
	  const l = str.length;
	  for (let i = 0; i < l; i++) {
	    const c = str[i];
	    if (c === '0' && skip) {
	      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
	        out += c;
	        skip = false;
	      }
	    } else {
	      if (c === token) {
	        skip = true;
	      } else {
	        skip = false;
	      }
	      out += c;
	    }
	  }
	  return out
	}

	function findToken (str, token) {
	  let ind = 0;
	  for (let i = 0; i < str.length; i++) {
	    if (str[i] === token) ind++;
	  }
	  return ind
	}

	const RDS1 = /^\.\.?\//u;
	const RDS2 = /^\/\.(?:\/|$)/u;
	const RDS3 = /^\/\.\.(?:\/|$)/u;
	const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;

	function removeDotSegments (input) {
	  const output = [];

	  while (input.length) {
	    if (input.match(RDS1)) {
	      input = input.replace(RDS1, '');
	    } else if (input.match(RDS2)) {
	      input = input.replace(RDS2, '/');
	    } else if (input.match(RDS3)) {
	      input = input.replace(RDS3, '/');
	      output.pop();
	    } else if (input === '.' || input === '..') {
	      input = '';
	    } else {
	      const im = input.match(RDS5);
	      if (im) {
	        const s = im[0];
	        input = input.slice(s.length);
	        output.push(s);
	      } else {
	        throw new Error('Unexpected dot segment condition')
	      }
	    }
	  }
	  return output.join('')
	}

	function normalizeComponentEncoding (components, esc) {
	  const func = esc !== true ? escape : unescape;
	  if (components.scheme !== undefined) {
	    components.scheme = func(components.scheme);
	  }
	  if (components.userinfo !== undefined) {
	    components.userinfo = func(components.userinfo);
	  }
	  if (components.host !== undefined) {
	    components.host = func(components.host);
	  }
	  if (components.path !== undefined) {
	    components.path = func(components.path);
	  }
	  if (components.query !== undefined) {
	    components.query = func(components.query);
	  }
	  if (components.fragment !== undefined) {
	    components.fragment = func(components.fragment);
	  }
	  return components
	}

	function recomposeAuthority (components) {
	  const uriTokens = [];

	  if (components.userinfo !== undefined) {
	    uriTokens.push(components.userinfo);
	    uriTokens.push('@');
	  }

	  if (components.host !== undefined) {
	    let host = unescape(components.host);
	    const ipV4res = normalizeIPv4(host);

	    if (ipV4res.isIPV4) {
	      host = ipV4res.host;
	    } else {
	      const ipV6res = normalizeIPv6(ipV4res.host);
	      if (ipV6res.isIPV6 === true) {
	        host = `[${ipV6res.escapedHost}]`;
	      } else {
	        host = components.host;
	      }
	    }
	    uriTokens.push(host);
	  }

	  if (typeof components.port === 'number' || typeof components.port === 'string') {
	    uriTokens.push(':');
	    uriTokens.push(String(components.port));
	  }

	  return uriTokens.length ? uriTokens.join('') : undefined
	}
	utils$2 = {
	  recomposeAuthority,
	  normalizeComponentEncoding,
	  removeDotSegments,
	  normalizeIPv4,
	  normalizeIPv6,
	  stringArrayToHexStripped
	};
	return utils$2;
}

var schemes;
var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;

	const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

	function isSecure (wsComponents) {
	  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
	}

	function httpParse (components) {
	  if (!components.host) {
	    components.error = components.error || 'HTTP URIs must have a host.';
	  }

	  return components
	}

	function httpSerialize (components) {
	  const secure = String(components.scheme).toLowerCase() === 'https';

	  // normalize the default port
	  if (components.port === (secure ? 443 : 80) || components.port === '') {
	    components.port = undefined;
	  }

	  // normalize the empty path
	  if (!components.path) {
	    components.path = '/';
	  }

	  // NOTE: We do not parse query strings for HTTP URIs
	  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	  // and not the HTTP spec.

	  return components
	}

	function wsParse (wsComponents) {
	// indicate if the secure flag is set
	  wsComponents.secure = isSecure(wsComponents);

	  // construct resouce name
	  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	  wsComponents.path = undefined;
	  wsComponents.query = undefined;

	  return wsComponents
	}

	function wsSerialize (wsComponents) {
	// normalize the default port
	  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
	    wsComponents.port = undefined;
	  }

	  // ensure scheme matches secure flag
	  if (typeof wsComponents.secure === 'boolean') {
	    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');
	    wsComponents.secure = undefined;
	  }

	  // reconstruct path from resource name
	  if (wsComponents.resourceName) {
	    const [path, query] = wsComponents.resourceName.split('?');
	    wsComponents.path = (path && path !== '/' ? path : undefined);
	    wsComponents.query = query;
	    wsComponents.resourceName = undefined;
	  }

	  // forbid fragment component
	  wsComponents.fragment = undefined;

	  return wsComponents
	}

	function urnParse (urnComponents, options) {
	  if (!urnComponents.path) {
	    urnComponents.error = 'URN can not be parsed';
	    return urnComponents
	  }
	  const matches = urnComponents.path.match(URN_REG);
	  if (matches) {
	    const scheme = options.scheme || urnComponents.scheme || 'urn';
	    urnComponents.nid = matches[1].toLowerCase();
	    urnComponents.nss = matches[2];
	    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
	    const schemeHandler = SCHEMES[urnScheme];
	    urnComponents.path = undefined;

	    if (schemeHandler) {
	      urnComponents = schemeHandler.parse(urnComponents, options);
	    }
	  } else {
	    urnComponents.error = urnComponents.error || 'URN can not be parsed.';
	  }

	  return urnComponents
	}

	function urnSerialize (urnComponents, options) {
	  const scheme = options.scheme || urnComponents.scheme || 'urn';
	  const nid = urnComponents.nid.toLowerCase();
	  const urnScheme = `${scheme}:${options.nid || nid}`;
	  const schemeHandler = SCHEMES[urnScheme];

	  if (schemeHandler) {
	    urnComponents = schemeHandler.serialize(urnComponents, options);
	  }

	  const uriComponents = urnComponents;
	  const nss = urnComponents.nss;
	  uriComponents.path = `${nid || options.nid}:${nss}`;

	  options.skipEscape = true;
	  return uriComponents
	}

	function urnuuidParse (urnComponents, options) {
	  const uuidComponents = urnComponents;
	  uuidComponents.uuid = uuidComponents.nss;
	  uuidComponents.nss = undefined;

	  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
	    uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
	  }

	  return uuidComponents
	}

	function urnuuidSerialize (uuidComponents) {
	  const urnComponents = uuidComponents;
	  // normalize UUID
	  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
	  return urnComponents
	}

	const http = {
	  scheme: 'http',
	  domainHost: true,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const https = {
	  scheme: 'https',
	  domainHost: http.domainHost,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const ws = {
	  scheme: 'ws',
	  domainHost: true,
	  parse: wsParse,
	  serialize: wsSerialize
	};

	const wss = {
	  scheme: 'wss',
	  domainHost: ws.domainHost,
	  parse: ws.parse,
	  serialize: ws.serialize
	};

	const urn = {
	  scheme: 'urn',
	  parse: urnParse,
	  serialize: urnSerialize,
	  skipNormalize: true
	};

	const urnuuid = {
	  scheme: 'urn:uuid',
	  parse: urnuuidParse,
	  serialize: urnuuidSerialize,
	  skipNormalize: true
	};

	const SCHEMES = {
	  http,
	  https,
	  ws,
	  wss,
	  urn,
	  'urn:uuid': urnuuid
	};

	schemes = SCHEMES;
	return schemes;
}

var hasRequiredFastUri;

function requireFastUri () {
	if (hasRequiredFastUri) return fastUri.exports;
	hasRequiredFastUri = 1;

	const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils$2();
	const SCHEMES = requireSchemes();

	function normalize (uri, options) {
	  if (typeof uri === 'string') {
	    uri = serialize(parse(uri, options), options);
	  } else if (typeof uri === 'object') {
	    uri = parse(serialize(uri, options), options);
	  }
	  return uri
	}

	function resolve (baseURI, relativeURI, options) {
	  const schemelessOptions = Object.assign({ scheme: 'null' }, options);
	  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
	  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
	}

	function resolveComponents (base, relative, options, skipNormalization) {
	  const target = {};
	  if (!skipNormalization) {
	    base = parse(serialize(base, options), options); // normalize base components
	    relative = parse(serialize(relative, options), options); // normalize relative components
	  }
	  options = options || {};

	  if (!options.tolerant && relative.scheme) {
	    target.scheme = relative.scheme;
	    // target.authority = relative.authority;
	    target.userinfo = relative.userinfo;
	    target.host = relative.host;
	    target.port = relative.port;
	    target.path = removeDotSegments(relative.path || '');
	    target.query = relative.query;
	  } else {
	    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	      // target.authority = relative.authority;
	      target.userinfo = relative.userinfo;
	      target.host = relative.host;
	      target.port = relative.port;
	      target.path = removeDotSegments(relative.path || '');
	      target.query = relative.query;
	    } else {
	      if (!relative.path) {
	        target.path = base.path;
	        if (relative.query !== undefined) {
	          target.query = relative.query;
	        } else {
	          target.query = base.query;
	        }
	      } else {
	        if (relative.path.charAt(0) === '/') {
	          target.path = removeDotSegments(relative.path);
	        } else {
	          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	            target.path = '/' + relative.path;
	          } else if (!base.path) {
	            target.path = relative.path;
	          } else {
	            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
	          }
	          target.path = removeDotSegments(target.path);
	        }
	        target.query = relative.query;
	      }
	      // target.authority = base.authority;
	      target.userinfo = base.userinfo;
	      target.host = base.host;
	      target.port = base.port;
	    }
	    target.scheme = base.scheme;
	  }

	  target.fragment = relative.fragment;

	  return target
	}

	function equal (uriA, uriB, options) {
	  if (typeof uriA === 'string') {
	    uriA = unescape(uriA);
	    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriA === 'object') {
	    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
	  }

	  if (typeof uriB === 'string') {
	    uriB = unescape(uriB);
	    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriB === 'object') {
	    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
	  }

	  return uriA.toLowerCase() === uriB.toLowerCase()
	}

	function serialize (cmpts, opts) {
	  const components = {
	    host: cmpts.host,
	    scheme: cmpts.scheme,
	    userinfo: cmpts.userinfo,
	    port: cmpts.port,
	    path: cmpts.path,
	    query: cmpts.query,
	    nid: cmpts.nid,
	    nss: cmpts.nss,
	    uuid: cmpts.uuid,
	    fragment: cmpts.fragment,
	    reference: cmpts.reference,
	    resourceName: cmpts.resourceName,
	    secure: cmpts.secure,
	    error: ''
	  };
	  const options = Object.assign({}, opts);
	  const uriTokens = [];

	  // find scheme handler
	  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];

	  // perform scheme specific serialization
	  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

	  if (components.path !== undefined) {
	    if (!options.skipEscape) {
	      components.path = escape(components.path);

	      if (components.scheme !== undefined) {
	        components.path = components.path.split('%3A').join(':');
	      }
	    } else {
	      components.path = unescape(components.path);
	    }
	  }

	  if (options.reference !== 'suffix' && components.scheme) {
	    uriTokens.push(components.scheme, ':');
	  }

	  const authority = recomposeAuthority(components);
	  if (authority !== undefined) {
	    if (options.reference !== 'suffix') {
	      uriTokens.push('//');
	    }

	    uriTokens.push(authority);

	    if (components.path && components.path.charAt(0) !== '/') {
	      uriTokens.push('/');
	    }
	  }
	  if (components.path !== undefined) {
	    let s = components.path;

	    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	      s = removeDotSegments(s);
	    }

	    if (authority === undefined) {
	      s = s.replace(/^\/\//u, '/%2F'); // don't allow the path to start with "//"
	    }

	    uriTokens.push(s);
	  }

	  if (components.query !== undefined) {
	    uriTokens.push('?', components.query);
	  }

	  if (components.fragment !== undefined) {
	    uriTokens.push('#', components.fragment);
	  }
	  return uriTokens.join('')
	}

	const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));

	function nonSimpleDomain (value) {
	  let code = 0;
	  for (let i = 0, len = value.length; i < len; ++i) {
	    code = value.charCodeAt(i);
	    if (code > 126 || hexLookUp[code]) {
	      return true
	    }
	  }
	  return false
	}

	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

	function parse (uri, opts) {
	  const options = Object.assign({}, opts);
	  const parsed = {
	    scheme: undefined,
	    userinfo: undefined,
	    host: '',
	    port: undefined,
	    path: '',
	    query: undefined,
	    fragment: undefined
	  };
	  const gotEncoding = uri.indexOf('%') !== -1;
	  let isIP = false;
	  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;

	  const matches = uri.match(URI_PARSE);

	  if (matches) {
	    // store each component
	    parsed.scheme = matches[1];
	    parsed.userinfo = matches[3];
	    parsed.host = matches[4];
	    parsed.port = parseInt(matches[5], 10);
	    parsed.path = matches[6] || '';
	    parsed.query = matches[7];
	    parsed.fragment = matches[8];

	    // fix port number
	    if (isNaN(parsed.port)) {
	      parsed.port = matches[5];
	    }
	    if (parsed.host) {
	      const ipv4result = normalizeIPv4(parsed.host);
	      if (ipv4result.isIPV4 === false) {
	        const ipv6result = normalizeIPv6(ipv4result.host);
	        parsed.host = ipv6result.host.toLowerCase();
	        isIP = ipv6result.isIPV6;
	      } else {
	        parsed.host = ipv4result.host;
	        isIP = true;
	      }
	    }
	    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
	      parsed.reference = 'same-document';
	    } else if (parsed.scheme === undefined) {
	      parsed.reference = 'relative';
	    } else if (parsed.fragment === undefined) {
	      parsed.reference = 'absolute';
	    } else {
	      parsed.reference = 'uri';
	    }

	    // check for reference errors
	    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
	      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
	    }

	    // find scheme handler
	    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];

	    // check if scheme can't handle IRIs
	    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	      // if host component is a domain name
	      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
	        // convert Unicode IDN -> ASCII IDN
	        try {
	          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
	        } catch (e) {
	          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
	        }
	      }
	      // convert IRI -> URI
	    }

	    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
	      if (gotEncoding && parsed.scheme !== undefined) {
	        parsed.scheme = unescape(parsed.scheme);
	      }
	      if (gotEncoding && parsed.host !== undefined) {
	        parsed.host = unescape(parsed.host);
	      }
	      if (parsed.path) {
	        parsed.path = escape(unescape(parsed.path));
	      }
	      if (parsed.fragment) {
	        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
	      }
	    }

	    // perform scheme specific parsing
	    if (schemeHandler && schemeHandler.parse) {
	      schemeHandler.parse(parsed, options);
	    }
	  } else {
	    parsed.error = parsed.error || 'URI can not be parsed.';
	  }
	  return parsed
	}

	const fastUri$1 = {
	  SCHEMES,
	  normalize,
	  resolve,
	  resolveComponents,
	  equal,
	  serialize,
	  parse
	};

	fastUri.exports = fastUri$1;
	fastUri.exports.default = fastUri$1;
	fastUri.exports.fastUri = fastUri$1;
	return fastUri.exports;
}

var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	Object.defineProperty(uri, "__esModule", { value: true });
	const uri$1 = requireFastUri();
	uri$1.code = 'require("ajv/dist/runtime/uri").default';
	uri.default = uri$1;
	
	return uri;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error();
		const ref_error_1 = requireRef_error();
		const rules_1 = requireRules();
		const compile_1 = requireCompile();
		const codegen_2 = requireCodegen();
		const resolve_1 = requireResolve();
		const dataType_1 = requireDataType();
		const util_1 = requireUtil$1();
		const $dataRefSchema = require$$9;
		const uri_1 = requireUri();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$1));
	return core$1;
}

var draft7 = {};

var core = {};

var id = {};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id;
	hasRequiredId = 1;
	Object.defineProperty(id, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id.default = def;
	
	return id;
}

var ref$1 = {};

var hasRequiredRef$1;

function requireRef$1 () {
	if (hasRequiredRef$1) return ref$1;
	hasRequiredRef$1 = 1;
	Object.defineProperty(ref$1, "__esModule", { value: true });
	ref$1.callRef = ref$1.getValidate = void 0;
	const ref_error_1 = requireRef_error();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const compile_1 = requireCompile();
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref$1.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref$1.callRef = callRef;
	ref$1.default = def;
	
	return ref$1;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	const id_1 = requireId();
	const ref_1 = requireRef$1();
	const core$1 = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core.default = core$1;
	
	return core;
}

var validation$3 = {};

var limitNumber = {};

var hasRequiredLimitNumber;

function requireLimitNumber () {
	if (hasRequiredLimitNumber) return limitNumber;
	hasRequiredLimitNumber = 1;
	Object.defineProperty(limitNumber, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber.default = def;
	
	return limitNumber;
}

var multipleOf = {};

var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	Object.defineProperty(multipleOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf.default = def;
	
	return multipleOf;
}

var limitLength = {};

var ucs2length = {};

var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	Object.defineProperty(ucs2length, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length$1(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length.default = ucs2length$1;
	ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length;
}

var hasRequiredLimitLength;

function requireLimitLength () {
	if (hasRequiredLimitLength) return limitLength;
	hasRequiredLimitLength = 1;
	Object.defineProperty(limitLength, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const ucs2length_1 = requireUcs2length();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength.default = def;
	
	return limitLength;
}

var pattern$1 = {};

var hasRequiredPattern$1;

function requirePattern$1 () {
	if (hasRequiredPattern$1) return pattern$1;
	hasRequiredPattern$1 = 1;
	Object.defineProperty(pattern$1, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern$1.default = def;
	
	return pattern$1;
}

var limitProperties = {};

var hasRequiredLimitProperties;

function requireLimitProperties () {
	if (hasRequiredLimitProperties) return limitProperties;
	hasRequiredLimitProperties = 1;
	Object.defineProperty(limitProperties, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties.default = def;
	
	return limitProperties;
}

var required = {};

var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required;
	hasRequiredRequired = 1;
	Object.defineProperty(required, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required.default = def;
	
	return required;
}

var limitItems = {};

var hasRequiredLimitItems;

function requireLimitItems () {
	if (hasRequiredLimitItems) return limitItems;
	hasRequiredLimitItems = 1;
	Object.defineProperty(limitItems, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems.default = def;
	
	return limitItems;
}

var uniqueItems = {};

var equal = {};

var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return equal;
	hasRequiredEqual = 1;
	Object.defineProperty(equal, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal$1 = requireFastDeepEqual();
	equal$1.code = 'require("ajv/dist/runtime/equal").default';
	equal.default = equal$1;
	
	return equal;
}

var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	Object.defineProperty(uniqueItems, "__esModule", { value: true });
	const dataType_1 = requireDataType();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems.default = def;
	
	return uniqueItems;
}

var _const = {};

var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	Object.defineProperty(_const, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const.default = def;
	
	return _const;
}

var _enum$1 = {};

var hasRequired_enum$1;

function require_enum$1 () {
	if (hasRequired_enum$1) return _enum$1;
	hasRequired_enum$1 = 1;
	Object.defineProperty(_enum$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum$1.default = def;
	
	return _enum$1;
}

var hasRequiredValidation$3;

function requireValidation$3 () {
	if (hasRequiredValidation$3) return validation$3;
	hasRequiredValidation$3 = 1;
	Object.defineProperty(validation$3, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber();
	const multipleOf_1 = requireMultipleOf();
	const limitLength_1 = requireLimitLength();
	const pattern_1 = requirePattern$1();
	const limitProperties_1 = requireLimitProperties();
	const required_1 = requireRequired();
	const limitItems_1 = requireLimitItems();
	const uniqueItems_1 = requireUniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum$1();
	const validation = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation$3.default = validation;
	
	return validation$3;
}

var applicator = {};

var additionalItems = {};

var hasRequiredAdditionalItems;

function requireAdditionalItems () {
	if (hasRequiredAdditionalItems) return additionalItems;
	hasRequiredAdditionalItems = 1;
	Object.defineProperty(additionalItems, "__esModule", { value: true });
	additionalItems.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems.validateAdditionalItems = validateAdditionalItems;
	additionalItems.default = def;
	
	return additionalItems;
}

var prefixItems = {};

var items = {};

var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	Object.defineProperty(items, "__esModule", { value: true });
	items.validateTuple = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items.validateTuple = validateTuple;
	items.default = def;
	
	return items;
}

var hasRequiredPrefixItems;

function requirePrefixItems () {
	if (hasRequiredPrefixItems) return prefixItems;
	hasRequiredPrefixItems = 1;
	Object.defineProperty(prefixItems, "__esModule", { value: true });
	const items_1 = requireItems();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems.default = def;
	
	return prefixItems;
}

var items2020 = {};

var hasRequiredItems2020;

function requireItems2020 () {
	if (hasRequiredItems2020) return items2020;
	hasRequiredItems2020 = 1;
	Object.defineProperty(items2020, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const additionalItems_1 = requireAdditionalItems();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020.default = def;
	
	return items2020;
}

var contains = {};

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	Object.defineProperty(contains, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains.default = def;
	
	return contains;
}

var dependencies = {};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const code_1 = requireCode();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies));
	return dependencies;
}

var propertyNames = {};

var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	Object.defineProperty(propertyNames, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames.default = def;
	
	return propertyNames;
}

var additionalProperties = {};

var hasRequiredAdditionalProperties;

function requireAdditionalProperties () {
	if (hasRequiredAdditionalProperties) return additionalProperties;
	hasRequiredAdditionalProperties = 1;
	Object.defineProperty(additionalProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties.default = def;
	
	return additionalProperties;
}

var properties$2 = {};

var hasRequiredProperties$1;

function requireProperties$1 () {
	if (hasRequiredProperties$1) return properties$2;
	hasRequiredProperties$1 = 1;
	Object.defineProperty(properties$2, "__esModule", { value: true });
	const validate_1 = requireValidate();
	const code_1 = requireCode();
	const util_1 = requireUtil$1();
	const additionalProperties_1 = requireAdditionalProperties();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$2.default = def;
	
	return properties$2;
}

var patternProperties = {};

var hasRequiredPatternProperties;

function requirePatternProperties () {
	if (hasRequiredPatternProperties) return patternProperties;
	hasRequiredPatternProperties = 1;
	Object.defineProperty(patternProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const util_2 = requireUtil$1();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties.default = def;
	
	return patternProperties;
}

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not.default = def;
	
	return not;
}

var anyOf = {};

var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	Object.defineProperty(anyOf, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf.default = def;
	
	return anyOf;
}

var oneOf = {};

var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	Object.defineProperty(oneOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf.default = def;
	
	return oneOf;
}

var allOf = {};

var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	Object.defineProperty(allOf, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf.default = def;
	
	return allOf;
}

var _if = {};

var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	Object.defineProperty(_if, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if.default = def;
	
	return _if;
}

var thenElse = {};

var hasRequiredThenElse;

function requireThenElse () {
	if (hasRequiredThenElse) return thenElse;
	hasRequiredThenElse = 1;
	Object.defineProperty(thenElse, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse.default = def;
	
	return thenElse;
}

var hasRequiredApplicator;

function requireApplicator () {
	if (hasRequiredApplicator) return applicator;
	hasRequiredApplicator = 1;
	Object.defineProperty(applicator, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems();
	const prefixItems_1 = requirePrefixItems();
	const items_1 = requireItems();
	const items2020_1 = requireItems2020();
	const contains_1 = requireContains();
	const dependencies_1 = requireDependencies();
	const propertyNames_1 = requirePropertyNames();
	const additionalProperties_1 = requireAdditionalProperties();
	const properties_1 = requireProperties$1();
	const patternProperties_1 = requirePatternProperties();
	const not_1 = requireNot();
	const anyOf_1 = requireAnyOf();
	const oneOf_1 = requireOneOf();
	const allOf_1 = requireAllOf();
	const if_1 = require_if();
	const thenElse_1 = requireThenElse();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator.default = getApplicator;
	
	return applicator;
}

var format$1 = {};

var format = {};

var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format;
	hasRequiredFormat$1 = 1;
	Object.defineProperty(format, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format.default = def;
	
	return format;
}

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format$1;
	hasRequiredFormat = 1;
	Object.defineProperty(format$1, "__esModule", { value: true });
	const format_1 = requireFormat$1();
	const format = [format_1.default];
	format$1.default = format;
	
	return format$1;
}

var metadata$1 = {};

var hasRequiredMetadata$1;

function requireMetadata$1 () {
	if (hasRequiredMetadata$1) return metadata$1;
	hasRequiredMetadata$1 = 1;
	Object.defineProperty(metadata$1, "__esModule", { value: true });
	metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
	metadata$1.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata$1.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata$1;
}

var hasRequiredDraft7;

function requireDraft7 () {
	if (hasRequiredDraft7) return draft7;
	hasRequiredDraft7 = 1;
	Object.defineProperty(draft7, "__esModule", { value: true });
	const core_1 = requireCore();
	const validation_1 = requireValidation$3();
	const applicator_1 = requireApplicator();
	const format_1 = requireFormat();
	const metadata_1 = requireMetadata$1();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7.default = draft7Vocabularies;
	
	return draft7;
}

var discriminator$1 = {};

var types$3 = {};

var hasRequiredTypes$3;

function requireTypes$3 () {
	if (hasRequiredTypes$3) return types$3;
	hasRequiredTypes$3 = 1;
	Object.defineProperty(types$3, "__esModule", { value: true });
	types$3.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types$3.DiscrError = DiscrError = {}));
	
	return types$3;
}

var hasRequiredDiscriminator$1;

function requireDiscriminator$1 () {
	if (hasRequiredDiscriminator$1) return discriminator$1;
	hasRequiredDiscriminator$1 = 1;
	Object.defineProperty(discriminator$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const types_1 = requireTypes$3();
	const compile_1 = requireCompile();
	const ref_error_1 = requireRef_error();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator$1.default = def;
	
	return discriminator$1;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$1 = [
	"object",
	"boolean"
];
var properties$1 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3$1 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type$1,
	properties: properties$1,
	"default": true
};

var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv.exports;
	hasRequiredAjv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const draft7_1 = requireDraft7();
		const discriminator_1 = requireDiscriminator$1();
		const draft7MetaSchema = require$$3$1;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv, ajv.exports));
	return ajv.exports;
}

var ajvExports = requireAjv();

const configSchema = {
  type: "object",
  properties: {
    host: { type: "string" },
    port: { type: "number" },
    workers: { type: "number" },
    logLevel: { type: "string" },
    reverseProxy: { type: "boolean" },
    swaggerApi: { type: "string" },
    redirect: { type: "string" },
    healthyAge: { type: "number" },
    interval: { type: "number" },
    ratelimit: { type: "number" },
    concurrency: { type: "number" },
    maxBodySize: { type: "number" },
    blockRefresh: { type: "number" },
    maxBlockRange: { type: "number" },
    backends: {
      type: "array",
      minItems: 1,
      items: {
        type: "object",
        properties: {
          chain: { type: "string" },
          url: { type: "string" },
          wsUrl: { type: "string" },
          trace: { type: "boolean" },
          filter: { type: "boolean" },
          timeout: { type: "number" }
        },
        required: ["chain", "url"]
      }
    }
  },
  required: ["backends"]
};
function getConfig() {
  const configFile = process.env.CONFIG_FILE || "config.json";
  if (!require$$0$2.existsSync(configFile)) {
    throw new Error("Config file not found");
  }
  const config = JSON.parse(require$$0$2.readFileSync(configFile, { encoding: "utf8" }));
  const ajv = new ajvExports.Ajv();
  if (!ajv.compile(configSchema)(config)) {
    throw new Error("Invalid config, check the config.example.json and verify if config is valid");
  }
  config.host = config.host || "127.0.0.1";
  config.port = config.port || 8544;
  config.workers = config.workers || os.cpus().length;
  config.logLevel = config.logLevel || "debug";
  config.reverseProxy = config.reverseProxy ?? true;
  config.healthyAge = config.healthyAge || 1800;
  config.interval = config.interval || 60;
  config.ratelimit = config.ratelimit || 100;
  config.concurrency = config.concurrency || 50;
  config.maxBodySize = config.maxBodySize || 10485760;
  for (const backend of config.backends) {
    backend.timeout = backend.timeout || 120;
  }
  config.backendGroup = config.backends.reduce(
    (acc, curr) => {
      if (!acc[curr.chain]) {
        acc[curr.chain] = [];
      }
      acc[curr.chain].push(curr);
      return acc;
    },
    {}
  );
  return config;
}

var fastify = {exports: {}};

var queue = {exports: {}};

var reusify_1;
var hasRequiredReusify;

function requireReusify () {
	if (hasRequiredReusify) return reusify_1;
	hasRequiredReusify = 1;

	function reusify (Constructor) {
	  var head = new Constructor();
	  var tail = head;

	  function get () {
	    var current = head;

	    if (current.next) {
	      head = current.next;
	    } else {
	      head = new Constructor();
	      tail = head;
	    }

	    current.next = null;

	    return current
	  }

	  function release (obj) {
	    tail.next = obj;
	    tail = obj;
	  }

	  return {
	    get: get,
	    release: release
	  }
	}

	reusify_1 = reusify;
	return reusify_1;
}

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue.exports;
	hasRequiredQueue = 1;

	/* eslint-disable no-var */

	var reusify = requireReusify();

	function fastqueue (context, worker, _concurrency) {
	  if (typeof context === 'function') {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }

	  if (!(_concurrency >= 1)) {
	    throw new Error('fastqueue concurrency must be equal to or greater than 1')
	  }

	  var cache = reusify(Task);
	  var queueHead = null;
	  var queueTail = null;
	  var _running = 0;
	  var errorHandler = null;

	  var self = {
	    push: push,
	    drain: noop,
	    saturated: noop,
	    pause: pause,
	    paused: false,

	    get concurrency () {
	      return _concurrency
	    },
	    set concurrency (value) {
	      if (!(value >= 1)) {
	        throw new Error('fastqueue concurrency must be equal to or greater than 1')
	      }
	      _concurrency = value;

	      if (self.paused) return
	      for (; queueHead && _running < _concurrency;) {
	        _running++;
	        release();
	      }
	    },

	    running: running,
	    resume: resume,
	    idle: idle,
	    length: length,
	    getQueue: getQueue,
	    unshift: unshift,
	    empty: noop,
	    kill: kill,
	    killAndDrain: killAndDrain,
	    error: error
	  };

	  return self

	  function running () {
	    return _running
	  }

	  function pause () {
	    self.paused = true;
	  }

	  function length () {
	    var current = queueHead;
	    var counter = 0;

	    while (current) {
	      current = current.next;
	      counter++;
	    }

	    return counter
	  }

	  function getQueue () {
	    var current = queueHead;
	    var tasks = [];

	    while (current) {
	      tasks.push(current.value);
	      current = current.next;
	    }

	    return tasks
	  }

	  function resume () {
	    if (!self.paused) return
	    self.paused = false;
	    if (queueHead === null) {
	      _running++;
	      release();
	      return
	    }
	    for (; queueHead && _running < _concurrency;) {
	      _running++;
	      release();
	    }
	  }

	  function idle () {
	    return _running === 0 && self.length() === 0
	  }

	  function push (value, done) {
	    var current = cache.get();

	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;

	    if (_running >= _concurrency || self.paused) {
	      if (queueTail) {
	        queueTail.next = current;
	        queueTail = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }

	  function unshift (value, done) {
	    var current = cache.get();

	    current.context = context;
	    current.release = release;
	    current.value = value;
	    current.callback = done || noop;
	    current.errorHandler = errorHandler;

	    if (_running >= _concurrency || self.paused) {
	      if (queueHead) {
	        current.next = queueHead;
	        queueHead = current;
	      } else {
	        queueHead = current;
	        queueTail = current;
	        self.saturated();
	      }
	    } else {
	      _running++;
	      worker.call(context, current.value, current.worked);
	    }
	  }

	  function release (holder) {
	    if (holder) {
	      cache.release(holder);
	    }
	    var next = queueHead;
	    if (next && _running <= _concurrency) {
	      if (!self.paused) {
	        if (queueTail === queueHead) {
	          queueTail = null;
	        }
	        queueHead = next.next;
	        next.next = null;
	        worker.call(context, next.value, next.worked);
	        if (queueTail === null) {
	          self.empty();
	        }
	      } else {
	        _running--;
	      }
	    } else if (--_running === 0) {
	      self.drain();
	    }
	  }

	  function kill () {
	    queueHead = null;
	    queueTail = null;
	    self.drain = noop;
	  }

	  function killAndDrain () {
	    queueHead = null;
	    queueTail = null;
	    self.drain();
	    self.drain = noop;
	  }

	  function error (handler) {
	    errorHandler = handler;
	  }
	}

	function noop () {}

	function Task () {
	  this.value = null;
	  this.callback = noop;
	  this.next = null;
	  this.release = noop;
	  this.context = null;
	  this.errorHandler = null;

	  var self = this;

	  this.worked = function worked (err, result) {
	    var callback = self.callback;
	    var errorHandler = self.errorHandler;
	    var val = self.value;
	    self.value = null;
	    self.callback = noop;
	    if (self.errorHandler) {
	      errorHandler(err, val);
	    }
	    callback.call(self.context, err, result);
	    self.release(self);
	  };
	}

	function queueAsPromised (context, worker, _concurrency) {
	  if (typeof context === 'function') {
	    _concurrency = worker;
	    worker = context;
	    context = null;
	  }

	  function asyncWrapper (arg, cb) {
	    worker.call(this, arg)
	      .then(function (res) {
	        cb(null, res);
	      }, cb);
	  }

	  var queue = fastqueue(context, asyncWrapper, _concurrency);

	  var pushCb = queue.push;
	  var unshiftCb = queue.unshift;

	  queue.push = push;
	  queue.unshift = unshift;
	  queue.drained = drained;

	  return queue

	  function push (value) {
	    var p = new Promise(function (resolve, reject) {
	      pushCb(value, function (err, result) {
	        if (err) {
	          reject(err);
	          return
	        }
	        resolve(result);
	      });
	    });

	    // Let's fork the promise chain to
	    // make the error bubble up to the user but
	    // not lead to a unhandledRejection
	    p.catch(noop);

	    return p
	  }

	  function unshift (value) {
	    var p = new Promise(function (resolve, reject) {
	      unshiftCb(value, function (err, result) {
	        if (err) {
	          reject(err);
	          return
	        }
	        resolve(result);
	      });
	    });

	    // Let's fork the promise chain to
	    // make the error bubble up to the user but
	    // not lead to a unhandledRejection
	    p.catch(noop);

	    return p
	  }

	  function drained () {
	    var p = new Promise(function (resolve) {
	      process.nextTick(function () {
	        if (queue.idle()) {
	          resolve();
	        } else {
	          var previousDrain = queue.drain;
	          queue.drain = function () {
	            if (typeof previousDrain === 'function') previousDrain();
	            resolve();
	            queue.drain = previousDrain;
	          };
	        }
	      });
	    });

	    return p
	  }
	}

	queue.exports = fastqueue;
	queue.exports.promise = queueAsPromised;
	return queue.exports;
}

var error$1 = {exports: {}};

var hasRequiredError$1;

function requireError$1 () {
	if (hasRequiredError$1) return error$1.exports;
	hasRequiredError$1 = 1;

	const { format } = require$$0$3;

	function toString () {
	  return `${this.name} [${this.code}]: ${this.message}`
	}

	const FastifyGenericErrorSymbol = Symbol.for('fastify-error-generic');

	function createError (code, message, statusCode = 500, Base = Error, captureStackTrace = createError.captureStackTrace) {
	  const shouldCreateFastifyGenericError = code === FastifyGenericErrorSymbol;

	  if (shouldCreateFastifyGenericError) {
	    code = 'FST_ERR';
	  }

	  if (!code) throw new Error('Fastify error code must not be empty')
	  if (!message) throw new Error('Fastify error message must not be empty')

	  code = code.toUpperCase();
	  !statusCode && (statusCode = undefined);

	  const FastifySpecificErrorSymbol = Symbol.for(`fastify-error ${code}`);

	  function FastifyError (...args) {
	    if (!new.target) {
	      return new FastifyError(...args)
	    }

	    this.code = code;
	    this.name = 'FastifyError';
	    this.statusCode = statusCode;

	    const lastElement = args.length - 1;
	    if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === 'object' && 'cause' in args[lastElement]) {
	      this.cause = args.pop().cause;
	    }

	    this.message = format(message, ...args);

	    Error.stackTraceLimit && captureStackTrace && Error.captureStackTrace(this, FastifyError);
	  }

	  FastifyError.prototype = Object.create(Base.prototype, {
	    constructor: {
	      value: FastifyError,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    },
	    [FastifyGenericErrorSymbol]: {
	      value: true,
	      enumerable: false,
	      writable: false,
	      configurable: false
	    },
	    [FastifySpecificErrorSymbol]: {
	      value: true,
	      enumerable: false,
	      writable: false,
	      configurable: false
	    }
	  });

	  if (shouldCreateFastifyGenericError) {
	    Object.defineProperty(FastifyError, Symbol.hasInstance, {
	      value (instance) {
	        return instance && instance[FastifyGenericErrorSymbol]
	      },
	      configurable: false,
	      writable: false,
	      enumerable: false
	    });
	  } else {
	    Object.defineProperty(FastifyError, Symbol.hasInstance, {
	      value (instance) {
	        return instance && instance[FastifySpecificErrorSymbol]
	      },
	      configurable: false,
	      writable: false,
	      enumerable: false
	    });
	  }

	  FastifyError.prototype[Symbol.toStringTag] = 'Error';

	  FastifyError.prototype.toString = toString;

	  return FastifyError
	}

	createError.captureStackTrace = true;

	const FastifyErrorConstructor = createError(FastifyGenericErrorSymbol, 'Fastify Error', 500, Error);

	error$1.exports = createError;
	error$1.exports.FastifyError = FastifyErrorConstructor;
	error$1.exports.default = createError;
	error$1.exports.createError = createError;
	return error$1.exports;
}

var errors$3;
var hasRequiredErrors$3;

function requireErrors$3 () {
	if (hasRequiredErrors$3) return errors$3;
	hasRequiredErrors$3 = 1;

	const { createError } = requireError$1();

	errors$3 = {
	  AVV_ERR_EXPOSE_ALREADY_DEFINED: createError(
	    'AVV_ERR_EXPOSE_ALREADY_DEFINED',
	    "'%s' is already defined, specify an expose option for '%s'"
	  ),
	  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError(
	    'AVV_ERR_ATTRIBUTE_ALREADY_DEFINED',
	    "'%s' is already defined"
	  ),
	  AVV_ERR_CALLBACK_NOT_FN: createError(
	    'AVV_ERR_CALLBACK_NOT_FN',
	    "Callback for '%s' hook is not a function. Received: '%s'"
	  ),
	  AVV_ERR_PLUGIN_NOT_VALID: createError(
	    'AVV_ERR_PLUGIN_NOT_VALID',
	    "Plugin must be a function or a promise. Received: '%s'"
	  ),
	  AVV_ERR_ROOT_PLG_BOOTED: createError(
	    'AVV_ERR_ROOT_PLG_BOOTED',
	    'Root plugin has already booted'
	  ),
	  AVV_ERR_PARENT_PLG_LOADED: createError(
	    'AVV_ERR_PARENT_PLG_LOADED',
	    "Impossible to load '%s' plugin because the parent '%s' was already loaded"
	  ),
	  AVV_ERR_READY_TIMEOUT: createError(
	    'AVV_ERR_READY_TIMEOUT',
	    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
	  ),
	  AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError(
	    'AVV_ERR_PLUGIN_EXEC_TIMEOUT',
	    "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
	  )
	};
	return errors$3;
}

var symbols$3;
var hasRequiredSymbols$3;

function requireSymbols$3 () {
	if (hasRequiredSymbols$3) return symbols$3;
	hasRequiredSymbols$3 = 1;

	// Internal Symbols
	const kAvvio = Symbol('avvio.Boot');
	const kIsOnCloseHandler = Symbol('isOnCloseHandler');
	const kThenifyDoNotWrap = Symbol('avvio.ThenifyDoNotWrap');
	const kUntrackNode = Symbol('avvio.TimeTree.untrackNode');
	const kTrackNode = Symbol('avvio.TimeTree.trackNode');
	const kGetParent = Symbol('avvio.TimeTree.getParent');
	const kGetNode = Symbol('avvio.TimeTree.getNode');
	const kAddNode = Symbol('avvio.TimeTree.addNode');

	// Public Symbols
	const kPluginMeta = Symbol.for('plugin-meta');

	symbols$3 = {
	  kAvvio,
	  kIsOnCloseHandler,
	  kThenifyDoNotWrap,
	  kUntrackNode,
	  kTrackNode,
	  kGetParent,
	  kGetNode,
	  kAddNode,
	  kPluginMeta
	};
	return symbols$3;
}

var timeTree;
var hasRequiredTimeTree;

function requireTimeTree () {
	if (hasRequiredTimeTree) return timeTree;
	hasRequiredTimeTree = 1;

	const {
	  kUntrackNode,
	  kTrackNode,
	  kGetParent,
	  kGetNode,
	  kAddNode
	} = requireSymbols$3();

	/**
	 * Node of the TimeTree
	 * @typedef {object} TimeTreeNode
	 * @property {string} id
	 * @property {string|null} parent
	 * @property {string} label
	 * @property {Array<TimeTreeNode>} nodes
	 * @property {number} start
	 * @property {number|undefined} stop
	 * @property {number|undefined} diff
	 */

	class TimeTree {
	  constructor () {
	    /**
	     * @type {TimeTreeNode|null} root
	     * @public
	     */
	    this.root = null;

	    /**
	     * @type {Map<string, TimeTreeNode>} tableId
	     * @public
	     */
	    this.tableId = new Map();

	    /**
	     * @type {Map<string, Array<TimeTreeNode>>} tableLabel
	     * @public
	     */
	    this.tableLabel = new Map();
	  }

	  /**
	   * @param {TimeTreeNode} node
	   */
	  [kTrackNode] (node) {
	    this.tableId.set(node.id, node);
	    if (this.tableLabel.has(node.label)) {
	      this.tableLabel.get(node.label).push(node);
	    } else {
	      this.tableLabel.set(node.label, [node]);
	    }
	  }

	  /**
	   * @param {TimeTreeNode} node
	   */
	  [kUntrackNode] (node) {
	    this.tableId.delete(node.id);

	    const labelNode = this.tableLabel.get(node.label);
	    labelNode.pop();

	    if (labelNode.length === 0) {
	      this.tableLabel.delete(node.label);
	    }
	  }

	  /**
	   * @param {string} parent
	   * @returns {TimeTreeNode}
	   */
	  [kGetParent] (parent) {
	    if (parent === null) {
	      return null
	    } else if (this.tableLabel.has(parent)) {
	      const parentNode = this.tableLabel.get(parent);
	      return parentNode[parentNode.length - 1]
	    } else {
	      return null
	    }
	  }

	  /**
	   *
	   * @param {string} nodeId
	   * @returns {TimeTreeNode}
	   */
	  [kGetNode] (nodeId) {
	    return this.tableId.get(nodeId)
	  }

	  /**
	   * @param {string} parent
	   * @param {string} label
	   * @param {number} start
	   * @returns {TimeTreeNode["id"]}
	   */
	  [kAddNode] (parent, label, start) {
	    const parentNode = this[kGetParent](parent);
	    const isRoot = parentNode === null;

	    if (isRoot) {
	      this.root = {
	        parent: null,
	        id: 'root',
	        label,
	        nodes: [],
	        start,
	        stop: null,
	        diff: -1
	      };
	      this[kTrackNode](this.root);
	      return this.root.id
	    }

	    const nodeId = `${label}-${Math.random()}`;
	    /**
	     * @type {TimeTreeNode}
	     */
	    const childNode = {
	      parent,
	      id: nodeId,
	      label,
	      nodes: [],
	      start,
	      stop: null,
	      diff: -1
	    };
	    parentNode.nodes.push(childNode);
	    this[kTrackNode](childNode);
	    return nodeId
	  }

	  /**
	   * @param {string} parent
	   * @param {string} label
	   * @param {number|undefined} start
	   * @returns {TimeTreeNode["id"]}
	   */
	  start (parent, label, start = Date.now()) {
	    return this[kAddNode](parent, label, start)
	  }

	  /**
	   * @param {string} nodeId
	   * @param {number|undefined} stop
	   */
	  stop (nodeId, stop = Date.now()) {
	    const node = this[kGetNode](nodeId);
	    if (node) {
	      node.stop = stop;
	      node.diff = (node.stop - node.start) || 0;
	      this[kUntrackNode](node);
	    }
	  }

	  /**
	   * @returns {TimeTreeNode}
	   */
	  toJSON () {
	    return Object.assign({}, this.root)
	  }

	  /**
	   * @returns {string}
	   */
	  prettyPrint () {
	    return prettyPrintTimeTree(this.toJSON())
	  }
	}

	/**
	 * @param {TimeTreeNode} obj
	 * @param {string|undefined} prefix
	 * @returns {string}
	 */
	function prettyPrintTimeTree (obj, prefix = '') {
	  let result = prefix;

	  const nodesCount = obj.nodes.length;
	  const lastIndex = nodesCount - 1;
	  result += `${obj.label} ${obj.diff} ms\n`;

	  for (let i = 0; i < nodesCount; ++i) {
	    const node = obj.nodes[i];
	    const prefix_ = prefix + (i === lastIndex ? '  ' : ' ');

	    result += prefix;
	    result += (i === lastIndex ? '' : '');
	    result += (node.nodes.length === 0 ? ' ' : ' ');
	    result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
	  }
	  return result
	}

	timeTree = {
	  TimeTree
	};
	return timeTree;
}

var debug_1$1;
var hasRequiredDebug$1;

function requireDebug$1 () {
	if (hasRequiredDebug$1) return debug_1$1;
	hasRequiredDebug$1 = 1;

	const { debuglog } = require$$0$3;

	/**
	 * @callback DebugLogger
	 * @param {string} msg
	 * @param {...unknown} param
	 * @returns {void}
	 */

	/**
	 * @type {DebugLogger}
	 */
	const debug = debuglog('avvio');

	debug_1$1 = {
	  debug
	};
	return debug_1$1;
}

var createPromise_1;
var hasRequiredCreatePromise;

function requireCreatePromise () {
	if (hasRequiredCreatePromise) return createPromise_1;
	hasRequiredCreatePromise = 1;

	/**
	 * @callback PromiseResolve
	 * @param {any|PromiseLike<any>} value
	 * @returns {void}
	 */

	/**
	 * @callback PromiseReject
	 * @param {any} reason
	 * @returns {void}
	 */

	/**
	 * @typedef PromiseObject
	 * @property {Promise} promise
	 * @property {PromiseResolve} resolve
	 * @property {PromiseReject} reject
	 */

	/**
	 * @returns {PromiseObject}
	 */
	function createPromise () {
	  /**
	   * @type {PromiseObject}
	   */
	  const obj = {
	    resolve: null,
	    reject: null,
	    promise: null
	  };

	  obj.promise = new Promise((resolve, reject) => {
	    obj.resolve = resolve;
	    obj.reject = reject;
	  });

	  return obj
	}

	createPromise_1 = {
	  createPromise
	};
	return createPromise_1;
}

var getPluginName_1;
var hasRequiredGetPluginName$1;

function requireGetPluginName$1 () {
	if (hasRequiredGetPluginName$1) return getPluginName_1;
	hasRequiredGetPluginName$1 = 1;

	// this symbol is assigned by fastify-plugin
	const { kPluginMeta } = requireSymbols$3();

	/**
	 * @param {function} plugin
	 * @param {object} [options]
	 * @param {string} [options.name]
	 * @returns {string}
	 */
	function getPluginName (plugin, options) {
	  // use explicit function metadata if set
	  if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
	    return plugin[kPluginMeta].name
	  }

	  // use explicit name option if set
	  if (options && options.name) {
	    return options.name
	  }

	  // determine from the function
	  if (plugin.name) {
	    return plugin.name
	  } else {
	    // takes the first two lines of the function if nothing else works
	    return plugin.toString().split('\n').slice(0, 2).map(s => s.trim()).join(' -- ')
	  }
	}

	getPluginName_1 = {
	  getPluginName
	};
	return getPluginName_1;
}

var isPromiseLike_1;
var hasRequiredIsPromiseLike;

function requireIsPromiseLike () {
	if (hasRequiredIsPromiseLike) return isPromiseLike_1;
	hasRequiredIsPromiseLike = 1;

	/**
	 * @param {any} maybePromiseLike
	 * @returns {maybePromiseLike is PromiseLike}
	 */
	function isPromiseLike (maybePromiseLike) {
	  return (
	    maybePromiseLike !== null &&
	    typeof maybePromiseLike === 'object' &&
	    typeof maybePromiseLike.then === 'function'
	  )
	}

	isPromiseLike_1 = {
	  isPromiseLike
	};
	return isPromiseLike_1;
}

var plugin$1;
var hasRequiredPlugin$1;

function requirePlugin$1 () {
	if (hasRequiredPlugin$1) return plugin$1;
	hasRequiredPlugin$1 = 1;

	const { EventEmitter } = require$$0$4;
	const { inherits } = require$$0$3;
	const { debug } = requireDebug$1();
	const { createPromise } = requireCreatePromise();
	const { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = requireErrors$3();
	const { getPluginName } = requireGetPluginName$1();
	const { isPromiseLike } = requireIsPromiseLike();

	/**
	 * @param {*} queue
	 * @param {*} func
	 * @param {*} options
	 * @param {boolean} isAfter
	 * @param {number} [timeout]
	 */
	function Plugin (queue, func, options, isAfter, timeout) {
	  this.queue = queue;
	  this.func = func;
	  this.options = options;

	  /**
	   * @type {boolean}
	   */
	  this.isAfter = isAfter;
	  /**
	   * @type {number}
	   */
	  this.timeout = timeout;

	  /**
	   * @type {boolean}
	   */
	  this.started = false;
	  /**
	   * @type {string}
	   */
	  this.name = getPluginName(func, options);

	  this.queue.pause();

	  /**
	   * @type {Error|null}
	   */
	  this._error = null;
	  /**
	   * @type {boolean}
	   */
	  this.loaded = false;

	  this._promise = null;

	  this.startTime = null;
	}

	inherits(Plugin, EventEmitter);

	/**
	 * @callback ExecCallback
	 * @param {Error|null} execErr
	 * @returns
	 */

	/**
	 *
	 * @param {*} server
	 * @param {ExecCallback} callback
	 * @returns
	 */
	Plugin.prototype.exec = function (server, callback) {
	  debug('exec', this.name);

	  this.server = server;
	  const func = this.func;
	  const name = this.name;
	  let completed = false;

	  this.options = typeof this.options === 'function' ? this.options(this.server) : this.options;

	  let timer = null;

	  /**
	   * @param {Error} [execErr]
	   */
	  const done = (execErr) => {
	    if (completed) {
	      debug('loading complete', name);
	      return
	    }

	    this._error = execErr;

	    if (execErr) {
	      debug('exec errored', name);
	    } else {
	      debug('exec completed', name);
	    }

	    completed = true;

	    if (timer) {
	      clearTimeout(timer);
	    }

	    callback(execErr);
	  };

	  if (this.timeout > 0) {
	    debug('setting up timeout', name, this.timeout);
	    timer = setTimeout(function () {
	      debug('timed out', name);
	      timer = null;
	      const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
	      // TODO Remove reference to function
	      readyTimeoutErr.fn = func;
	      done(readyTimeoutErr);
	    }, this.timeout);
	  }

	  this.started = true;
	  this.startTime = Date.now();
	  this.emit('start', this.server ? this.server.name : null, this.name, Date.now());

	  const maybePromiseLike = func(this.server, this.options, done);

	  if (isPromiseLike(maybePromiseLike)) {
	    debug('exec: resolving promise', name);

	    maybePromiseLike.then(
	      () => process.nextTick(done),
	      (e) => process.nextTick(done, e));
	  } else if (func.length < 3) {
	    done();
	  }
	};

	/**
	 * @returns {Promise}
	 */
	Plugin.prototype.loadedSoFar = function () {
	  debug('loadedSoFar', this.name);

	  if (this.loaded) {
	    return Promise.resolve()
	  }

	  const setup = () => {
	    this.server.after((afterErr, callback) => {
	      this._error = afterErr;
	      this.queue.pause();

	      if (this._promise) {
	        if (afterErr) {
	          debug('rejecting promise', this.name, afterErr);
	          this._promise.reject(afterErr);
	        } else {
	          debug('resolving promise', this.name);
	          this._promise.resolve();
	        }
	        this._promise = null;
	      }

	      process.nextTick(callback, afterErr);
	    });
	    this.queue.resume();
	  };

	  let res;

	  if (!this._promise) {
	    this._promise = createPromise();
	    res = this._promise.promise;

	    if (!this.server) {
	      this.on('start', setup);
	    } else {
	      setup();
	    }
	  } else {
	    res = Promise.resolve();
	  }

	  return res
	};

	/**
	 * @callback EnqueueCallback
	 * @param {Error|null} enqueueErr
	 * @param {Plugin} result
	 */

	/**
	 *
	 * @param {Plugin} plugin
	 * @param {EnqueueCallback} callback
	 */
	Plugin.prototype.enqueue = function (plugin, callback) {
	  debug('enqueue', this.name, plugin.name);

	  this.emit('enqueue', this.server ? this.server.name : null, this.name, Date.now());
	  this.queue.push(plugin, callback);
	};

	/**
	 * @callback FinishCallback
	 * @param {Error|null} finishErr
	 * @returns
	 */
	/**
	 *
	 * @param {Error|null} err
	 * @param {FinishCallback} callback
	 * @returns
	 */
	Plugin.prototype.finish = function (err, callback) {
	  debug('finish', this.name, err);

	  const done = () => {
	    if (this.loaded) {
	      return
	    }

	    debug('loaded', this.name);
	    this.emit('loaded', this.server ? this.server.name : null, this.name, Date.now());
	    this.loaded = true;

	    callback(err);
	  };

	  if (err) {
	    if (this._promise) {
	      this._promise.reject(err);
	      this._promise = null;
	    }
	    done();
	    return
	  }

	  const check = () => {
	    debug('check', this.name, this.queue.length(), this.queue.running(), this._promise);
	    if (this.queue.length() === 0 && this.queue.running() === 0) {
	      if (this._promise) {
	        const wrap = () => {
	          debug('wrap');
	          queueMicrotask(check);
	        };
	        this._promise.resolve();
	        this._promise.promise.then(wrap, wrap);
	        this._promise = null;
	      } else {
	        done();
	      }
	    } else {
	      debug('delayed', this.name);
	      // finish when the queue of nested plugins to load is empty
	      this.queue.drain = () => {
	        debug('drain', this.name);
	        this.queue.drain = noop;

	        // we defer the check, as a safety net for things
	        // that might be scheduled in the loading callback
	        queueMicrotask(check);
	      };
	    }
	  };

	  queueMicrotask(check);

	  // we start loading the dependents plugins only once
	  // the current level is finished
	  this.queue.resume();
	};

	function noop () {}

	plugin$1 = {
	  Plugin
	};
	return plugin$1;
}

var validatePlugin_1;
var hasRequiredValidatePlugin;

function requireValidatePlugin () {
	if (hasRequiredValidatePlugin) return validatePlugin_1;
	hasRequiredValidatePlugin = 1;

	const { AVV_ERR_PLUGIN_NOT_VALID } = requireErrors$3();

	/**
	 * @param {any} maybePlugin
	 * @throws {AVV_ERR_PLUGIN_NOT_VALID}
	 *
	 * @returns {asserts plugin is Function|PromiseLike}
	 */
	function validatePlugin (maybePlugin) {
	  // validate if plugin is a function or Promise
	  if (!(maybePlugin && (typeof maybePlugin === 'function' || typeof maybePlugin.then === 'function'))) {
	    if (Array.isArray(maybePlugin)) {
	      throw new AVV_ERR_PLUGIN_NOT_VALID('array')
	    } else if (maybePlugin === null) {
	      throw new AVV_ERR_PLUGIN_NOT_VALID('null')
	    } else {
	      throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin)
	    }
	  }
	}

	validatePlugin_1 = {
	  validatePlugin
	};
	return validatePlugin_1;
}

var isBundledOrTypescriptPlugin_1;
var hasRequiredIsBundledOrTypescriptPlugin;

function requireIsBundledOrTypescriptPlugin () {
	if (hasRequiredIsBundledOrTypescriptPlugin) return isBundledOrTypescriptPlugin_1;
	hasRequiredIsBundledOrTypescriptPlugin = 1;

	/**
	 * bundled or typescript plugin
	 * @typedef {object} BundledOrTypescriptPlugin
	 * @property {function} default
	 */

	/**
	 * @param {any} maybeBundledOrTypescriptPlugin
	 * @returns {plugin is BundledOrTypescriptPlugin}
	 */
	function isBundledOrTypescriptPlugin (maybeBundledOrTypescriptPlugin) {
	  return (
	    maybeBundledOrTypescriptPlugin !== null &&
	    typeof maybeBundledOrTypescriptPlugin === 'object' &&
	    typeof maybeBundledOrTypescriptPlugin.default === 'function'
	  )
	}

	isBundledOrTypescriptPlugin_1 = {
	  isBundledOrTypescriptPlugin
	};
	return isBundledOrTypescriptPlugin_1;
}

var thenify_1;
var hasRequiredThenify;

function requireThenify () {
	if (hasRequiredThenify) return thenify_1;
	hasRequiredThenify = 1;

	const { debug } = requireDebug$1();
	const { kThenifyDoNotWrap } = requireSymbols$3();

	/**
	 * @callback PromiseConstructorLikeResolve
	 * @param {any} value
	 * @returns {void}
	 */

	/**
	 * @callback PromiseConstructorLikeReject
	 * @param {reason} error
	 * @returns {void}
	 */

	/**
	 * @callback PromiseConstructorLike
	 * @param {PromiseConstructorLikeResolve} resolve
	 * @param {PromiseConstructorLikeReject} reject
	 * @returns {void}
	 */

	/**
	 * @returns {PromiseConstructorLike}
	 */
	function thenify () {
	  // If the instance is ready, then there is
	  // nothing to await. This is true during
	  // await server.ready() as ready() resolves
	  // with the server, end we will end up here
	  // because of automatic promise chaining.
	  if (this.booted) {
	    debug('thenify returning undefined because we are already booted');
	    return
	  }

	  // Calling resolve(this._server) would fetch the then
	  // property on the server, which will lead it here.
	  // If we do not break the recursion, we will loop
	  // forever.
	  if (this[kThenifyDoNotWrap]) {
	    this[kThenifyDoNotWrap] = false;
	    return
	  }

	  debug('thenify');
	  return (resolve, reject) => {
	    const p = this._loadRegistered();
	    return p.then(() => {
	      this[kThenifyDoNotWrap] = true;
	      return resolve(this._server)
	    }, reject)
	  }
	}

	thenify_1 = {
	  thenify
	};
	return thenify_1;
}

var executeWithThenable_1;
var hasRequiredExecuteWithThenable;

function requireExecuteWithThenable () {
	if (hasRequiredExecuteWithThenable) return executeWithThenable_1;
	hasRequiredExecuteWithThenable = 1;
	const { isPromiseLike } = requireIsPromiseLike();
	const { kAvvio } = requireSymbols$3();

	/**
	 * @callback ExecuteWithThenableCallback
	 * @param {Error} error
	 * @returns {void}
	 */

	/**
	 * @param {Function} func
	 * @param {Array<any>} args
	 * @param {ExecuteWithThenableCallback} [callback]
	 */
	function executeWithThenable (func, args, callback) {
	  const result = func.apply(func, args);
	  if (isPromiseLike(result) && !result[kAvvio]) {
	    // process promise but not avvio mock thenable
	    result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
	  } else if (callback) {
	    process.nextTick(callback);
	  }
	}

	executeWithThenable_1 = {
	  executeWithThenable
	};
	return executeWithThenable_1;
}

var boot;
var hasRequiredBoot;

function requireBoot () {
	if (hasRequiredBoot) return boot;
	hasRequiredBoot = 1;

	const fastq = requireQueue();
	const EE = require$$0$4.EventEmitter;
	const inherits = require$$0$3.inherits;
	const {
	  AVV_ERR_EXPOSE_ALREADY_DEFINED,
	  AVV_ERR_CALLBACK_NOT_FN,
	  AVV_ERR_ROOT_PLG_BOOTED,
	  AVV_ERR_READY_TIMEOUT,
	  AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
	} = requireErrors$3();
	const {
	  kAvvio,
	  kIsOnCloseHandler
	} = requireSymbols$3();
	const { TimeTree } = requireTimeTree();
	const { Plugin } = requirePlugin$1();
	const { debug } = requireDebug$1();
	const { validatePlugin } = requireValidatePlugin();
	const { isBundledOrTypescriptPlugin } = requireIsBundledOrTypescriptPlugin();
	const { isPromiseLike } = requireIsPromiseLike();
	const { thenify } = requireThenify();
	const { executeWithThenable } = requireExecuteWithThenable();

	function Boot (server, opts, done) {
	  if (typeof server === 'function' && arguments.length === 1) {
	    done = server;
	    opts = {};
	    server = null;
	  }

	  if (typeof opts === 'function') {
	    done = opts;
	    opts = {};
	  }

	  opts = opts || {};
	  opts.autostart = opts.autostart !== false;
	  opts.timeout = Number(opts.timeout) || 0;
	  opts.expose = opts.expose || {};

	  if (!new.target) {
	    return new Boot(server, opts, done)
	  }

	  this._server = server || this;
	  this._opts = opts;

	  if (server) {
	    this._expose();
	  }

	  /**
	   * @type {Array<Plugin>}
	   */
	  this._current = [];

	  this._error = null;

	  this._lastUsed = null;

	  this.setMaxListeners(0);

	  if (done) {
	    this.once('start', done);
	  }

	  this.started = false;
	  this.booted = false;
	  this.pluginTree = new TimeTree();

	  this._readyQ = fastq(this, callWithCbOrNextTick, 1);
	  this._readyQ.pause();
	  this._readyQ.drain = () => {
	    this.emit('start');
	    // nooping this, we want to emit start only once
	    this._readyQ.drain = noop;
	  };

	  this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
	  this._closeQ.pause();
	  this._closeQ.drain = () => {
	    this.emit('close');
	    // nooping this, we want to emit close only once
	    this._closeQ.drain = noop;
	  };

	  this._doStart = null;

	  const instance = this;
	  this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root (server, opts, done) {
	    instance._doStart = done;
	    opts.autostart && instance.start();
	  }, opts, false, 0);

	  this._trackPluginLoading(this._root);

	  this._loadPlugin(this._root, (err) => {
	    debug('root plugin ready');
	    try {
	      this.emit('preReady');
	      this._root = null;
	    } catch (preReadyError) {
	      err = err || this._error || preReadyError;
	    }

	    if (err) {
	      this._error = err;
	      if (this._readyQ.length() === 0) {
	        throw err
	      }
	    } else {
	      this.booted = true;
	    }
	    this._readyQ.resume();
	  });
	}

	inherits(Boot, EE);

	Boot.prototype.start = function () {
	  this.started = true;

	  // we need to wait any call to use() to happen
	  process.nextTick(this._doStart);
	  return this
	};

	// allows to override the instance of a server, given a plugin
	Boot.prototype.override = function (server, func, opts) {
	  return server
	};

	Boot.prototype[kAvvio] = true;

	// load a plugin
	Boot.prototype.use = function (plugin, opts) {
	  this._lastUsed = this._addPlugin(plugin, opts, false);
	  return this
	};

	Boot.prototype._loadRegistered = function () {
	  const plugin = this._current[0];
	  const weNeedToStart = !this.started && !this.booted;

	  // if the root plugin is not loaded, let's resume that
	  // so one can use after() before calling ready
	  if (weNeedToStart) {
	    process.nextTick(() => this._root.queue.resume());
	  }

	  if (!plugin) {
	    return Promise.resolve()
	  }

	  return plugin.loadedSoFar()
	};

	Object.defineProperty(Boot.prototype, 'then', { get: thenify });

	Boot.prototype._addPlugin = function (pluginFn, opts, isAfter) {
	  if (isBundledOrTypescriptPlugin(pluginFn)) {
	    pluginFn = pluginFn.default;
	  }
	  validatePlugin(pluginFn);
	  opts = opts || {};

	  if (this.booted) {
	    throw new AVV_ERR_ROOT_PLG_BOOTED()
	  }

	  // we always add plugins to load at the current element
	  const current = this._current[0];

	  let timeout = this._opts.timeout;

	  if (!current.loaded && current.timeout > 0) {
	    const delta = Date.now() - current.startTime;
	    // We need to decrease it by 3ms to make sure the internal timeout
	    // is triggered earlier than the parent
	    timeout = current.timeout - (delta + 3);
	  }

	  const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
	  this._trackPluginLoading(plugin);

	  if (current.loaded) {
	    throw new Error(plugin.name, current.name)
	  }

	  // we add the plugin to be loaded at the end of the current queue
	  current.enqueue(plugin, (err) => { err && (this._error = err); });

	  return plugin
	};

	Boot.prototype._expose = function _expose () {
	  const instance = this;
	  const server = instance._server;
	  const {
	    use: useKey = 'use',
	    after: afterKey = 'after',
	    ready: readyKey = 'ready',
	    onClose: onCloseKey = 'onClose',
	    close: closeKey = 'close'
	  } = this._opts.expose;

	  if (server[useKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, 'use')
	  }
	  server[useKey] = function (fn, opts) {
	    instance.use(fn, opts);
	    return this
	  };

	  if (server[afterKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, 'after')
	  }
	  server[afterKey] = function (func) {
	    if (typeof func !== 'function') {
	      return instance._loadRegistered()
	    }
	    instance.after(encapsulateThreeParam(func, this));
	    return this
	  };

	  if (server[readyKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, 'ready')
	  }
	  server[readyKey] = function (func) {
	    if (func && typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func)
	    }
	    return instance.ready(func ? encapsulateThreeParam(func, this) : undefined)
	  };

	  if (server[onCloseKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, 'onClose')
	  }
	  server[onCloseKey] = function (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func)
	    }
	    instance.onClose(encapsulateTwoParam(func, this));
	    return this
	  };

	  if (server[closeKey]) {
	    throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, 'close')
	  }
	  server[closeKey] = function (func) {
	    if (func && typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func)
	    }

	    if (func) {
	      instance.close(encapsulateThreeParam(func, this));
	      return this
	    }

	    // this is a Promise
	    return instance.close()
	  };

	  if (server.then) {
	    throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED('then')
	  }
	  Object.defineProperty(server, 'then', { get: thenify.bind(instance) });

	  server[kAvvio] = true;
	};

	Boot.prototype.after = function (func) {
	  if (!func) {
	    return this._loadRegistered()
	  }

	  this._addPlugin(_after.bind(this), {}, true);

	  function _after (s, opts, done) {
	    callWithCbOrNextTick.call(this, func, done);
	  }

	  return this
	};

	Boot.prototype.onClose = function (func) {
	  // this is used to distinguish between onClose and close handlers
	  // because they share the same queue but must be called with different signatures

	  if (typeof func !== 'function') {
	    throw new AVV_ERR_CALLBACK_NOT_FN('onClose', typeof func)
	  }

	  func[kIsOnCloseHandler] = true;
	  this._closeQ.unshift(func, (err) => { err && (this._error = err); });

	  return this
	};

	Boot.prototype.close = function (func) {
	  let promise;

	  if (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN('close', typeof func)
	    }
	  } else {
	    promise = new Promise(function (resolve, reject) {
	      func = function (err) {
	        if (err) {
	          return reject(err)
	        }
	        resolve();
	      };
	    });
	  }

	  this.ready(() => {
	    this._error = null;
	    this._closeQ.push(func);
	    process.nextTick(this._closeQ.resume.bind(this._closeQ));
	  });

	  return promise
	};

	Boot.prototype.ready = function (func) {
	  if (func) {
	    if (typeof func !== 'function') {
	      throw new AVV_ERR_CALLBACK_NOT_FN('ready', typeof func)
	    }
	    this._readyQ.push(func);
	    queueMicrotask(this.start.bind(this));
	    return
	  }

	  return new Promise((resolve, reject) => {
	    this._readyQ.push(readyPromiseCB);
	    this.start();

	    /**
	     * The `encapsulateThreeParam` let callback function
	     * bind to the right server instance.
	     * In promises we need to track the last server
	     * instance loaded, the first one in the _current queue.
	     */
	    const relativeContext = this._current[0].server;

	    function readyPromiseCB (err, context, done) {
	      // the context is always binded to the root server
	      if (err) {
	        reject(err);
	      } else {
	        resolve(relativeContext);
	      }
	      process.nextTick(done);
	    }
	  })
	};

	/**
	 * @param {Plugin} plugin
	 * @returns {void}
	 */
	Boot.prototype._trackPluginLoading = function (plugin) {
	  const parentName = this._current[0]?.name || null;
	  plugin.once('start', (serverName, funcName, time) => {
	    const nodeId = this.pluginTree.start(parentName || null, funcName, time);
	    plugin.once('loaded', (serverName, funcName, time) => {
	      this.pluginTree.stop(nodeId, time);
	    });
	  });
	};

	Boot.prototype.prettyPrint = function () {
	  return this.pluginTree.prettyPrint()
	};

	Boot.prototype.toJSON = function () {
	  return this.pluginTree.toJSON()
	};

	/**
	 * @callback LoadPluginCallback
	 * @param {Error} [err]
	 */

	/**
	 * Load a plugin
	 *
	 * @param {Plugin} plugin
	 * @param {LoadPluginCallback} callback
	 */
	Boot.prototype._loadPlugin = function (plugin, callback) {
	  const instance = this;
	  if (isPromiseLike(plugin.func)) {
	    plugin.func.then((fn) => {
	      if (typeof fn.default === 'function') {
	        fn = fn.default;
	      }
	      plugin.func = fn;
	      this._loadPlugin(plugin, callback);
	    }, callback);
	    return
	  }

	  const last = instance._current[0];

	  // place the plugin at the top of _current
	  instance._current.unshift(plugin);

	  if (instance._error && !plugin.isAfter) {
	    debug('skipping loading of plugin as instance errored and it is not an after', plugin.name);
	    process.nextTick(execCallback);
	    return
	  }

	  let server = (last && last.server) || instance._server;

	  if (!plugin.isAfter) {
	    // Skip override for after
	    try {
	      server = instance.override(server, plugin.func, plugin.options);
	    } catch (overrideErr) {
	      debug('override errored', plugin.name);
	      return execCallback(overrideErr)
	    }
	  }

	  plugin.exec(server, execCallback);

	  function execCallback (err) {
	    plugin.finish(err, (err) => {
	      instance._current.shift();
	      callback(err);
	    });
	  }
	};

	/**
	* Delays plugin loading until the next tick to ensure any bound `_after` callbacks have a chance
	* to run prior to executing the next plugin
	*/
	Boot.prototype._loadPluginNextTick = function (plugin, callback) {
	  process.nextTick(this._loadPlugin.bind(this), plugin, callback);
	};

	function noop () { }

	function callWithCbOrNextTick (func, cb) {
	  const context = this._server;
	  const err = this._error;

	  // with this the error will appear just in the next after/ready callback
	  this._error = null;
	  if (func.length === 0) {
	    this._error = err;
	    executeWithThenable(func, [], cb);
	  } else if (func.length === 1) {
	    executeWithThenable(func, [err], cb);
	  } else {
	    if (this._opts.timeout === 0) {
	      const wrapCb = (err) => {
	        this._error = err;
	        cb(this._error);
	      };

	      if (func.length === 2) {
	        func(err, wrapCb);
	      } else {
	        func(err, context, wrapCb);
	      }
	    } else {
	      timeoutCall.call(this, func, err, context, cb);
	    }
	  }
	}

	function timeoutCall (func, rootErr, context, cb) {
	  const name = func.unwrappedName ?? func.name;
	  debug('setting up ready timeout', name, this._opts.timeout);
	  let timer = setTimeout(() => {
	    debug('timed out', name);
	    timer = null;
	    const toutErr = new AVV_ERR_READY_TIMEOUT(name);
	    toutErr.fn = func;
	    this._error = toutErr;
	    cb(toutErr);
	  }, this._opts.timeout);

	  if (func.length === 2) {
	    func(rootErr, timeoutCb.bind(this));
	  } else {
	    func(rootErr, context, timeoutCb.bind(this));
	  }

	  function timeoutCb (err) {
	    if (timer) {
	      clearTimeout(timer);
	      this._error = err;
	      cb(this._error);
	    }
	  }
	}

	function closeWithCbOrNextTick (func, cb) {
	  const context = this._server;
	  const isOnCloseHandler = func[kIsOnCloseHandler];
	  if (func.length === 0 || func.length === 1) {
	    let promise;
	    if (isOnCloseHandler) {
	      promise = func(context);
	    } else {
	      promise = func(this._error);
	    }
	    if (promise && typeof promise.then === 'function') {
	      debug('resolving close/onClose promise');
	      promise.then(
	        () => process.nextTick(cb),
	        (e) => process.nextTick(cb, e));
	    } else {
	      process.nextTick(cb);
	    }
	  } else if (func.length === 2) {
	    if (isOnCloseHandler) {
	      func(context, cb);
	    } else {
	      func(this._error, cb);
	    }
	  } else {
	    if (isOnCloseHandler) {
	      func(context, cb);
	    } else {
	      func(this._error, context, cb);
	    }
	  }
	}

	function encapsulateTwoParam (func, that) {
	  return _encapsulateTwoParam.bind(that)
	  function _encapsulateTwoParam (context, cb) {
	    let res;
	    if (func.length === 0) {
	      res = func();
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else if (func.length === 1) {
	      res = func(this);

	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else {
	      func(this, cb);
	    }
	  }
	}

	function encapsulateThreeParam (func, that) {
	  const wrapped = _encapsulateThreeParam.bind(that);
	  wrapped.unwrappedName = func.name;
	  return wrapped
	  function _encapsulateThreeParam (err, cb) {
	    let res;
	    if (!func) {
	      process.nextTick(cb);
	    } else if (func.length === 0) {
	      res = func();
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb, err);
	        }, cb);
	      } else {
	        process.nextTick(cb, err);
	      }
	    } else if (func.length === 1) {
	      res = func(err);
	      if (res && res.then) {
	        res.then(function () {
	          process.nextTick(cb);
	        }, cb);
	      } else {
	        process.nextTick(cb);
	      }
	    } else if (func.length === 2) {
	      func(err, cb);
	    } else {
	      func(err, this, cb);
	    }
	  }
	}

	boot = Boot;
	return boot;
}

var symbols$2;
var hasRequiredSymbols$2;

function requireSymbols$2 () {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;

	const keys = {
	  kAvvioBoot: Symbol('fastify.avvioBoot'),
	  kChildren: Symbol('fastify.children'),
	  kServerBindings: Symbol('fastify.serverBindings'),
	  kBodyLimit: Symbol('fastify.bodyLimit'),
	  kSupportedHTTPMethods: Symbol('fastify.acceptedHTTPMethods'),
	  kRoutePrefix: Symbol('fastify.routePrefix'),
	  kLogLevel: Symbol('fastify.logLevel'),
	  kLogSerializers: Symbol('fastify.logSerializers'),
	  kHooks: Symbol('fastify.hooks'),
	  kContentTypeParser: Symbol('fastify.contentTypeParser'),
	  kState: Symbol('fastify.state'),
	  kOptions: Symbol('fastify.options'),
	  kDisableRequestLogging: Symbol('fastify.disableRequestLogging'),
	  kPluginNameChain: Symbol('fastify.pluginNameChain'),
	  kRouteContext: Symbol('fastify.context'),
	  kGenReqId: Symbol('fastify.genReqId'),
	  // Schema
	  kSchemaController: Symbol('fastify.schemaController'),
	  kSchemaHeaders: Symbol('headers-schema'),
	  kSchemaParams: Symbol('params-schema'),
	  kSchemaQuerystring: Symbol('querystring-schema'),
	  kSchemaBody: Symbol('body-schema'),
	  kSchemaResponse: Symbol('response-schema'),
	  kSchemaErrorFormatter: Symbol('fastify.schemaErrorFormatter'),
	  kSchemaVisited: Symbol('fastify.schemas.visited'),
	  // Request
	  kRequest: Symbol('fastify.Request'),
	  kRequestPayloadStream: Symbol('fastify.RequestPayloadStream'),
	  kRequestAcceptVersion: Symbol('fastify.RequestAcceptVersion'),
	  kRequestCacheValidateFns: Symbol('fastify.request.cache.validateFns'),
	  kRequestOriginalUrl: Symbol('fastify.request.originalUrl'),
	  // 404
	  kFourOhFour: Symbol('fastify.404'),
	  kCanSetNotFoundHandler: Symbol('fastify.canSetNotFoundHandler'),
	  kFourOhFourLevelInstance: Symbol('fastify.404LogLevelInstance'),
	  kFourOhFourContext: Symbol('fastify.404ContextKey'),
	  kDefaultJsonParse: Symbol('fastify.defaultJSONParse'),
	  // Reply
	  kReply: Symbol('fastify.Reply'),
	  kReplySerializer: Symbol('fastify.reply.serializer'),
	  kReplyIsError: Symbol('fastify.reply.isError'),
	  kReplyHeaders: Symbol('fastify.reply.headers'),
	  kReplyTrailers: Symbol('fastify.reply.trailers'),
	  kReplyHasStatusCode: Symbol('fastify.reply.hasStatusCode'),
	  kReplyHijacked: Symbol('fastify.reply.hijacked'),
	  kReplyStartTime: Symbol('fastify.reply.startTime'),
	  kReplyNextErrorHandler: Symbol('fastify.reply.nextErrorHandler'),
	  kReplyEndTime: Symbol('fastify.reply.endTime'),
	  kReplyErrorHandlerCalled: Symbol('fastify.reply.errorHandlerCalled'),
	  kReplyIsRunningOnErrorHook: Symbol('fastify.reply.isRunningOnErrorHook'),
	  kReplySerializerDefault: Symbol('fastify.replySerializerDefault'),
	  kReplyCacheSerializeFns: Symbol('fastify.reply.cache.serializeFns'),
	  // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
	  kTestInternals: Symbol('fastify.testInternals'),
	  kErrorHandler: Symbol('fastify.errorHandler'),
	  kErrorHandlerAlreadySet: Symbol('fastify.errorHandlerAlreadySet'),
	  kChildLoggerFactory: Symbol('fastify.childLoggerFactory'),
	  kHasBeenDecorated: Symbol('fastify.hasBeenDecorated'),
	  kKeepAliveConnections: Symbol('fastify.keepAliveConnections'),
	  kRouteByFastify: Symbol('fastify.routeByFastify')
	};

	symbols$2 = keys;
	return symbols$2;
}

var server = {};

var processWarning$1 = {exports: {}};

var hasRequiredProcessWarning$1;

function requireProcessWarning$1 () {
	if (hasRequiredProcessWarning$1) return processWarning$1.exports;
	hasRequiredProcessWarning$1 = 1;

	const { format } = require$$0$3;

	/**
	 * @namespace processWarning
	 */

	/**
	 * Represents a warning item with details.
	 * @typedef {Function} WarningItem
	 * @param {*} [a] Possible message interpolation value.
	 * @param {*} [b] Possible message interpolation value.
	 * @param {*} [c] Possible message interpolation value.
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} emitted - Indicates if the warning has been emitted.
	 * @property {function} format - Formats the warning message.
	 */

	/**
	 * Options for creating a process warning.
	 * @typedef {Object} ProcessWarningOptions
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} [unlimited=false] - If true, allows unlimited emissions of the warning.
	 */

	/**
	 * Represents the process warning functionality.
	 * @typedef {Object} ProcessWarning
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 */

	/**
	 * Creates a deprecation warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created deprecation warning item.
	 */
	function createDeprecation (params) {
	  return createWarning({ ...params, name: 'DeprecationWarning' })
	}

	/**
	 * Creates a warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created warning item.
	 * @throws {Error} Throws an error if name, code, or message is empty, or if opts.unlimited is not a boolean.
	 */
	function createWarning ({ name, code, message, unlimited = false } = {}) {
	  if (!name) throw new Error('Warning name must not be empty')
	  if (!code) throw new Error('Warning code must not be empty')
	  if (!message) throw new Error('Warning message must not be empty')
	  if (typeof unlimited !== 'boolean') throw new Error('Warning opts.unlimited must be a boolean')

	  code = code.toUpperCase();

	  let warningContainer = {
	    [name]: function (a, b, c) {
	      if (warning.emitted === true && warning.unlimited !== true) {
	        return
	      }
	      warning.emitted = true;
	      process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	    }
	  };
	  if (unlimited) {
	    warningContainer = {
	      [name]: function (a, b, c) {
	        warning.emitted = true;
	        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	      }
	    };
	  }

	  const warning = warningContainer[name];

	  warning.emitted = false;
	  warning.message = message;
	  warning.unlimited = unlimited;
	  warning.code = code;

	  /**
	   * Formats the warning message.
	   * @param {*} [a] Possible message interpolation value.
	   * @param {*} [b] Possible message interpolation value.
	   * @param {*} [c] Possible message interpolation value.
	   * @returns {string} The formatted warning message.
	   */
	  warning.format = function (a, b, c) {
	    let formatted;
	    if (a && b && c) {
	      formatted = format(message, a, b, c);
	    } else if (a && b) {
	      formatted = format(message, a, b);
	    } else if (a) {
	      formatted = format(message, a);
	    } else {
	      formatted = message;
	    }
	    return formatted
	  };

	  return warning
	}

	/**
	 * Module exports containing the process warning functionality.
	 * @namespace
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 * @property {ProcessWarning} processWarning - Represents the process warning functionality.
	 */
	const out = { createWarning, createDeprecation };
	processWarning$1.exports = out;
	processWarning$1.exports.default = out;
	processWarning$1.exports.processWarning = out;
	return processWarning$1.exports;
}

var warnings;
var hasRequiredWarnings;

function requireWarnings () {
	if (hasRequiredWarnings) return warnings;
	hasRequiredWarnings = 1;

	const { createWarning } = requireProcessWarning$1();

	/**
	 * Deprecation codes:
	 *   - FSTWRN001
	 *   - FSTSEC001
	 *
	 * Deprecation Codes FSTDEP001 - FSTDEP021 were used by v4 and MUST NOT not be reused.
	 * Warning Codes FSTWRN001 - FSTWRN002 were used by v4 and MUST NOT not be reused.
	 */

	const FSTWRN001 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN001',
	  message: 'The %s schema for %s: %s is missing. This may indicate the schema is not well specified.',
	  unlimited: true
	});

	const FSTWRN003 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN003',
	  message: 'The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.',
	  unlimited: true
	});

	const FSTWRN004 = createWarning({
	  name: 'FastifyWarning',
	  code: 'FSTWRN004',
	  message: 'It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.',
	  unlimited: true
	});

	const FSTSEC001 = createWarning({
	  name: 'FastifySecurity',
	  code: 'FSTSEC001',
	  message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
	  unlimited: true
	});

	warnings = {
	  FSTWRN001,
	  FSTWRN003,
	  FSTWRN004,
	  FSTSEC001
	};
	return warnings;
}

var errors$2 = {exports: {}};

var hasRequiredErrors$2;

function requireErrors$2 () {
	if (hasRequiredErrors$2) return errors$2.exports;
	hasRequiredErrors$2 = 1;

	const createError = requireError$1();

	const codes = {
	  /**
	   * Basic
	   */
	  FST_ERR_NOT_FOUND: createError(
	    'FST_ERR_NOT_FOUND',
	    'Not Found',
	    404
	  ),
	  FST_ERR_OPTIONS_NOT_OBJ: createError(
	    'FST_ERR_OPTIONS_NOT_OBJ',
	    'Options must be an object',
	    500,
	    TypeError
	  ),
	  FST_ERR_QSP_NOT_FN: createError(
	    'FST_ERR_QSP_NOT_FN',
	    "querystringParser option should be a function, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError(
	    'FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN',
	    "schemaController.bucket option should be a function, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError(
	    'FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN',
	    "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
	    500,
	    TypeError
	  ),
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError(
	    'FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ',
	    "ajv.customOptions option should be an object, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError(
	    'FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR',
	    "ajv.plugins option should be an array, instead got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_VALIDATION: createError(
	    'FST_ERR_VALIDATION',
	    '%s',
	    400
	  ),
	  FST_ERR_LISTEN_OPTIONS_INVALID: createError(
	    'FST_ERR_LISTEN_OPTIONS_INVALID',
	    "Invalid listen options: '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_ERROR_HANDLER_NOT_FN: createError(
	    'FST_ERR_ERROR_HANDLER_NOT_FN',
	    'Error Handler must be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_ERROR_HANDLER_ALREADY_SET: createError(
	    'FST_ERR_ERROR_HANDLER_ALREADY_SET',
	    "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.",
	    500,
	    TypeError
	  ),

	  /**
	   * ContentTypeParser
	  */
	  FST_ERR_CTP_ALREADY_PRESENT: createError(
	    'FST_ERR_CTP_ALREADY_PRESENT',
	    "Content type parser '%s' already present."
	  ),
	  FST_ERR_CTP_INVALID_TYPE: createError(
	    'FST_ERR_CTP_INVALID_TYPE',
	    'The content type should be a string or a RegExp',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_EMPTY_TYPE: createError(
	    'FST_ERR_CTP_EMPTY_TYPE',
	    'The content type cannot be an empty string',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_INVALID_HANDLER: createError(
	    'FST_ERR_CTP_INVALID_HANDLER',
	    'The content type handler should be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_INVALID_PARSE_TYPE: createError(
	    'FST_ERR_CTP_INVALID_PARSE_TYPE',
	    "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
	    500,
	    TypeError
	  ),
	  FST_ERR_CTP_BODY_TOO_LARGE: createError(
	    'FST_ERR_CTP_BODY_TOO_LARGE',
	    'Request body is too large',
	    413,
	    RangeError
	  ),
	  FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(
	    'FST_ERR_CTP_INVALID_MEDIA_TYPE',
	    'Unsupported Media Type: %s',
	    415
	  ),
	  FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(
	    'FST_ERR_CTP_INVALID_CONTENT_LENGTH',
	    'Request body size did not match Content-Length',
	    400,
	    RangeError
	  ),
	  FST_ERR_CTP_EMPTY_JSON_BODY: createError(
	    'FST_ERR_CTP_EMPTY_JSON_BODY',
	    "Body cannot be empty when content-type is set to 'application/json'",
	    400
	  ),
	  FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError(
	    'FST_ERR_CTP_INSTANCE_ALREADY_STARTED',
	    'Cannot call "%s" when fastify instance is already started!',
	    400
	  ),

	  /**
	   * decorate
	  */
	  FST_ERR_DEC_ALREADY_PRESENT: createError(
	    'FST_ERR_DEC_ALREADY_PRESENT',
	    "The decorator '%s' has already been added!"
	  ),
	  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(
	    'FST_ERR_DEC_DEPENDENCY_INVALID_TYPE',
	    "The dependencies of decorator '%s' must be of type Array.",
	    500,
	    TypeError
	  ),
	  FST_ERR_DEC_MISSING_DEPENDENCY: createError(
	    'FST_ERR_DEC_MISSING_DEPENDENCY',
	    "The decorator is missing dependency '%s'."
	  ),
	  FST_ERR_DEC_AFTER_START: createError(
	    'FST_ERR_DEC_AFTER_START',
	    "The decorator '%s' has been added after start!"
	  ),
	  FST_ERR_DEC_REFERENCE_TYPE: createError(
	    'FST_ERR_DEC_REFERENCE_TYPE',
	    "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
	  ),
	  FST_ERR_DEC_UNDECLARED: createError(
	    'FST_ERR_DEC_UNDECLARED',
	    "No decorator '%s' has been declared on %s."
	  ),

	  /**
	   * hooks
	  */
	  FST_ERR_HOOK_INVALID_TYPE: createError(
	    'FST_ERR_HOOK_INVALID_TYPE',
	    'The hook name must be a string',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_INVALID_HANDLER: createError(
	    'FST_ERR_HOOK_INVALID_HANDLER',
	    '%s hook should be a function, instead got %s',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError(
	    'FST_ERR_HOOK_INVALID_ASYNC_HANDLER',
	    'Async function has too many arguments. Async hooks should not use the \'done\' argument.',
	    500,
	    TypeError
	  ),
	  FST_ERR_HOOK_NOT_SUPPORTED: createError(
	    'FST_ERR_HOOK_NOT_SUPPORTED',
	    '%s hook not supported!',
	    500,
	    TypeError
	  ),

	  /**
	   * Middlewares
	   */
	  FST_ERR_MISSING_MIDDLEWARE: createError(
	    'FST_ERR_MISSING_MIDDLEWARE',
	    'You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.',
	    500
	  ),

	  FST_ERR_HOOK_TIMEOUT: createError(
	    'FST_ERR_HOOK_TIMEOUT',
	    "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
	  ),

	  /**
	   * logger
	  */
	  FST_ERR_LOG_INVALID_DESTINATION: createError(
	    'FST_ERR_LOG_INVALID_DESTINATION',
	    'Cannot specify both logger.stream and logger.file options'
	  ),

	  FST_ERR_LOG_INVALID_LOGGER: createError(
	    'FST_ERR_LOG_INVALID_LOGGER',
	    "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError(
	    'FST_ERR_LOG_INVALID_LOGGER_INSTANCE',
	    'loggerInstance only accepts a logger instance.',
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError(
	    'FST_ERR_LOG_INVALID_LOGGER_CONFIG',
	    'logger options only accepts a configuration object.',
	    500,
	    TypeError
	  ),

	  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError(
	    'FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED',
	    'You cannot provide both logger and loggerInstance. Please provide only one.',
	    500,
	    TypeError
	  ),

	  /**
	   * reply
	  */
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(
	    'FST_ERR_REP_INVALID_PAYLOAD_TYPE',
	    "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
	    500,
	    TypeError
	  ),
	  FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError(
	    'FST_ERR_REP_RESPONSE_BODY_CONSUMED',
	    'Response.body is already consumed.'
	  ),
	  FST_ERR_REP_READABLE_STREAM_LOCKED: createError(
	    'FST_ERR_REP_READABLE_STREAM_LOCKED',
	    'ReadableStream was locked. You should call releaseLock() method on reader before sending.'
	  ),
	  FST_ERR_REP_ALREADY_SENT: createError(
	    'FST_ERR_REP_ALREADY_SENT',
	    'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
	  ),
	  FST_ERR_REP_SENT_VALUE: createError(
	    'FST_ERR_REP_SENT_VALUE',
	    'The only possible value for reply.sent is true.',
	    500,
	    TypeError
	  ),
	  FST_ERR_SEND_INSIDE_ONERR: createError(
	    'FST_ERR_SEND_INSIDE_ONERR',
	    'You cannot use `send` inside the `onError` hook'
	  ),
	  FST_ERR_SEND_UNDEFINED_ERR: createError(
	    'FST_ERR_SEND_UNDEFINED_ERR',
	    'Undefined error has occurred'
	  ),
	  FST_ERR_BAD_STATUS_CODE: createError(
	    'FST_ERR_BAD_STATUS_CODE',
	    'Called reply with an invalid status code: %s'
	  ),
	  FST_ERR_BAD_TRAILER_NAME: createError(
	    'FST_ERR_BAD_TRAILER_NAME',
	    'Called reply.trailer with an invalid header name: %s'
	  ),
	  FST_ERR_BAD_TRAILER_VALUE: createError(
	    'FST_ERR_BAD_TRAILER_VALUE',
	    "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
	  ),
	  FST_ERR_FAILED_ERROR_SERIALIZATION: createError(
	    'FST_ERR_FAILED_ERROR_SERIALIZATION',
	    'Failed to serialize an error. Error: %s. Original error: %s'
	  ),
	  FST_ERR_MISSING_SERIALIZATION_FN: createError(
	    'FST_ERR_MISSING_SERIALIZATION_FN',
	    'Missing serialization function. Key "%s"'
	  ),
	  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError(
	    'FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN',
	    'Missing serialization function. Key "%s:%s"'
	  ),
	  FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError(
	    'FST_ERR_REQ_INVALID_VALIDATION_INVOCATION',
	    'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
	  ),

	  /**
	   * schemas
	  */
	  FST_ERR_SCH_MISSING_ID: createError(
	    'FST_ERR_SCH_MISSING_ID',
	    'Missing schema $id property'
	  ),
	  FST_ERR_SCH_ALREADY_PRESENT: createError(
	    'FST_ERR_SCH_ALREADY_PRESENT',
	    "Schema with id '%s' already declared!"
	  ),
	  FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError(
	    'FST_ERR_SCH_CONTENT_MISSING_SCHEMA',
	    "Schema is missing for the content type '%s'"
	  ),
	  FST_ERR_SCH_DUPLICATE: createError(
	    'FST_ERR_SCH_DUPLICATE',
	    "Schema with '%s' already present!"
	  ),
	  FST_ERR_SCH_VALIDATION_BUILD: createError(
	    'FST_ERR_SCH_VALIDATION_BUILD',
	    'Failed building the validation schema for %s: %s, due to error %s'
	  ),
	  FST_ERR_SCH_SERIALIZATION_BUILD: createError(
	    'FST_ERR_SCH_SERIALIZATION_BUILD',
	    'Failed building the serialization schema for %s: %s, due to error %s'
	  ),
	  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError(
	    'FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX',
	    'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
	  ),

	  /**
	   * initialConfig
	   */
	  FST_ERR_INIT_OPTS_INVALID: createError(
	    'FST_ERR_INIT_OPTS_INVALID',
	    "Invalid initialization options: '%s'"
	  ),
	  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError(
	    'FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE',
	    "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
	  ),

	  /**
	   * router
	   */
	  FST_ERR_DUPLICATED_ROUTE: createError(
	    'FST_ERR_DUPLICATED_ROUTE',
	    "Method '%s' already declared for route '%s'"
	  ),
	  FST_ERR_BAD_URL: createError(
	    'FST_ERR_BAD_URL',
	    "'%s' is not a valid url component",
	    400,
	    URIError
	  ),
	  FST_ERR_ASYNC_CONSTRAINT: createError(
	    'FST_ERR_ASYNC_CONSTRAINT',
	    'Unexpected error from async constraint',
	    500
	  ),
	  FST_ERR_INVALID_URL: createError(
	    'FST_ERR_INVALID_URL',
	    "URL must be a string. Received '%s'",
	    400,
	    TypeError
	  ),
	  FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError(
	    'FST_ERR_ROUTE_OPTIONS_NOT_OBJ',
	    'Options for "%s:%s" route must be an object',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_DUPLICATED_HANDLER: createError(
	    'FST_ERR_ROUTE_DUPLICATED_HANDLER',
	    'Duplicate handler for "%s:%s" route is not allowed!',
	    500
	  ),
	  FST_ERR_ROUTE_HANDLER_NOT_FN: createError(
	    'FST_ERR_ROUTE_HANDLER_NOT_FN',
	    'Error Handler for %s:%s route, if defined, must be a function',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_MISSING_HANDLER: createError(
	    'FST_ERR_ROUTE_MISSING_HANDLER',
	    'Missing handler function for "%s:%s" route.',
	    500
	  ),
	  FST_ERR_ROUTE_METHOD_INVALID: createError(
	    'FST_ERR_ROUTE_METHOD_INVALID',
	    'Provided method is invalid!',
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError(
	    'FST_ERR_ROUTE_METHOD_NOT_SUPPORTED',
	    '%s method is not supported.',
	    500
	  ),
	  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError(
	    'FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED',
	    'Body validation schema for %s:%s route is not supported!',
	    500
	  ),
	  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError(
	    'FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT',
	    "'bodyLimit' option must be an integer > 0. Got '%s'",
	    500,
	    TypeError
	  ),
	  FST_ERR_ROUTE_REWRITE_NOT_STR: createError(
	    'FST_ERR_ROUTE_REWRITE_NOT_STR',
	    'Rewrite url for "%s" needs to be of type "string" but received "%s"',
	    500,
	    TypeError
	  ),

	  /**
	   *  again listen when close server
	   */
	  FST_ERR_REOPENED_CLOSE_SERVER: createError(
	    'FST_ERR_REOPENED_CLOSE_SERVER',
	    'Fastify has already been closed and cannot be reopened'
	  ),
	  FST_ERR_REOPENED_SERVER: createError(
	    'FST_ERR_REOPENED_SERVER',
	    'Fastify is already listening'
	  ),
	  FST_ERR_INSTANCE_ALREADY_LISTENING: createError(
	    'FST_ERR_INSTANCE_ALREADY_LISTENING',
	    'Fastify instance is already listening. %s'
	  ),

	  /**
	   * plugin
	   */
	  FST_ERR_PLUGIN_VERSION_MISMATCH: createError(
	    'FST_ERR_PLUGIN_VERSION_MISMATCH',
	    "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
	  ),
	  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError(
	    'FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE',
	    "The decorator '%s'%s is not present in %s"
	  ),
	  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError(
	    'FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER',
	    'The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.',
	    500,
	    TypeError
	  ),

	  /**
	   *  Avvio Errors
	   */
	  FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError(
	    'FST_ERR_PLUGIN_CALLBACK_NOT_FN',
	    'fastify-plugin: %s',
	    500,
	    TypeError
	  ),
	  FST_ERR_PLUGIN_NOT_VALID: createError(
	    'FST_ERR_PLUGIN_NOT_VALID',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_ROOT_PLG_BOOTED: createError(
	    'FST_ERR_ROOT_PLG_BOOTED',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_PARENT_PLUGIN_BOOTED: createError(
	    'FST_ERR_PARENT_PLUGIN_BOOTED',
	    'fastify-plugin: %s'
	  ),
	  FST_ERR_PLUGIN_TIMEOUT: createError(
	    'FST_ERR_PLUGIN_TIMEOUT',
	    'fastify-plugin: %s'
	  )
	};

	function appendStackTrace (oldErr, newErr) {
	  newErr.cause = oldErr;

	  return newErr
	}

	errors$2.exports = codes;
	errors$2.exports.appendStackTrace = appendStackTrace;
	errors$2.exports.AVVIO_ERRORS_MAP = {
	  AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
	  AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
	  AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
	  AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
	  AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
	  AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
	};
	return errors$2.exports;
}

var hooks;
var hasRequiredHooks;

function requireHooks () {
	if (hasRequiredHooks) return hooks;
	hasRequiredHooks = 1;

	const applicationHooks = [
	  'onRoute',
	  'onRegister',
	  'onReady',
	  'onListen',
	  'preClose',
	  'onClose'
	];
	const lifecycleHooks = [
	  'onTimeout',
	  'onRequest',
	  'preParsing',
	  'preValidation',
	  'preSerialization',
	  'preHandler',
	  'onSend',
	  'onResponse',
	  'onError',
	  'onRequestAbort'
	];
	const supportedHooks = lifecycleHooks.concat(applicationHooks);
	const {
	  FST_ERR_HOOK_INVALID_TYPE,
	  FST_ERR_HOOK_INVALID_HANDLER,
	  FST_ERR_SEND_UNDEFINED_ERR,
	  FST_ERR_HOOK_TIMEOUT,
	  FST_ERR_HOOK_NOT_SUPPORTED,
	  AVVIO_ERRORS_MAP,
	  appendStackTrace
	} = requireErrors$2();

	const {
	  kChildren,
	  kHooks,
	  kRequestPayloadStream
	} = requireSymbols$2();

	function Hooks () {
	  this.onRequest = [];
	  this.preParsing = [];
	  this.preValidation = [];
	  this.preSerialization = [];
	  this.preHandler = [];
	  this.onResponse = [];
	  this.onSend = [];
	  this.onError = [];
	  this.onRoute = [];
	  this.onRegister = [];
	  this.onReady = [];
	  this.onListen = [];
	  this.onTimeout = [];
	  this.onRequestAbort = [];
	  this.preClose = [];
	}

	Hooks.prototype = Object.create(null);

	Hooks.prototype.validate = function (hook, fn) {
	  if (typeof hook !== 'string') throw new FST_ERR_HOOK_INVALID_TYPE()
	  if (Array.isArray(this[hook]) === false) {
	    throw new FST_ERR_HOOK_NOT_SUPPORTED(hook)
	  }
	  if (typeof fn !== 'function') throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn))
	};

	Hooks.prototype.add = function (hook, fn) {
	  this.validate(hook, fn);
	  this[hook].push(fn);
	};

	function buildHooks (h) {
	  const hooks = new Hooks();
	  hooks.onRequest = h.onRequest.slice();
	  hooks.preParsing = h.preParsing.slice();
	  hooks.preValidation = h.preValidation.slice();
	  hooks.preSerialization = h.preSerialization.slice();
	  hooks.preHandler = h.preHandler.slice();
	  hooks.onSend = h.onSend.slice();
	  hooks.onResponse = h.onResponse.slice();
	  hooks.onError = h.onError.slice();
	  hooks.onRoute = h.onRoute.slice();
	  hooks.onRegister = h.onRegister.slice();
	  hooks.onTimeout = h.onTimeout.slice();
	  hooks.onRequestAbort = h.onRequestAbort.slice();
	  hooks.onReady = [];
	  hooks.onListen = [];
	  hooks.preClose = [];
	  return hooks
	}

	function hookRunnerApplication (hookName, boot, server, cb) {
	  const hooks = server[kHooks][hookName];
	  let i = 0;
	  let c = 0;

	  next();

	  function exit (err) {
	    const hookFnName = hooks[i - 1]?.name;
	    const hookFnFragment = hookFnName ? ` "${hookFnName}"` : '';

	    if (err) {
	      if (err.code === 'AVV_ERR_READY_TIMEOUT') {
	        err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
	      } else {
	        err = AVVIO_ERRORS_MAP[err.code] != null
	          ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))
	          : err;
	      }

	      cb(err);
	      return
	    }
	    cb();
	  }

	  function next (err) {
	    if (err) {
	      exit(err);
	      return
	    }

	    if (i === hooks.length && c === server[kChildren].length) {
	      if (i === 0 && c === 0) { // speed up start
	        exit();
	      } else {
	        // This is the last function executed for every fastify instance
	        boot(function manageTimeout (err, done) {
	          // this callback is needed by fastify to provide an hook interface without the error
	          // as first parameter and managing it on behalf the user
	          exit(err);

	          // this callback is needed by avvio to continue the loading of the next `register` plugins
	          done(err);
	        });
	      }
	      return
	    }

	    if (i === hooks.length && c < server[kChildren].length) {
	      const child = server[kChildren][c++];
	      hookRunnerApplication(hookName, boot, child, next);
	      return
	    }

	    boot(wrap(hooks[i++], server));
	    next();
	  }

	  function wrap (fn, server) {
	    return function (err, done) {
	      if (err) {
	        done(err);
	        return
	      }

	      if (fn.length === 1) {
	        try {
	          fn.call(server, done);
	        } catch (error) {
	          done(error);
	        }
	        return
	      }

	      try {
	        const ret = fn.call(server);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(done, done);
	          return
	        }
	      } catch (error) {
	        err = error;
	      }

	      done(err); // auto done
	    }
	  }
	}

	function onListenHookRunner (server) {
	  const hooks = server[kHooks].onListen;
	  const hooksLen = hooks.length;

	  let i = 0;
	  let c = 0;

	  next();

	  function next (err) {
	    err && server.log.error(err);

	    if (
	      i === hooksLen
	    ) {
	      while (c < server[kChildren].length) {
	        const child = server[kChildren][c++];
	        onListenHookRunner(child);
	      }
	      return
	    }

	    wrap(hooks[i++], server, next);
	  }

	  async function wrap (fn, server, done) {
	    if (fn.length === 1) {
	      try {
	        fn.call(server, done);
	      } catch (e) {
	        done(e);
	      }
	      return
	    }
	    try {
	      const ret = fn.call(server);
	      if (ret && typeof ret.then === 'function') {
	        ret.then(done, done);
	        return
	      }
	      done();
	    } catch (error) {
	      done(error);
	    }
	  }
	}

	function hookRunnerGenerator (iterator) {
	  return function hookRunner (functions, request, reply, cb) {
	    let i = 0;

	    function next (err) {
	      if (err || i === functions.length) {
	        cb(err, request, reply);
	        return
	      }

	      let result;
	      try {
	        result = iterator(functions[i++], request, reply, next);
	      } catch (error) {
	        cb(error, request, reply);
	        return
	      }
	      if (result && typeof result.then === 'function') {
	        result.then(handleResolve, handleReject);
	      }
	    }

	    function handleResolve () {
	      next();
	    }

	    function handleReject (err) {
	      if (!err) {
	        err = new FST_ERR_SEND_UNDEFINED_ERR();
	      }

	      cb(err, request, reply);
	    }

	    next();
	  }
	}

	function onResponseHookIterator (fn, request, reply, next) {
	  return fn(request, reply, next)
	}

	const onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
	const preValidationHookRunner = hookRunnerGenerator(hookIterator);
	const preHandlerHookRunner = hookRunnerGenerator(hookIterator);
	const onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
	const onRequestHookRunner = hookRunnerGenerator(hookIterator);

	function onSendHookRunner (functions, request, reply, payload, cb) {
	  let i = 0;

	  function next (err, newPayload) {
	    if (err) {
	      cb(err, request, reply, payload);
	      return
	    }

	    if (newPayload !== undefined) {
	      payload = newPayload;
	    }

	    if (i === functions.length) {
	      cb(null, request, reply, payload);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, reply, payload, next);
	    } catch (error) {
	      cb(error, request, reply);
	      return
	    }
	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve (newPayload) {
	    next(null, newPayload);
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request, reply, payload);
	  }

	  next();
	}

	const preSerializationHookRunner = onSendHookRunner;

	function preParsingHookRunner (functions, request, reply, cb) {
	  let i = 0;

	  function next (err, newPayload) {
	    if (reply.sent) {
	      return
	    }

	    if (newPayload !== undefined) {
	      request[kRequestPayloadStream] = newPayload;
	    }

	    if (err || i === functions.length) {
	      cb(err, request, reply);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, reply, request[kRequestPayloadStream], next);
	    } catch (error) {
	      cb(error, request, reply);
	      return
	    }

	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve (newPayload) {
	    next(null, newPayload);
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request, reply);
	  }

	  next();
	}

	function onRequestAbortHookRunner (functions, request, cb) {
	  let i = 0;

	  function next (err) {
	    if (err || i === functions.length) {
	      cb(err, request);
	      return
	    }

	    let result;
	    try {
	      result = functions[i++](request, next);
	    } catch (error) {
	      cb(error, request);
	      return
	    }
	    if (result && typeof result.then === 'function') {
	      result.then(handleResolve, handleReject);
	    }
	  }

	  function handleResolve () {
	    next();
	  }

	  function handleReject (err) {
	    if (!err) {
	      err = new FST_ERR_SEND_UNDEFINED_ERR();
	    }

	    cb(err, request);
	  }

	  next();
	}

	function hookIterator (fn, request, reply, next) {
	  if (reply.sent === true) return undefined
	  return fn(request, reply, next)
	}

	hooks = {
	  Hooks,
	  buildHooks,
	  hookRunnerGenerator,
	  preParsingHookRunner,
	  onResponseHookRunner,
	  onSendHookRunner,
	  preSerializationHookRunner,
	  onRequestAbortHookRunner,
	  hookIterator,
	  hookRunnerApplication,
	  onListenHookRunner,
	  preHandlerHookRunner,
	  preValidationHookRunner,
	  onRequestHookRunner,
	  onTimeoutHookRunner,
	  lifecycleHooks,
	  supportedHooks
	};
	return hooks;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;

	const http = require$$0$5;
	const https = require$$1$1;
	const http2 = require$$2;
	const dns = require$$3$2;
	const os = require$$0$6;

	const { kState, kOptions, kServerBindings } = requireSymbols$2();
	const { FSTWRN003 } = requireWarnings();
	const { onListenHookRunner } = requireHooks();
	const {
	  FST_ERR_REOPENED_CLOSE_SERVER,
	  FST_ERR_REOPENED_SERVER,
	  FST_ERR_LISTEN_OPTIONS_INVALID
	} = requireErrors$2();

	server.createServer = createServer;

	function defaultResolveServerListeningText (address) {
	  return `Server listening at ${address}`
	}

	function createServer (options, httpHandler) {
	  const server = getServerInstance(options, httpHandler);

	  // `this` is the Fastify object
	  function listen (
	    listenOptions = { port: 0, host: 'localhost' },
	    cb = undefined
	  ) {
	    if (typeof cb === 'function') {
	      if (cb.constructor.name === 'AsyncFunction') {
	        FSTWRN003('listen method');
	      }

	      listenOptions.cb = cb;
	    }
	    if (listenOptions.signal) {
	      if (typeof listenOptions.signal.on !== 'function' && typeof listenOptions.signal.addEventListener !== 'function') {
	        throw new FST_ERR_LISTEN_OPTIONS_INVALID('Invalid options.signal')
	      }

	      if (listenOptions.signal.aborted) {
	        this.close();
	      } else {
	        const onAborted = () => {
	          this.close();
	        };
	        listenOptions.signal.addEventListener('abort', onAborted, { once: true });
	      }
	    }

	    // If we have a path specified, don't default host to 'localhost' so we don't end up listening
	    // on both path and host
	    // See https://github.com/fastify/fastify/issues/4007
	    let host;
	    if (listenOptions.path == null) {
	      host = listenOptions.host ?? 'localhost';
	    } else {
	      host = listenOptions.host;
	    }
	    if (!Object.hasOwn(listenOptions, 'host') ||
	      listenOptions.host == null) {
	      listenOptions.host = host;
	    }
	    if (host === 'localhost') {
	      listenOptions.cb = (err, address) => {
	        if (err) {
	          // the server did not start
	          cb(err, address);
	          return
	        }

	        multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
	          this[kState].listening = true;
	          cb(null, address);
	          onListenHookRunner(this);
	        });
	      };
	    } else {
	      listenOptions.cb = (err, address) => {
	        // the server did not start
	        if (err) {
	          cb(err, address);
	          return
	        }
	        this[kState].listening = true;
	        cb(null, address);
	        onListenHookRunner(this);
	      };
	    }

	    // https://github.com/nodejs/node/issues/9390
	    // If listening to 'localhost', listen to both 127.0.0.1 or ::1 if they are available.
	    // If listening to 127.0.0.1, only listen to 127.0.0.1.
	    // If listening to ::1, only listen to ::1.

	    if (cb === undefined) {
	      const listening = listenPromise.call(this, server, listenOptions);
	      return listening.then(address => {
	        return new Promise((resolve, reject) => {
	          if (host === 'localhost') {
	            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
	              this[kState].listening = true;
	              resolve(address);
	              onListenHookRunner(this);
	            });
	          } else {
	            resolve(address);
	            onListenHookRunner(this);
	          }
	        })
	      })
	    }

	    this.ready(listenCallback.call(this, server, listenOptions));
	  }

	  return { server, listen }
	}

	function multipleBindings (mainServer, httpHandler, serverOpts, listenOptions, onListen) {
	  // the main server is started, we need to start the secondary servers
	  this[kState].listening = false;

	  // let's check if we need to bind additional addresses
	  dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
	    if (dnsErr) {
	      // not blocking the main server listening
	      // this.log.warn('dns.lookup error:', dnsErr)
	      onListen();
	      return
	    }

	    const isMainServerListening = mainServer.listening && serverOpts.serverFactory;

	    let binding = 0;
	    let bound = 0;
	    if (!isMainServerListening) {
	      const primaryAddress = mainServer.address();
	      for (const adr of addresses) {
	        if (adr.address !== primaryAddress.address) {
	          binding++;
	          const secondaryOpts = Object.assign({}, listenOptions, {
	            host: adr.address,
	            port: primaryAddress.port,
	            cb: (_ignoreErr) => {
	              bound++;

	              if (!_ignoreErr) {
	                this[kServerBindings].push(secondaryServer);
	              }

	              if (bound === binding) {
	                // regardless of the error, we are done
	                onListen();
	              }
	            }
	          });

	          const secondaryServer = getServerInstance(serverOpts, httpHandler);
	          const closeSecondary = () => {
	            // To avoid falling into situations where the close of the
	            // secondary server is triggered before the preClose hook
	            // is done running, we better wait until the main server is closed.
	            // No new TCP connections are accepted
	            // We swallow any error from the secondary server
	            secondaryServer.close(() => {});
	            if (typeof secondaryServer.closeAllConnections === 'function' && serverOpts.forceCloseConnections === true) {
	              secondaryServer.closeAllConnections();
	            }
	          };

	          secondaryServer.on('upgrade', mainServer.emit.bind(mainServer, 'upgrade'));
	          mainServer.on('unref', closeSecondary);
	          mainServer.on('close', closeSecondary);
	          mainServer.on('error', closeSecondary);
	          this[kState].listening = false;
	          listenCallback.call(this, secondaryServer, secondaryOpts)();
	        }
	      }
	    }
	    // no extra bindings are necessary
	    if (binding === 0) {
	      onListen();
	      return
	    }

	    // in test files we are using unref so we need to propagate the unref event
	    // to the secondary servers. It is valid only when the user is
	    // listening on localhost
	    const originUnref = mainServer.unref;
	    mainServer.unref = function () {
	      originUnref.call(mainServer);
	      mainServer.emit('unref');
	    };
	  });
	}

	function listenCallback (server, listenOptions) {
	  const wrap = (err) => {
	    server.removeListener('error', wrap);
	    server.removeListener('listening', wrap);
	    if (!err) {
	      const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
	      listenOptions.cb(null, address);
	    } else {
	      this[kState].listening = false;
	      listenOptions.cb(err, null);
	    }
	  };

	  return (err) => {
	    if (err != null) return listenOptions.cb(err)

	    if (this[kState].listening && this[kState].closing) {
	      return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null)
	    }
	    if (this[kState].listening) {
	      return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null)
	    }

	    server.once('error', wrap);
	    if (!this[kState].closing) {
	      server.once('listening', wrap);
	      server.listen(listenOptions);
	      this[kState].listening = true;
	    }
	  }
	}

	function listenPromise (server, listenOptions) {
	  if (this[kState].listening && this[kState].closing) {
	    return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER())
	  }
	  if (this[kState].listening) {
	    return Promise.reject(new FST_ERR_REOPENED_SERVER())
	  }

	  return this.ready().then(() => {
	    let errEventHandler;
	    let listeningEventHandler;
	    function cleanup () {
	      server.removeListener('error', errEventHandler);
	      server.removeListener('listening', listeningEventHandler);
	    }
	    const errEvent = new Promise((resolve, reject) => {
	      errEventHandler = (err) => {
	        cleanup();
	        this[kState].listening = false;
	        reject(err);
	      };
	      server.once('error', errEventHandler);
	    });
	    const listeningEvent = new Promise((resolve, reject) => {
	      listeningEventHandler = () => {
	        cleanup();
	        this[kState].listening = true;
	        resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
	      };
	      server.once('listening', listeningEventHandler);
	    });

	    server.listen(listenOptions);

	    return Promise.race([
	      errEvent, // e.g invalid port range error is always emitted before the server listening
	      listeningEvent
	    ])
	  })
	}

	function getServerInstance (options, httpHandler) {
	  if (options.serverFactory) {
	    // User provided server instance
	    return options.serverFactory(httpHandler, options)
	  }

	  // We have accepted true as a valid way to init https but node requires an options obj
	  const httpsOptions = options.https === true ? {} : options.https;

	  if (options.http2) {
	    const server = typeof httpsOptions === 'object' ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
	    server.on('session', (session) => session.setTimeout(options.http2SessionTimeout, function closeSession () {
	      this.close();
	    }));

	    server.setTimeout(options.connectionTimeout);

	    return server
	  }

	  // HTTP1 server instance
	  const server = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
	  server.keepAliveTimeout = options.keepAliveTimeout;
	  server.requestTimeout = options.requestTimeout;
	  server.setTimeout(options.connectionTimeout);
	  // We treat zero as null(node default) so we do not pass zero to the server instance
	  if (options.maxRequestsPerSocket > 0) {
	    server.maxRequestsPerSocket = options.maxRequestsPerSocket;
	  }

	  return server
	}

	/**
	 * Inspects the provided `server.address` object and returns a
	 * normalized list of IP address strings. Normalization in this
	 * case refers to mapping wildcard `0.0.0.0` to the list of IP
	 * addresses the wildcard refers to.
	 *
	 * @see https://nodejs.org/docs/latest/api/net.html#serveraddress
	 *
	 * @param {object} A server address object as described in the
	 * linked docs.
	 *
	 * @returns {string[]}
	 */
	function getAddresses (address) {
	  if (address.address === '0.0.0.0') {
	    return Object.values(os.networkInterfaces()).flatMap((iface) => {
	      return iface.filter((iface) => iface.family === 'IPv4')
	    }).sort((iface) => {
	      /* c8 ignore next 2 */
	      // Order the interfaces so that internal ones come first
	      return iface.internal ? -1 : 1
	    }).map((iface) => { return iface.address })
	  }
	  return [address.address]
	}

	function logServerAddress (server, listenTextResolver) {
	  let addresses;
	  const isUnixSocket = typeof server.address() === 'string';
	  if (!isUnixSocket) {
	    if (server.address().address.indexOf(':') === -1) {
	      // IPv4
	      addresses = getAddresses(server.address()).map((address) => address + ':' + server.address().port);
	    } else {
	      // IPv6
	      addresses = ['[' + server.address().address + ']:' + server.address().port];
	    }

	    addresses = addresses.map((address) => ('http' + (this[kOptions].https ? 's' : '') + '://') + address);
	  } else {
	    addresses = [server.address()];
	  }

	  for (const address of addresses) {
	    this.log.info(listenTextResolver(address));
	  }
	  return addresses[0]
	}
	return server;
}

var reply = {exports: {}};

var handleRequest = {exports: {}};

var validation$2;
var hasRequiredValidation$2;

function requireValidation$2 () {
	if (hasRequiredValidation$2) return validation$2;
	hasRequiredValidation$2 = 1;

	const {
	  kSchemaHeaders: headersSchema,
	  kSchemaParams: paramsSchema,
	  kSchemaQuerystring: querystringSchema,
	  kSchemaBody: bodySchema,
	  kSchemaResponse: responseSchema
	} = requireSymbols$2();
	const scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;

	const {
	  FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
	} = requireErrors$2();

	const { FSTWRN001 } = requireWarnings();

	function compileSchemasForSerialization (context, compile) {
	  if (!context.schema || !context.schema.response) {
	    return
	  }
	  const { method, url } = context.config || {};
	  context[responseSchema] = Object.keys(context.schema.response)
	    .reduce(function (acc, statusCode) {
	      const schema = context.schema.response[statusCode];
	      statusCode = statusCode.toLowerCase();
	      if (!scChecker.test(statusCode)) {
	        throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX()
	      }

	      if (schema.content) {
	        const contentTypesSchemas = {};
	        for (const mediaName of Object.keys(schema.content)) {
	          const contentSchema = schema.content[mediaName].schema;
	          contentTypesSchemas[mediaName] = compile({
	            schema: contentSchema,
	            url,
	            method,
	            httpStatus: statusCode,
	            contentType: mediaName
	          });
	        }
	        acc[statusCode] = contentTypesSchemas;
	      } else {
	        acc[statusCode] = compile({
	          schema,
	          url,
	          method,
	          httpStatus: statusCode
	        });
	      }

	      return acc
	    }, {});
	}

	function compileSchemasForValidation (context, compile, isCustom) {
	  const { schema } = context;
	  if (!schema) {
	    return
	  }

	  const { method, url } = context.config || {};

	  const headers = schema.headers;
	  // the or part is used for backward compatibility
	  if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
	    // do not mess with schema when custom validator applied, e.g. Joi, Typebox
	    context[headersSchema] = compile({ schema: headers, method, url, httpPart: 'headers' });
	  } else if (headers) {
	    // The header keys are case insensitive
	    //  https://datatracker.ietf.org/doc/html/rfc2616#section-4.2
	    const headersSchemaLowerCase = {};
	    Object.keys(headers).forEach(k => { headersSchemaLowerCase[k] = headers[k]; });
	    if (headersSchemaLowerCase.required instanceof Array) {
	      headersSchemaLowerCase.required = headersSchemaLowerCase.required.map(h => h.toLowerCase());
	    }
	    if (headers.properties) {
	      headersSchemaLowerCase.properties = {};
	      Object.keys(headers.properties).forEach(k => {
	        headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
	      });
	    }
	    context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: 'headers' });
	  } else if (Object.hasOwn(schema, 'headers')) {
	    FSTWRN001('headers', method, url);
	  }

	  if (schema.body) {
	    const contentProperty = schema.body.content;
	    if (contentProperty) {
	      const contentTypeSchemas = {};
	      for (const contentType of Object.keys(contentProperty)) {
	        const contentSchema = contentProperty[contentType].schema;
	        contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url, httpPart: 'body', contentType });
	      }
	      context[bodySchema] = contentTypeSchemas;
	    } else {
	      context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: 'body' });
	    }
	  } else if (Object.hasOwn(schema, 'body')) {
	    FSTWRN001('body', method, url);
	  }

	  if (schema.querystring) {
	    context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: 'querystring' });
	  } else if (Object.hasOwn(schema, 'querystring')) {
	    FSTWRN001('querystring', method, url);
	  }

	  if (schema.params) {
	    context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: 'params' });
	  } else if (Object.hasOwn(schema, 'params')) {
	    FSTWRN001('params', method, url);
	  }
	}

	function validateParam (validatorFunction, request, paramName) {
	  const isUndefined = request[paramName] === undefined;
	  const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);

	  if (ret && typeof ret.then === 'function') {
	    return ret
	      .then((res) => { return answer(res) })
	      .catch(err => { return err }) // return as simple error (not throw)
	  }

	  return answer(ret)

	  function answer (ret) {
	    if (ret === false) return validatorFunction.errors
	    if (ret && ret.error) return ret.error
	    if (ret && ret.value) request[paramName] = ret.value;
	    return false
	  }
	}

	function validate (context, request, execution) {
	  const runExecution = execution === undefined;

	  if (runExecution || !execution.skipParams) {
	    const params = validateParam(context[paramsSchema], request, 'params');
	    if (params) {
	      if (typeof params.then !== 'function') {
	        return wrapValidationError(params, 'params', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncParams(params, context, request)
	      }
	    }
	  }

	  if (runExecution || !execution.skipBody) {
	    let validatorFunction = null;
	    if (typeof context[bodySchema] === 'function') {
	      validatorFunction = context[bodySchema];
	    } else if (context[bodySchema]) {
	      // TODO: add request.contentType and reuse it here
	      const contentType = getEssenceMediaType(request.headers['content-type']);
	      const contentSchema = context[bodySchema][contentType];
	      if (contentSchema) {
	        validatorFunction = contentSchema;
	      }
	    }
	    const body = validateParam(validatorFunction, request, 'body');
	    if (body) {
	      if (typeof body.then !== 'function') {
	        return wrapValidationError(body, 'body', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncBody(body, context, request)
	      }
	    }
	  }

	  if (runExecution || !execution.skipQuery) {
	    const query = validateParam(context[querystringSchema], request, 'query');
	    if (query) {
	      if (typeof query.then !== 'function') {
	        return wrapValidationError(query, 'querystring', context.schemaErrorFormatter)
	      } else {
	        return validateAsyncQuery(query, context, request)
	      }
	    }
	  }

	  const headers = validateParam(context[headersSchema], request, 'headers');
	  if (headers) {
	    if (typeof headers.then !== 'function') {
	      return wrapValidationError(headers, 'headers', context.schemaErrorFormatter)
	    } else {
	      return validateAsyncHeaders(headers, context)
	    }
	  }

	  return false
	}

	function validateAsyncParams (validatePromise, context, request) {
	  return validatePromise
	    .then((paramsResult) => {
	      if (paramsResult) {
	        return wrapValidationError(paramsResult, 'params', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true })
	    })
	}

	function validateAsyncBody (validatePromise, context, request) {
	  return validatePromise
	    .then((bodyResult) => {
	      if (bodyResult) {
	        return wrapValidationError(bodyResult, 'body', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true, skipBody: true })
	    })
	}

	function validateAsyncQuery (validatePromise, context, request) {
	  return validatePromise
	    .then((queryResult) => {
	      if (queryResult) {
	        return wrapValidationError(queryResult, 'querystring', context.schemaErrorFormatter)
	      }

	      return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true })
	    })
	}

	function validateAsyncHeaders (validatePromise, context, request) {
	  return validatePromise
	    .then((headersResult) => {
	      if (headersResult) {
	        return wrapValidationError(headersResult, 'headers', context.schemaErrorFormatter)
	      }

	      return false
	    })
	}

	function wrapValidationError (result, dataVar, schemaErrorFormatter) {
	  if (result instanceof Error) {
	    result.statusCode = result.statusCode || 400;
	    result.code = result.code || 'FST_ERR_VALIDATION';
	    result.validationContext = result.validationContext || dataVar;
	    return result
	  }

	  const error = schemaErrorFormatter(result, dataVar);
	  error.statusCode = error.statusCode || 400;
	  error.code = error.code || 'FST_ERR_VALIDATION';
	  error.validation = result;
	  error.validationContext = dataVar;
	  return error
	}

	/**
	 * simple function to retrieve the essence media type
	 * @param {string} header
	 * @returns {string} Mimetype string.
	 */
	function getEssenceMediaType (header) {
	  if (!header) return ''
	  return header.split(/[ ;]/, 1)[0].trim().toLowerCase()
	}

	validation$2 = {
	  symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
	  compileSchemasForValidation,
	  compileSchemasForSerialization,
	  validate
	};
	return validation$2;
}

var wrapThenable_1;
var hasRequiredWrapThenable;

function requireWrapThenable () {
	if (hasRequiredWrapThenable) return wrapThenable_1;
	hasRequiredWrapThenable = 1;

	const {
	  kReplyIsError,
	  kReplyHijacked
	} = requireSymbols$2();

	const diagnostics = require$$1$2;
	const channels = diagnostics.tracingChannel('fastify.request.handler');

	function wrapThenable (thenable, reply, store) {
	  if (store) store.async = true;
	  thenable.then(function (payload) {
	    if (reply[kReplyHijacked] === true) {
	      return
	    }

	    if (store) {
	      channels.asyncStart.publish(store);
	    }

	    try {
	      // this is for async functions that are using reply.send directly
	      //
	      // since wrap-thenable will be called when using reply.send directly
	      // without actual return. the response can be sent already or
	      // the request may be terminated during the reply. in this situation,
	      // it require an extra checking of request.aborted to see whether
	      // the request is killed by client.
	      if (payload !== undefined || //
	        (reply.sent === false && //
	          reply.raw.headersSent === false &&
	          reply.request.raw.aborted === false &&
	          reply.request.socket &&
	          !reply.request.socket.destroyed
	        )
	      ) {
	        // we use a try-catch internally to avoid adding a catch to another
	        // promise, increase promise perf by 10%
	        try {
	          reply.send(payload);
	        } catch (err) {
	          reply[kReplyIsError] = true;
	          reply.send(err);
	        }
	      }
	    } finally {
	      if (store) {
	        channels.asyncEnd.publish(store);
	      }
	    }
	  }, function (err) {
	    if (store) {
	      store.error = err;
	      channels.error.publish(store); // note that error happens before asyncStart
	      channels.asyncStart.publish(store);
	    }

	    try {
	      if (reply.sent === true) {
	        reply.log.error({ err }, 'Promise errored, but reply.sent = true was set');
	        return
	      }

	      reply[kReplyIsError] = true;

	      reply.send(err);
	      // The following should not happen
	      /* c8 ignore next 3 */
	    } catch (err) {
	      // try-catch allow to re-throw error in error handler for async handler
	      reply.send(err);
	    } finally {
	      if (store) {
	        channels.asyncEnd.publish(store);
	      }
	    }
	  });
	}

	wrapThenable_1 = wrapThenable;
	return wrapThenable_1;
}

var hasRequiredHandleRequest;

function requireHandleRequest () {
	if (hasRequiredHandleRequest) return handleRequest.exports;
	hasRequiredHandleRequest = 1;
	(function (module) {

		const diagnostics = require$$1$2;
		const { validate: validateSchema } = requireValidation$2();
		const { preValidationHookRunner, preHandlerHookRunner } = requireHooks();
		const wrapThenable = requireWrapThenable();
		const {
		  kReplyIsError,
		  kRouteContext,
		  kFourOhFourContext,
		  kSupportedHTTPMethods
		} = requireSymbols$2();

		const channels = diagnostics.tracingChannel('fastify.request.handler');

		function handleRequest (err, request, reply) {
		  if (reply.sent === true) return
		  if (err != null) {
		    reply[kReplyIsError] = true;
		    reply.send(err);
		    return
		  }

		  const method = request.raw.method;
		  const headers = request.headers;
		  const context = request[kRouteContext];

		  if (this[kSupportedHTTPMethods].bodyless.has(method)) {
		    handler(request, reply);
		    return
		  }

		  if (this[kSupportedHTTPMethods].bodywith.has(method)) {
		    const contentType = headers['content-type'];
		    const contentLength = headers['content-length'];
		    const transferEncoding = headers['transfer-encoding'];

		    if (contentType === undefined) {
		      if (
		        (contentLength === undefined || contentLength === '0') &&
		        transferEncoding === undefined
		      ) {
		        // Request has no body to parse
		        handler(request, reply);
		      } else {
		        context.contentTypeParser.run('', handler, request, reply);
		      }
		    } else {
		      if (contentLength === undefined && transferEncoding === undefined && method === 'OPTIONS') {
		        // OPTIONS can have a Content-Type header without a body
		        handler(request, reply);
		        return
		      }
		      context.contentTypeParser.run(contentType, handler, request, reply);
		    }
		    return
		  }

		  // Return 404 instead of 405 see https://github.com/fastify/fastify/pull/862 for discussion
		  handler(request, reply);
		}

		function handler (request, reply) {
		  try {
		    if (request[kRouteContext].preValidation !== null) {
		      preValidationHookRunner(
		        request[kRouteContext].preValidation,
		        request,
		        reply,
		        preValidationCallback
		      );
		    } else {
		      preValidationCallback(null, request, reply);
		    }
		  } catch (err) {
		    preValidationCallback(err, request, reply);
		  }
		}

		function preValidationCallback (err, request, reply) {
		  if (reply.sent === true) return

		  if (err != null) {
		    reply[kReplyIsError] = true;
		    reply.send(err);
		    return
		  }

		  const validationErr = validateSchema(reply[kRouteContext], request);
		  const isAsync = (validationErr && typeof validationErr.then === 'function') || false;

		  if (isAsync) {
		    const cb = validationCompleted.bind(null, request, reply);
		    validationErr.then(cb, cb);
		  } else {
		    validationCompleted(request, reply, validationErr);
		  }
		}

		function validationCompleted (request, reply, validationErr) {
		  if (validationErr) {
		    if (reply[kRouteContext].attachValidation === false) {
		      reply.send(validationErr);
		      return
		    }

		    reply.request.validationError = validationErr;
		  }

		  // preHandler hook
		  if (request[kRouteContext].preHandler !== null) {
		    preHandlerHookRunner(
		      request[kRouteContext].preHandler,
		      request,
		      reply,
		      preHandlerCallback
		    );
		  } else {
		    preHandlerCallback(null, request, reply);
		  }
		}

		function preHandlerCallback (err, request, reply) {
		  if (reply.sent) return

		  const context = request[kRouteContext];

		  if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
		    preHandlerCallbackInner(err, request, reply);
		  } else {
		    const store = {
		      request,
		      reply,
		      async: false,
		      route: {
		        url: context.config.url,
		        method: context.config.method
		      }
		    };
		    channels.start.runStores(store, preHandlerCallbackInner, undefined, err, request, reply, store);
		  }
		}

		function preHandlerCallbackInner (err, request, reply, store) {
		  const context = request[kRouteContext];

		  try {
		    if (err != null) {
		      reply[kReplyIsError] = true;
		      reply.send(err);
		      if (store) {
		        store.error = err;
		        channels.error.publish(store);
		      }
		      return
		    }

		    let result;

		    try {
		      result = context.handler(request, reply);
		    } catch (err) {
		      if (store) {
		        store.error = err;
		        channels.error.publish(store);
		      }

		      reply[kReplyIsError] = true;
		      reply.send(err);
		      return
		    }

		    if (result !== undefined) {
		      if (result !== null && typeof result.then === 'function') {
		        wrapThenable(result, reply, store);
		      } else {
		        reply.send(result);
		      }
		    }
		  } finally {
		    if (store) channels.end.publish(store);
		  }
		}

		module.exports = handleRequest;
		module.exports[Symbol.for('internals')] = { handler, preHandlerCallback }; 
	} (handleRequest));
	return handleRequest.exports;
}

var abstractLogging = {exports: {}};

abstractLogging.exports;

var hasRequiredAbstractLogging;

function requireAbstractLogging () {
	if (hasRequiredAbstractLogging) return abstractLogging.exports;
	hasRequiredAbstractLogging = 1;
	(function (module) {

		function noop () { }

		const proto = {
		  fatal: noop,
		  error: noop,
		  warn: noop,
		  info: noop,
		  debug: noop,
		  trace: noop
		};

		Object.defineProperty(module, 'exports', {
		  get () {
		    return Object.create(proto)
		  }
		}); 
	} (abstractLogging));
	return abstractLogging.exports;
}

var pino = {exports: {}};

var errHelpers;
var hasRequiredErrHelpers;

function requireErrHelpers () {
	if (hasRequiredErrHelpers) return errHelpers;
	hasRequiredErrHelpers = 1;

	// **************************************************************
	// * Code initially copied/adapted from "pony-cause" npm module *
	// * Please upstream improvements there                         *
	// **************************************************************

	const isErrorLike = (err) => {
	  return err && typeof err.message === 'string'
	};

	/**
	 * @param {Error|{ cause?: unknown|(()=>err)}} err
	 * @returns {Error|Object|undefined}
	 */
	const getErrorCause = (err) => {
	  if (!err) return

	  /** @type {unknown} */
	  // @ts-ignore
	  const cause = err.cause;

	  // VError / NError style causes
	  if (typeof cause === 'function') {
	    // @ts-ignore
	    const causeResult = err.cause();

	    return isErrorLike(causeResult)
	      ? causeResult
	      : undefined
	  } else {
	    return isErrorLike(cause)
	      ? cause
	      : undefined
	  }
	};

	/**
	 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
	 *
	 * @private
	 * @param {Error} err
	 * @param {Set<Error>} seen
	 * @returns {string}
	 */
	const _stackWithCauses = (err, seen) => {
	  if (!isErrorLike(err)) return ''

	  const stack = err.stack || '';

	  // Ensure we don't go circular or crazily deep
	  if (seen.has(err)) {
	    return stack + '\ncauses have become circular...'
	  }

	  const cause = getErrorCause(err);

	  if (cause) {
	    seen.add(err);
	    return (stack + '\ncaused by: ' + _stackWithCauses(cause, seen))
	  } else {
	    return stack
	  }
	};

	/**
	 * @param {Error} err
	 * @returns {string}
	 */
	const stackWithCauses = (err) => _stackWithCauses(err, new Set());

	/**
	 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
	 *
	 * @private
	 * @param {Error} err
	 * @param {Set<Error>} seen
	 * @param {boolean} [skip]
	 * @returns {string}
	 */
	const _messageWithCauses = (err, seen, skip) => {
	  if (!isErrorLike(err)) return ''

	  const message = skip ? '' : (err.message || '');

	  // Ensure we don't go circular or crazily deep
	  if (seen.has(err)) {
	    return message + ': ...'
	  }

	  const cause = getErrorCause(err);

	  if (cause) {
	    seen.add(err);

	    // @ts-ignore
	    const skipIfVErrorStyleCause = typeof err.cause === 'function';

	    return (message +
	      (skipIfVErrorStyleCause ? '' : ': ') +
	      _messageWithCauses(cause, seen, skipIfVErrorStyleCause))
	  } else {
	    return message
	  }
	};

	/**
	 * @param {Error} err
	 * @returns {string}
	 */
	const messageWithCauses = (err) => _messageWithCauses(err, new Set());

	errHelpers = {
	  isErrorLike,
	  getErrorCause,
	  stackWithCauses,
	  messageWithCauses
	};
	return errHelpers;
}

var errProto;
var hasRequiredErrProto;

function requireErrProto () {
	if (hasRequiredErrProto) return errProto;
	hasRequiredErrProto = 1;

	const seen = Symbol('circular-ref-tag');
	const rawSymbol = Symbol('pino-raw-err-ref');

	const pinoErrProto = Object.create({}, {
	  type: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  message: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  stack: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  aggregateErrors: {
	    enumerable: true,
	    writable: true,
	    value: undefined
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoErrProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	errProto = {
	  pinoErrProto,
	  pinoErrorSymbols: {
	    seen,
	    rawSymbol
	  }
	};
	return errProto;
}

var err;
var hasRequiredErr;

function requireErr () {
	if (hasRequiredErr) return err;
	hasRequiredErr = 1;

	err = errSerializer;

	const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
	const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
	const { seen } = pinoErrorSymbols;

	const { toString } = Object.prototype;

	function errSerializer (err) {
	  if (!isErrorLike(err)) {
	    return err
	  }

	  err[seen] = undefined; // tag to prevent re-looking at this
	  const _err = Object.create(pinoErrProto);
	  _err.type = toString.call(err.constructor) === '[object Function]'
	    ? err.constructor.name
	    : err.name;
	  _err.message = messageWithCauses(err);
	  _err.stack = stackWithCauses(err);

	  if (Array.isArray(err.errors)) {
	    _err.aggregateErrors = err.errors.map(err => errSerializer(err));
	  }

	  for (const key in err) {
	    if (_err[key] === undefined) {
	      const val = err[key];
	      if (isErrorLike(val)) {
	        // We append cause messages and stacks to _err, therefore skipping causes here
	        if (key !== 'cause' && !Object.prototype.hasOwnProperty.call(val, seen)) {
	          _err[key] = errSerializer(val);
	        }
	      } else {
	        _err[key] = val;
	      }
	    }
	  }

	  delete err[seen]; // clean up tag in case err is serialized again later
	  _err.raw = err;
	  return _err
	}
	return err;
}

var errWithCause;
var hasRequiredErrWithCause;

function requireErrWithCause () {
	if (hasRequiredErrWithCause) return errWithCause;
	hasRequiredErrWithCause = 1;

	errWithCause = errWithCauseSerializer;

	const { isErrorLike } = requireErrHelpers();
	const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
	const { seen } = pinoErrorSymbols;

	const { toString } = Object.prototype;

	function errWithCauseSerializer (err) {
	  if (!isErrorLike(err)) {
	    return err
	  }

	  err[seen] = undefined; // tag to prevent re-looking at this
	  const _err = Object.create(pinoErrProto);
	  _err.type = toString.call(err.constructor) === '[object Function]'
	    ? err.constructor.name
	    : err.name;
	  _err.message = err.message;
	  _err.stack = err.stack;

	  if (Array.isArray(err.errors)) {
	    _err.aggregateErrors = err.errors.map(err => errWithCauseSerializer(err));
	  }

	  if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
	    _err.cause = errWithCauseSerializer(err.cause);
	  }

	  for (const key in err) {
	    if (_err[key] === undefined) {
	      const val = err[key];
	      if (isErrorLike(val)) {
	        if (!Object.prototype.hasOwnProperty.call(val, seen)) {
	          _err[key] = errWithCauseSerializer(val);
	        }
	      } else {
	        _err[key] = val;
	      }
	    }
	  }

	  delete err[seen]; // clean up tag in case err is serialized again later
	  _err.raw = err;
	  return _err
	}
	return errWithCause;
}

var req;
var hasRequiredReq;

function requireReq () {
	if (hasRequiredReq) return req;
	hasRequiredReq = 1;

	req = {
	  mapHttpRequest,
	  reqSerializer
	};

	const rawSymbol = Symbol('pino-raw-req-ref');
	const pinoReqProto = Object.create({}, {
	  id: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  method: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  url: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  query: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  params: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  headers: {
	    enumerable: true,
	    writable: true,
	    value: {}
	  },
	  remoteAddress: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  remotePort: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoReqProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	function reqSerializer (req) {
	  // req.info is for hapi compat.
	  const connection = req.info || req.socket;
	  const _req = Object.create(pinoReqProto);
	  _req.id = (typeof req.id === 'function' ? req.id() : (req.id || (req.info ? req.info.id : undefined)));
	  _req.method = req.method;
	  // req.originalUrl is for expressjs compat.
	  if (req.originalUrl) {
	    _req.url = req.originalUrl;
	  } else {
	    const path = req.path;
	    // path for safe hapi compat.
	    _req.url = typeof path === 'string' ? path : (req.url ? req.url.path || req.url : undefined);
	  }

	  if (req.query) {
	    _req.query = req.query;
	  }

	  if (req.params) {
	    _req.params = req.params;
	  }

	  _req.headers = req.headers;
	  _req.remoteAddress = connection && connection.remoteAddress;
	  _req.remotePort = connection && connection.remotePort;
	  // req.raw is  for hapi compat/equivalence
	  _req.raw = req.raw || req;
	  return _req
	}

	function mapHttpRequest (req) {
	  return {
	    req: reqSerializer(req)
	  }
	}
	return req;
}

var res;
var hasRequiredRes;

function requireRes () {
	if (hasRequiredRes) return res;
	hasRequiredRes = 1;

	res = {
	  mapHttpResponse,
	  resSerializer
	};

	const rawSymbol = Symbol('pino-raw-res-ref');
	const pinoResProto = Object.create({}, {
	  statusCode: {
	    enumerable: true,
	    writable: true,
	    value: 0
	  },
	  headers: {
	    enumerable: true,
	    writable: true,
	    value: ''
	  },
	  raw: {
	    enumerable: false,
	    get: function () {
	      return this[rawSymbol]
	    },
	    set: function (val) {
	      this[rawSymbol] = val;
	    }
	  }
	});
	Object.defineProperty(pinoResProto, rawSymbol, {
	  writable: true,
	  value: {}
	});

	function resSerializer (res) {
	  const _res = Object.create(pinoResProto);
	  _res.statusCode = res.headersSent ? res.statusCode : null;
	  _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
	  _res.raw = res;
	  return _res
	}

	function mapHttpResponse (res) {
	  return {
	    res: resSerializer(res)
	  }
	}
	return res;
}

var pinoStdSerializers;
var hasRequiredPinoStdSerializers;

function requirePinoStdSerializers () {
	if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
	hasRequiredPinoStdSerializers = 1;

	const errSerializer = requireErr();
	const errWithCauseSerializer = requireErrWithCause();
	const reqSerializers = requireReq();
	const resSerializers = requireRes();

	pinoStdSerializers = {
	  err: errSerializer,
	  errWithCause: errWithCauseSerializer,
	  mapHttpRequest: reqSerializers.mapHttpRequest,
	  mapHttpResponse: resSerializers.mapHttpResponse,
	  req: reqSerializers.reqSerializer,
	  res: resSerializers.resSerializer,

	  wrapErrorSerializer: function wrapErrorSerializer (customSerializer) {
	    if (customSerializer === errSerializer) return customSerializer
	    return function wrapErrSerializer (err) {
	      return customSerializer(errSerializer(err))
	    }
	  },

	  wrapRequestSerializer: function wrapRequestSerializer (customSerializer) {
	    if (customSerializer === reqSerializers.reqSerializer) return customSerializer
	    return function wrappedReqSerializer (req) {
	      return customSerializer(reqSerializers.reqSerializer(req))
	    }
	  },

	  wrapResponseSerializer: function wrapResponseSerializer (customSerializer) {
	    if (customSerializer === resSerializers.resSerializer) return customSerializer
	    return function wrappedResSerializer (res) {
	      return customSerializer(resSerializers.resSerializer(res))
	    }
	  }
	};
	return pinoStdSerializers;
}

var caller;
var hasRequiredCaller;

function requireCaller () {
	if (hasRequiredCaller) return caller;
	hasRequiredCaller = 1;

	function noOpPrepareStackTrace (_, stack) {
	  return stack
	}

	caller = function getCallers () {
	  const originalPrepare = Error.prepareStackTrace;
	  Error.prepareStackTrace = noOpPrepareStackTrace;
	  const stack = new Error().stack;
	  Error.prepareStackTrace = originalPrepare;

	  if (!Array.isArray(stack)) {
	    return undefined
	  }

	  const entries = stack.slice(2);

	  const fileNames = [];

	  for (const entry of entries) {
	    if (!entry) {
	      continue
	    }

	    fileNames.push(entry.getFileName());
	  }

	  return fileNames
	};
	return caller;
}

var validator_1;
var hasRequiredValidator$1;

function requireValidator$1 () {
	if (hasRequiredValidator$1) return validator_1;
	hasRequiredValidator$1 = 1;

	validator_1 = validator;

	function validator (opts = {}) {
	  const {
	    ERR_PATHS_MUST_BE_STRINGS = () => 'fast-redact - Paths must be (non-empty) strings',
	    ERR_INVALID_PATH = (s) => `fast-redact  Invalid path (${s})`
	  } = opts;

	  return function validate ({ paths }) {
	    paths.forEach((s) => {
	      if (typeof s !== 'string') {
	        throw Error(ERR_PATHS_MUST_BE_STRINGS())
	      }
	      try {
	        if (//.test(s)) throw Error()
	        const expr = (s[0] === '[' ? '' : '.') + s.replace(/^\*/, '').replace(/\.\*/g, '.').replace(/\[\*\]/g, '[]');
	        if (/\n|\r|;/.test(expr)) throw Error()
	        if (/\/\*/.test(expr)) throw Error()
	        /* eslint-disable-next-line */
	        Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const  = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
	      } catch (e) {
	        throw Error(ERR_INVALID_PATH(s))
	      }
	    });
	  }
	}
	return validator_1;
}

var rx;
var hasRequiredRx;

function requireRx () {
	if (hasRequiredRx) return rx;
	hasRequiredRx = 1;

	rx = /[^.[\]]+|\[((?:.)*?)\]/g;

	/*
	Regular expression explanation:

	Alt 1: /[^.[\]]+/ - Match one or more characters that are *not* a dot (.)
	                    opening square bracket ([) or closing square bracket (])

	Alt 2: /\[((?:.)*?)\]/ - If the char IS dot or square bracket, then create a capture
	                         group (which will be capture group $1) that matches anything
	                         within square brackets. Expansion is lazy so it will
	                         stop matching as soon as the first closing bracket is met `]`
	                         (rather than continuing to match until the final closing bracket).
	*/
	return rx;
}

var parse_1$2;
var hasRequiredParse$3;

function requireParse$3 () {
	if (hasRequiredParse$3) return parse_1$2;
	hasRequiredParse$3 = 1;

	const rx = requireRx();

	parse_1$2 = parse;

	function parse ({ paths }) {
	  const wildcards = [];
	  var wcLen = 0;
	  const secret = paths.reduce(function (o, strPath, ix) {
	    var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ''));
	    const leadingBracket = strPath[0] === '[';
	    path = path.map((p) => {
	      if (p[0] === '[') return p.substr(1, p.length - 2)
	      else return p
	    });
	    const star = path.indexOf('*');
	    if (star > -1) {
	      const before = path.slice(0, star);
	      const beforeStr = before.join('.');
	      const after = path.slice(star + 1, path.length);
	      const nested = after.length > 0;
	      wcLen++;
	      wildcards.push({
	        before,
	        beforeStr,
	        after,
	        nested
	      });
	    } else {
	      o[strPath] = {
	        path: path,
	        val: undefined,
	        precensored: false,
	        circle: '',
	        escPath: JSON.stringify(strPath),
	        leadingBracket: leadingBracket
	      };
	    }
	    return o
	  }, {});

	  return { wildcards, wcLen, secret }
	}
	return parse_1$2;
}

var redactor_1;
var hasRequiredRedactor;

function requireRedactor () {
	if (hasRequiredRedactor) return redactor_1;
	hasRequiredRedactor = 1;

	const rx = requireRx();

	redactor_1 = redactor;

	function redactor ({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
	  /* eslint-disable-next-line */
	  const redact = Function('o', `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);

	  redact.state = state;

	  if (serialize === false) {
	    redact.restore = (o) => state.restore(o);
	  }

	  return redact
	}

	function redactTmpl (secret, isCensorFct, censorFctTakesPath) {
	  return Object.keys(secret).map((path) => {
	    const { escPath, leadingBracket, path: arrPath } = secret[path];
	    const skip = leadingBracket ? 1 : 0;
	    const delim = leadingBracket ? '' : '.';
	    const hops = [];
	    var match;
	    while ((match = rx.exec(path)) !== null) {
	      const [ , ix ] = match;
	      const { index, input } = match;
	      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
	    }
	    var existence = hops.map((p) => `o${delim}${p}`).join(' && ');
	    if (existence.length === 0) existence += `o${delim}${path} != null`;
	    else existence += ` && o${delim}${path} != null`;

	    const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join('\n')}
      }
    `;

	    const censorArgs = censorFctTakesPath
	      ? `val, ${JSON.stringify(arrPath)}`
	      : `val`;

	    return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : 'censor'}
          ${circularDetection}
        }
      }
    `
	  }).join('\n')
	}

	function dynamicRedactTmpl (hasWildcards, isCensorFct, censorFctTakesPath) {
	  return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : ''
	}

	function resultTmpl (serialize) {
	  return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `
	}

	function strictImpl (strict, serialize) {
	  return strict === true
	    ? `throw Error('fast-redact: primitives cannot be redacted')`
	    : serialize === false ? `return o` : `return this.serialize(o)`
	}
	return redactor_1;
}

var modifiers;
var hasRequiredModifiers;

function requireModifiers () {
	if (hasRequiredModifiers) return modifiers;
	hasRequiredModifiers = 1;

	modifiers = {
	  groupRedact,
	  groupRestore,
	  nestedRedact,
	  nestedRestore
	};

	function groupRestore ({ keys, values, target }) {
	  if (target == null || typeof target === 'string') return
	  const length = keys.length;
	  for (var i = 0; i < length; i++) {
	    const k = keys[i];
	    target[k] = values[i];
	  }
	}

	function groupRedact (o, path, censor, isCensorFct, censorFctTakesPath) {
	  const target = get(o, path);
	  if (target == null || typeof target === 'string') return { keys: null, values: null, target, flat: true }
	  const keys = Object.keys(target);
	  const keysLength = keys.length;
	  const pathLength = path.length;
	  const pathWithKey = censorFctTakesPath ? [...path] : undefined;
	  const values = new Array(keysLength);

	  for (var i = 0; i < keysLength; i++) {
	    const key = keys[i];
	    values[i] = target[key];

	    if (censorFctTakesPath) {
	      pathWithKey[pathLength] = key;
	      target[key] = censor(target[key], pathWithKey);
	    } else if (isCensorFct) {
	      target[key] = censor(target[key]);
	    } else {
	      target[key] = censor;
	    }
	  }
	  return { keys, values, target, flat: true }
	}

	/**
	 * @param {RestoreInstruction[]} instructions a set of instructions for restoring values to objects
	 */
	function nestedRestore (instructions) {
	  for (let i = 0; i < instructions.length; i++) {
	    const { target, path, value } = instructions[i];
	    let current = target;
	    for (let i = path.length - 1; i > 0; i--) {
	      current = current[path[i]];
	    }
	    current[path[0]] = value;
	  }
	}

	function nestedRedact (store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
	  const target = get(o, path);
	  if (target == null) return
	  const keys = Object.keys(target);
	  const keysLength = keys.length;
	  for (var i = 0; i < keysLength; i++) {
	    const key = keys[i];
	    specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
	  }
	  return store
	}

	function has (obj, prop) {
	  return obj !== undefined && obj !== null
	    ? ('hasOwn' in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop))
	    : false
	}

	function specialSet (store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
	  const afterPathLen = afterPath.length;
	  const lastPathIndex = afterPathLen - 1;
	  const originalKey = k;
	  var i = -1;
	  var n;
	  var nv;
	  var ov;
	  var wc = null;
	  var kIsWc;
	  var wcov;
	  var consecutive = false;
	  var level = 0;
	  // need to track depth of the `redactPath` tree
	  var depth = 0;
	  var redactPathCurrent = tree();
	  ov = n = o[k];
	  if (typeof n !== 'object') return
	  while (n != null && ++i < afterPathLen) {
	    depth += 1;
	    k = afterPath[i];
	    if (k !== '*' && !wc && !(typeof n === 'object' && k in n)) {
	      break
	    }
	    if (k === '*') {
	      if (wc === '*') {
	        consecutive = true;
	      }
	      wc = k;
	      if (i !== lastPathIndex) {
	        continue
	      }
	    }
	    if (wc) {
	      const wcKeys = Object.keys(n);
	      for (var j = 0; j < wcKeys.length; j++) {
	        const wck = wcKeys[j];
	        wcov = n[wck];
	        kIsWc = k === '*';
	        if (consecutive) {
	          redactPathCurrent = node(redactPathCurrent, wck, depth);
	          level = i;
	          ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
	        } else {
	          if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
	            if (kIsWc) {
	              ov = wcov;
	            } else {
	              ov = wcov[k];
	            }
	            nv = (i !== lastPathIndex)
	              ? ov
	              : (isCensorFct
	                ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	                : censor);
	            if (kIsWc) {
	              const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
	              store.push(rv);
	              n[wck] = nv;
	            } else {
	              if (wcov[k] === nv) ; else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) {
	                redactPathCurrent = node(redactPathCurrent, wck, depth);
	              } else {
	                redactPathCurrent = node(redactPathCurrent, wck, depth);
	                const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
	                store.push(rv);
	                wcov[k] = nv;
	              }
	            }
	          }
	        }
	      }
	      wc = null;
	    } else {
	      ov = n[k];
	      redactPathCurrent = node(redactPathCurrent, k, depth);
	      nv = (i !== lastPathIndex)
	        ? ov
	        : (isCensorFct
	          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	          : censor);
	      if ((has(n, k) && nv === ov) || (nv === undefined && censor !== undefined)) ; else {
	        const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
	        store.push(rv);
	        n[k] = nv;
	      }
	      n = n[k];
	    }
	    if (typeof n !== 'object') break
	  }
	}

	function get (o, p) {
	  var i = -1;
	  var l = p.length;
	  var n = o;
	  while (n != null && ++i < l) {
	    n = n[p[i]];
	  }
	  return n
	}

	function iterateNthLevel (wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
	  if (level === 0) {
	    if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
	      if (kIsWc) {
	        ov = wcov;
	      } else {
	        ov = wcov[k];
	      }
	      nv = (i !== lastPathIndex)
	        ? ov
	        : (isCensorFct
	          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
	          : censor);
	      if (kIsWc) {
	        const rv = restoreInstr(redactPathCurrent, ov, parent);
	        store.push(rv);
	        n[wck] = nv;
	      } else {
	        if (wcov[k] === nv) ; else if ((nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov)) ; else {
	          const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
	          store.push(rv);
	          wcov[k] = nv;
	        }
	      }
	    }
	  }
	  for (const key in wcov) {
	    if (typeof wcov[key] === 'object') {
	      redactPathCurrent = node(redactPathCurrent, key, depth);
	      iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
	    }
	  }
	}

	/**
	 * @typedef {object} TreeNode
	 * @prop {TreeNode} [parent] reference to the parent of this node in the tree, or `null` if there is no parent
	 * @prop {string} key the key that this node represents (key here being part of the path being redacted
	 * @prop {TreeNode[]} children the child nodes of this node
	 * @prop {number} depth the depth of this node in the tree
	 */

	/**
	 * instantiate a new, empty tree
	 * @returns {TreeNode}
	 */
	function tree () {
	  return { parent: null, key: null, children: [], depth: 0 }
	}

	/**
	 * creates a new node in the tree, attaching it as a child of the provided parent node
	 * if the specified depth matches the parent depth, adds the new node as a _sibling_ of the parent instead
	  * @param {TreeNode} parent the parent node to add a new node to (if the parent depth matches the provided `depth` value, will instead add as a sibling of this
	  * @param {string} key the key that the new node represents (key here being part of the path being redacted)
	  * @param {number} depth the depth of the new node in the tree - used to determing whether to add the new node as a child or sibling of the provided `parent` node
	  * @returns {TreeNode} a reference to the newly created node in the tree
	 */
	function node (parent, key, depth) {
	  if (parent.depth === depth) {
	    return node(parent.parent, key, depth)
	  }

	  var child = {
	    parent,
	    key,
	    depth,
	    children: []
	  };

	  parent.children.push(child);

	  return child
	}

	/**
	 * @typedef {object} RestoreInstruction
	 * @prop {string[]} path a reverse-order path that can be used to find the correct insertion point to restore a `value` for the given `parent` object
	 * @prop {*} value the value to restore
	 * @prop {object} target the object to restore the `value` in
	 */

	/**
	 * create a restore instruction for the given redactPath node
	 * generates a path in reverse order by walking up the redactPath tree
	 * @param {TreeNode} node a tree node that should be at the bottom of the redact path (i.e. have no children) - this will be used to walk up the redact path tree to construct the path needed to restore
	 * @param {*} value the value to restore
	 * @param {object} target a reference to the parent object to apply the restore instruction to
	 * @returns {RestoreInstruction} an instruction used to restore a nested value for a specific object
	 */
	function restoreInstr (node, value, target) {
	  let current = node;
	  const path = [];
	  do {
	    path.push(current.key);
	    current = current.parent;
	  } while (current.parent != null)

	  return { path, value, target }
	}
	return modifiers;
}

var restorer_1;
var hasRequiredRestorer;

function requireRestorer () {
	if (hasRequiredRestorer) return restorer_1;
	hasRequiredRestorer = 1;

	const { groupRestore, nestedRestore } = requireModifiers();

	restorer_1 = restorer;

	function restorer () {
	  return function compileRestore () {
	    if (this.restore) {
	      this.restore.state.secret = this.secret;
	      return
	    }
	    const { secret, wcLen } = this;
	    const paths = Object.keys(secret);
	    const resetters = resetTmpl(secret, paths);
	    const hasWildcards = wcLen > 0;
	    const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
	    /* eslint-disable-next-line */
	    this.restore = Function(
	      'o',
	      restoreTmpl(resetters, paths, hasWildcards)
	    ).bind(state);
	    this.restore.state = state;
	  }
	}

	/**
	 * Mutates the original object to be censored by restoring its original values
	 * prior to censoring.
	 *
	 * @param {object} secret Compiled object describing which target fields should
	 * be censored and the field states.
	 * @param {string[]} paths The list of paths to censor as provided at
	 * initialization time.
	 *
	 * @returns {string} String of JavaScript to be used by `Function()`. The
	 * string compiles to the function that does the work in the description.
	 */
	function resetTmpl (secret, paths) {
	  return paths.map((path) => {
	    const { circle, escPath, leadingBracket } = secret[path];
	    const delim = leadingBracket ? '' : '.';
	    const reset = circle
	      ? `o.${circle} = secret[${escPath}].val`
	      : `o${delim}${path} = secret[${escPath}].val`;
	    const clear = `secret[${escPath}].val = undefined`;
	    return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `
	  }).join('')
	}

	/**
	 * Creates the body of the restore function
	 *
	 * Restoration of the redacted object happens
	 * backwards, in reverse order of redactions,
	 * so that repeated redactions on the same object
	 * property can be eventually rolled back to the
	 * original value.
	 *
	 * This way dynamic redactions are restored first,
	 * starting from the last one working backwards and
	 * followed by the static ones.
	 *
	 * @returns {string} the body of the restore function
	 */
	function restoreTmpl (resetters, paths, hasWildcards) {
	  const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : '';

	  return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `
	}
	return restorer_1;
}

var state_1;
var hasRequiredState$1;

function requireState$1 () {
	if (hasRequiredState$1) return state_1;
	hasRequiredState$1 = 1;

	state_1 = state;

	function state (o) {
	  const {
	    secret,
	    censor,
	    compileRestore,
	    serialize,
	    groupRedact,
	    nestedRedact,
	    wildcards,
	    wcLen
	  } = o;
	  const builder = [{ secret, censor, compileRestore }];
	  if (serialize !== false) builder.push({ serialize });
	  if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
	  return Object.assign(...builder)
	}
	return state_1;
}

var fastRedact_1;
var hasRequiredFastRedact;

function requireFastRedact () {
	if (hasRequiredFastRedact) return fastRedact_1;
	hasRequiredFastRedact = 1;

	const validator = requireValidator$1();
	const parse = requireParse$3();
	const redactor = requireRedactor();
	const restorer = requireRestorer();
	const { groupRedact, nestedRedact } = requireModifiers();
	const state = requireState$1();
	const rx = requireRx();
	const validate = validator();
	const noop = (o) => o;
	noop.restore = noop;

	const DEFAULT_CENSOR = '[REDACTED]';
	fastRedact.rx = rx;
	fastRedact.validator = validator;

	fastRedact_1 = fastRedact;

	function fastRedact (opts = {}) {
	  const paths = Array.from(new Set(opts.paths || []));
	  const serialize = 'serialize' in opts ? (
	    opts.serialize === false ? opts.serialize
	      : (typeof opts.serialize === 'function' ? opts.serialize : JSON.stringify)
	  ) : JSON.stringify;
	  const remove = opts.remove;
	  if (remove === true && serialize !== JSON.stringify) {
	    throw Error('fast-redact  remove option may only be set when serializer is JSON.stringify')
	  }
	  const censor = remove === true
	    ? undefined
	    : 'censor' in opts ? opts.censor : DEFAULT_CENSOR;

	  const isCensorFct = typeof censor === 'function';
	  const censorFctTakesPath = isCensorFct && censor.length > 1;

	  if (paths.length === 0) return serialize || noop

	  validate({ paths, serialize, censor });

	  const { wildcards, wcLen, secret } = parse({ paths, censor });

	  const compileRestore = restorer();
	  const strict = 'strict' in opts ? opts.strict : true;

	  return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
	    secret,
	    censor,
	    compileRestore,
	    serialize,
	    groupRedact,
	    nestedRedact,
	    wildcards,
	    wcLen
	  }))
	}
	return fastRedact_1;
}

var symbols$1;
var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;

	const setLevelSym = Symbol('pino.setLevel');
	const getLevelSym = Symbol('pino.getLevel');
	const levelValSym = Symbol('pino.levelVal');
	const levelCompSym = Symbol('pino.levelComp');
	const useLevelLabelsSym = Symbol('pino.useLevelLabels');
	const useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels');
	const mixinSym = Symbol('pino.mixin');

	const lsCacheSym = Symbol('pino.lsCache');
	const chindingsSym = Symbol('pino.chindings');

	const asJsonSym = Symbol('pino.asJson');
	const writeSym = Symbol('pino.write');
	const redactFmtSym = Symbol('pino.redactFmt');

	const timeSym = Symbol('pino.time');
	const timeSliceIndexSym = Symbol('pino.timeSliceIndex');
	const streamSym = Symbol('pino.stream');
	const stringifySym = Symbol('pino.stringify');
	const stringifySafeSym = Symbol('pino.stringifySafe');
	const stringifiersSym = Symbol('pino.stringifiers');
	const endSym = Symbol('pino.end');
	const formatOptsSym = Symbol('pino.formatOpts');
	const messageKeySym = Symbol('pino.messageKey');
	const errorKeySym = Symbol('pino.errorKey');
	const nestedKeySym = Symbol('pino.nestedKey');
	const nestedKeyStrSym = Symbol('pino.nestedKeyStr');
	const mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy');
	const msgPrefixSym = Symbol('pino.msgPrefix');

	const wildcardFirstSym = Symbol('pino.wildcardFirst');

	// public symbols, no need to use the same pino
	// version for these
	const serializersSym = Symbol.for('pino.serializers');
	const formattersSym = Symbol.for('pino.formatters');
	const hooksSym = Symbol.for('pino.hooks');
	const needsMetadataGsym = Symbol.for('pino.metadata');

	symbols$1 = {
	  setLevelSym,
	  getLevelSym,
	  levelValSym,
	  levelCompSym,
	  useLevelLabelsSym,
	  mixinSym,
	  lsCacheSym,
	  chindingsSym,
	  asJsonSym,
	  writeSym,
	  serializersSym,
	  redactFmtSym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  stringifySym,
	  stringifySafeSym,
	  stringifiersSym,
	  endSym,
	  formatOptsSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeySym,
	  wildcardFirstSym,
	  needsMetadataGsym,
	  useOnlyCustomLevelsSym,
	  formattersSym,
	  hooksSym,
	  nestedKeyStrSym,
	  mixinMergeStrategySym,
	  msgPrefixSym
	};
	return symbols$1;
}

var redaction_1;
var hasRequiredRedaction;

function requireRedaction () {
	if (hasRequiredRedaction) return redaction_1;
	hasRequiredRedaction = 1;

	const fastRedact = requireFastRedact();
	const { redactFmtSym, wildcardFirstSym } = requireSymbols$1();
	const { rx, validator } = fastRedact;

	const validate = validator({
	  ERR_PATHS_MUST_BE_STRINGS: () => 'pino  redacted paths must be strings',
	  ERR_INVALID_PATH: (s) => `pino  redact paths array contains an invalid path (${s})`
	});

	const CENSOR = '[Redacted]';
	const strict = false; // TODO should this be configurable?

	function redaction (opts, serialize) {
	  const { paths, censor } = handle(opts);

	  const shape = paths.reduce((o, str) => {
	    rx.lastIndex = 0;
	    const first = rx.exec(str);
	    const next = rx.exec(str);

	    // ns is the top-level path segment, brackets + quoting removed.
	    let ns = first[1] !== undefined
	      ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1')
	      : first[0];

	    if (ns === '*') {
	      ns = wildcardFirstSym;
	    }

	    // top level key:
	    if (next === null) {
	      o[ns] = null;
	      return o
	    }

	    // path with at least two segments:
	    // if ns is already redacted at the top level, ignore lower level redactions
	    if (o[ns] === null) {
	      return o
	    }

	    const { index } = next;
	    const nextPath = `${str.substr(index, str.length - 1)}`;

	    o[ns] = o[ns] || [];

	    // shape is a mix of paths beginning with literal values and wildcard
	    // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
	    // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
	    // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
	    // (* entry has wildcardFirstSym as key)
	    if (ns !== wildcardFirstSym && o[ns].length === 0) {
	      // first time ns's get all '*' redactions so far
	      o[ns].push(...(o[wildcardFirstSym] || []));
	    }

	    if (ns === wildcardFirstSym) {
	      // new * path gets added to all previously registered literal ns's.
	      Object.keys(o).forEach(function (k) {
	        if (o[k]) {
	          o[k].push(nextPath);
	        }
	      });
	    }

	    o[ns].push(nextPath);
	    return o
	  }, {});

	  // the redactor assigned to the format symbol key
	  // provides top level redaction for instances where
	  // an object is interpolated into the msg string
	  const result = {
	    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
	  };

	  const topCensor = (...args) => {
	    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)
	  };

	  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
	    // top level key:
	    if (shape[k] === null) {
	      o[k] = (value) => topCensor(value, [k]);
	    } else {
	      const wrappedCensor = typeof censor === 'function'
	        ? (value, path) => {
	            return censor(value, [k, ...path])
	          }
	        : censor;
	      o[k] = fastRedact({
	        paths: shape[k],
	        censor: wrappedCensor,
	        serialize,
	        strict
	      });
	    }
	    return o
	  }, result)
	}

	function handle (opts) {
	  if (Array.isArray(opts)) {
	    opts = { paths: opts, censor: CENSOR };
	    validate(opts);
	    return opts
	  }
	  let { paths, censor = CENSOR, remove } = opts;
	  if (Array.isArray(paths) === false) { throw Error('pino  redact must contain an array of strings') }
	  if (remove === true) censor = undefined;
	  validate({ paths, censor });

	  return { paths, censor }
	}

	redaction_1 = redaction;
	return redaction_1;
}

var time;
var hasRequiredTime;

function requireTime () {
	if (hasRequiredTime) return time;
	hasRequiredTime = 1;

	const nullTime = () => '';

	const epochTime = () => `,"time":${Date.now()}`;

	const unixTime = () => `,"time":${Math.round(Date.now() / 1000.0)}`;

	const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`; // using Date.now() for testability

	time = { nullTime, epochTime, unixTime, isoTime };
	return time;
}

var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;

function requireQuickFormatUnescaped () {
	if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
	hasRequiredQuickFormatUnescaped = 1;
	function tryStringify (o) {
	  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
	}

	quickFormatUnescaped = format;

	function format(f, args, opts) {
	  var ss = (opts && opts.stringify) || tryStringify;
	  var offset = 1;
	  if (typeof f === 'object' && f !== null) {
	    var len = args.length + offset;
	    if (len === 1) return f
	    var objects = new Array(len);
	    objects[0] = ss(f);
	    for (var index = 1; index < len; index++) {
	      objects[index] = ss(args[index]);
	    }
	    return objects.join(' ')
	  }
	  if (typeof f !== 'string') {
	    return f
	  }
	  var argLen = args.length;
	  if (argLen === 0) return f
	  var str = '';
	  var a = 1 - offset;
	  var lastPos = -1;
	  var flen = (f && f.length) || 0;
	  for (var i = 0; i < flen;) {
	    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
	      lastPos = lastPos > -1 ? lastPos : 0;
	      switch (f.charCodeAt(i + 1)) {
	        case 100: // 'd'
	        case 102: // 'f'
	          if (a >= argLen)
	            break
	          if (args[a] == null)  break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += Number(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 105: // 'i'
	          if (a >= argLen)
	            break
	          if (args[a] == null)  break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += Math.floor(Number(args[a]));
	          lastPos = i + 2;
	          i++;
	          break
	        case 79: // 'O'
	        case 111: // 'o'
	        case 106: // 'j'
	          if (a >= argLen)
	            break
	          if (args[a] === undefined) break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          var type = typeof args[a];
	          if (type === 'string') {
	            str += '\'' + args[a] + '\'';
	            lastPos = i + 2;
	            i++;
	            break
	          }
	          if (type === 'function') {
	            str += args[a].name || '<anonymous>';
	            lastPos = i + 2;
	            i++;
	            break
	          }
	          str += ss(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 115: // 's'
	          if (a >= argLen)
	            break
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += String(args[a]);
	          lastPos = i + 2;
	          i++;
	          break
	        case 37: // '%'
	          if (lastPos < i)
	            str += f.slice(lastPos, i);
	          str += '%';
	          lastPos = i + 2;
	          i++;
	          a--;
	          break
	      }
	      ++a;
	    }
	    ++i;
	  }
	  if (lastPos === -1)
	    return f
	  else if (lastPos < flen) {
	    str += f.slice(lastPos);
	  }

	  return str
	}
	return quickFormatUnescaped;
}

var atomicSleep = {exports: {}};

var hasRequiredAtomicSleep;

function requireAtomicSleep () {
	if (hasRequiredAtomicSleep) return atomicSleep.exports;
	hasRequiredAtomicSleep = 1;

	/* global SharedArrayBuffer, Atomics */

	if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
	  const nil = new Int32Array(new SharedArrayBuffer(4));

	  function sleep (ms) {
	    // also filters out NaN, non-number types, including empty strings, but allows bigints
	    const valid = ms > 0 && ms < Infinity; 
	    if (valid === false) {
	      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
	        throw TypeError('sleep: ms must be a number')
	      }
	      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
	    }

	    Atomics.wait(nil, 0, 0, Number(ms));
	  }
	  atomicSleep.exports = sleep;
	} else {

	  function sleep (ms) {
	    // also filters out NaN, non-number types, including empty strings, but allows bigints
	    const valid = ms > 0 && ms < Infinity; 
	    if (valid === false) {
	      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
	        throw TypeError('sleep: ms must be a number')
	      }
	      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
	    }
	  }

	  atomicSleep.exports = sleep;

	}
	return atomicSleep.exports;
}

var sonicBoom;
var hasRequiredSonicBoom;

function requireSonicBoom () {
	if (hasRequiredSonicBoom) return sonicBoom;
	hasRequiredSonicBoom = 1;

	const fs = require$$0$2;
	const EventEmitter = require$$0$7;
	const inherits = require$$1$3.inherits;
	const path$1 = path;
	const sleep = requireAtomicSleep();
	const assert = require$$5;

	const BUSY_WRITE_TIMEOUT = 100;
	const kEmptyBuffer = Buffer.allocUnsafe(0);

	// 16 KB. Don't write more than docker buffer size.
	// https://github.com/moby/moby/blob/513ec73831269947d38a644c278ce3cac36783b2/daemon/logger/copier.go#L13
	const MAX_WRITE = 16 * 1024;

	const kContentModeBuffer = 'buffer';
	const kContentModeUtf8 = 'utf8';

	const [major, minor] = (process.versions.node || '0.0').split('.').map(Number);
	const kCopyBuffer = major >= 22 && minor >= 7;

	function openFile (file, sonic) {
	  sonic._opening = true;
	  sonic._writing = true;
	  sonic._asyncDrainScheduled = false;

	  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
	  // for sync mode, there is no way to add a listener that will receive these

	  function fileOpened (err, fd) {
	    if (err) {
	      sonic._reopening = false;
	      sonic._writing = false;
	      sonic._opening = false;

	      if (sonic.sync) {
	        process.nextTick(() => {
	          if (sonic.listenerCount('error') > 0) {
	            sonic.emit('error', err);
	          }
	        });
	      } else {
	        sonic.emit('error', err);
	      }
	      return
	    }

	    const reopening = sonic._reopening;

	    sonic.fd = fd;
	    sonic.file = file;
	    sonic._reopening = false;
	    sonic._opening = false;
	    sonic._writing = false;

	    if (sonic.sync) {
	      process.nextTick(() => sonic.emit('ready'));
	    } else {
	      sonic.emit('ready');
	    }

	    if (sonic.destroyed) {
	      return
	    }

	    // start
	    if ((!sonic._writing && sonic._len > sonic.minLength) || sonic._flushPending) {
	      sonic._actualWrite();
	    } else if (reopening) {
	      process.nextTick(() => sonic.emit('drain'));
	    }
	  }

	  const flags = sonic.append ? 'a' : 'w';
	  const mode = sonic.mode;

	  if (sonic.sync) {
	    try {
	      if (sonic.mkdir) fs.mkdirSync(path$1.dirname(file), { recursive: true });
	      const fd = fs.openSync(file, flags, mode);
	      fileOpened(null, fd);
	    } catch (err) {
	      fileOpened(err);
	      throw err
	    }
	  } else if (sonic.mkdir) {
	    fs.mkdir(path$1.dirname(file), { recursive: true }, (err) => {
	      if (err) return fileOpened(err)
	      fs.open(file, flags, mode, fileOpened);
	    });
	  } else {
	    fs.open(file, flags, mode, fileOpened);
	  }
	}

	function SonicBoom (opts) {
	  if (!(this instanceof SonicBoom)) {
	    return new SonicBoom(opts)
	  }

	  let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};

	  fd = fd || dest;

	  this._len = 0;
	  this.fd = -1;
	  this._bufs = [];
	  this._lens = [];
	  this._writing = false;
	  this._ending = false;
	  this._reopening = false;
	  this._asyncDrainScheduled = false;
	  this._flushPending = false;
	  this._hwm = Math.max(minLength || 0, 16387);
	  this.file = null;
	  this.destroyed = false;
	  this.minLength = minLength || 0;
	  this.maxLength = maxLength || 0;
	  this.maxWrite = maxWrite || MAX_WRITE;
	  this._periodicFlush = periodicFlush || 0;
	  this._periodicFlushTimer = undefined;
	  this.sync = sync || false;
	  this.writable = true;
	  this._fsync = fsync || false;
	  this.append = append || false;
	  this.mode = mode;
	  this.retryEAGAIN = retryEAGAIN || (() => true);
	  this.mkdir = mkdir || false;

	  let fsWriteSync;
	  let fsWrite;
	  if (contentMode === kContentModeBuffer) {
	    this._writingBuf = kEmptyBuffer;
	    this.write = writeBuffer;
	    this.flush = flushBuffer;
	    this.flushSync = flushBufferSync;
	    this._actualWrite = actualWriteBuffer;
	    fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
	    fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
	  } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
	    this._writingBuf = '';
	    this.write = write;
	    this.flush = flush;
	    this.flushSync = flushSync;
	    this._actualWrite = actualWrite;
	    fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, 'utf8');
	    fsWrite = () => fs.write(this.fd, this._writingBuf, 'utf8', this.release);
	  } else {
	    throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`)
	  }

	  if (typeof fd === 'number') {
	    this.fd = fd;
	    process.nextTick(() => this.emit('ready'));
	  } else if (typeof fd === 'string') {
	    openFile(fd, this);
	  } else {
	    throw new Error('SonicBoom supports only file descriptors and files')
	  }
	  if (this.minLength >= this.maxWrite) {
	    throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`)
	  }

	  this.release = (err, n) => {
	    if (err) {
	      if ((err.code === 'EAGAIN' || err.code === 'EBUSY') && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
	        if (this.sync) {
	          // This error code should not happen in sync mode, because it is
	          // not using the underlining operating system asynchronous functions.
	          // However it happens, and so we handle it.
	          // Ref: https://github.com/pinojs/pino/issues/783
	          try {
	            sleep(BUSY_WRITE_TIMEOUT);
	            this.release(undefined, 0);
	          } catch (err) {
	            this.release(err);
	          }
	        } else {
	          // Let's give the destination some time to process the chunk.
	          setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
	        }
	      } else {
	        this._writing = false;

	        this.emit('error', err);
	      }
	      return
	    }

	    this.emit('write', n);
	    const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	    this._len = releasedBufObj.len;
	    this._writingBuf = releasedBufObj.writingBuf;

	    if (this._writingBuf.length) {
	      if (!this.sync) {
	        fsWrite();
	        return
	      }

	      try {
	        do {
	          const n = fsWriteSync();
	          const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	          this._len = releasedBufObj.len;
	          this._writingBuf = releasedBufObj.writingBuf;
	        } while (this._writingBuf.length)
	      } catch (err) {
	        this.release(err);
	        return
	      }
	    }

	    if (this._fsync) {
	      fs.fsyncSync(this.fd);
	    }

	    const len = this._len;
	    if (this._reopening) {
	      this._writing = false;
	      this._reopening = false;
	      this.reopen();
	    } else if (len > this.minLength) {
	      this._actualWrite();
	    } else if (this._ending) {
	      if (len > 0) {
	        this._actualWrite();
	      } else {
	        this._writing = false;
	        actualClose(this);
	      }
	    } else {
	      this._writing = false;
	      if (this.sync) {
	        if (!this._asyncDrainScheduled) {
	          this._asyncDrainScheduled = true;
	          process.nextTick(emitDrain, this);
	        }
	      } else {
	        this.emit('drain');
	      }
	    }
	  };

	  this.on('newListener', function (name) {
	    if (name === 'drain') {
	      this._asyncDrainScheduled = false;
	    }
	  });

	  if (this._periodicFlush !== 0) {
	    this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
	    this._periodicFlushTimer.unref();
	  }
	}

	/**
	 * Release the writingBuf after fs.write n bytes data
	 * @param {string | Buffer} writingBuf - currently writing buffer, usually be instance._writingBuf.
	 * @param {number} len - currently buffer length, usually be instance._len.
	 * @param {number} n - number of bytes fs already written
	 * @returns {{writingBuf: string | Buffer, len: number}} released writingBuf and length
	 */
	function releaseWritingBuf (writingBuf, len, n) {
	  // if Buffer.byteLength is equal to n, that means writingBuf contains no multi-byte character
	  if (typeof writingBuf === 'string' && Buffer.byteLength(writingBuf) !== n) {
	    // Since the fs.write callback parameter `n` means how many bytes the passed of string
	    // We calculate the original string length for avoiding the multi-byte character issue
	    n = Buffer.from(writingBuf).subarray(0, n).toString().length;
	  }
	  len = Math.max(len - n, 0);
	  writingBuf = writingBuf.slice(n);
	  return { writingBuf, len }
	}

	function emitDrain (sonic) {
	  const hasListeners = sonic.listenerCount('drain') > 0;
	  if (!hasListeners) return
	  sonic._asyncDrainScheduled = false;
	  sonic.emit('drain');
	}

	inherits(SonicBoom, EventEmitter);

	function mergeBuf (bufs, len) {
	  if (bufs.length === 0) {
	    return kEmptyBuffer
	  }

	  if (bufs.length === 1) {
	    return bufs[0]
	  }

	  return Buffer.concat(bufs, len)
	}

	function write (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    bufs[bufs.length - 1].length + data.length > this.maxWrite
	  ) {
	    bufs.push('' + data);
	  } else {
	    bufs[bufs.length - 1] += data;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function writeBuffer (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;
	  const lens = this._lens;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    lens[lens.length - 1] + data.length > this.maxWrite
	  ) {
	    bufs.push([data]);
	    lens.push(data.length);
	  } else {
	    bufs[bufs.length - 1].push(data);
	    lens[lens.length - 1] += data.length;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function callFlushCallbackOnDrain (cb) {
	  this._flushPending = true;
	  const onDrain = () => {
	    // only if _fsync is false to avoid double fsync
	    if (!this._fsync) {
	      try {
	        fs.fsync(this.fd, (err) => {
	          this._flushPending = false;
	          cb(err);
	        });
	      } catch (err) {
	        cb(err);
	      }
	    } else {
	      this._flushPending = false;
	      cb();
	    }
	    this.off('error', onError);
	  };
	  const onError = (err) => {
	    this._flushPending = false;
	    cb(err);
	    this.off('drain', onDrain);
	  };

	  this.once('drain', onDrain);
	  this.once('error', onError);
	}

	function flush (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push('');
	  }

	  this._actualWrite();
	}

	function flushBuffer (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push([]);
	    this._lens.push(0);
	  }

	  this._actualWrite();
	}

	SonicBoom.prototype.reopen = function (file) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.reopen(file);
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  if (!this.file) {
	    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')
	  }

	  if (file) {
	    this.file = file;
	  }
	  this._reopening = true;

	  if (this._writing) {
	    return
	  }

	  const fd = this.fd;
	  this.once('ready', () => {
	    if (fd !== this.fd) {
	      fs.close(fd, (err) => {
	        if (err) {
	          return this.emit('error', err)
	        }
	      });
	    }
	  });

	  openFile(this.file, this);
	};

	SonicBoom.prototype.end = function () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.end();
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  this._ending = true;

	  if (this._writing) {
	    return
	  }

	  if (this._len > 0 && this.fd >= 0) {
	    this._actualWrite();
	  } else {
	    actualClose(this);
	  }
	};

	function flushSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift(this._writingBuf);
	    this._writingBuf = '';
	  }

	  let buf = '';
	  while (this._bufs.length || buf) {
	    if (buf.length <= 0) {
	      buf = this._bufs[0];
	    }
	    try {
	      const n = fs.writeSync(this.fd, buf, 'utf8');
	      const releasedBufObj = releaseWritingBuf(buf, this._len, n);
	      buf = releasedBufObj.writingBuf;
	      this._len = releasedBufObj.len;
	      if (buf.length <= 0) {
	        this._bufs.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }

	  try {
	    fs.fsyncSync(this.fd);
	  } catch {
	    // Skip the error. The fd might not support fsync.
	  }
	}

	function flushBufferSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift([this._writingBuf]);
	    this._writingBuf = kEmptyBuffer;
	  }

	  let buf = kEmptyBuffer;
	  while (this._bufs.length || buf.length) {
	    if (buf.length <= 0) {
	      buf = mergeBuf(this._bufs[0], this._lens[0]);
	    }
	    try {
	      const n = fs.writeSync(this.fd, buf);
	      buf = buf.subarray(n);
	      this._len = Math.max(this._len - n, 0);
	      if (buf.length <= 0) {
	        this._bufs.shift();
	        this._lens.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }
	}

	SonicBoom.prototype.destroy = function () {
	  if (this.destroyed) {
	    return
	  }
	  actualClose(this);
	};

	function actualWrite () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf || this._bufs.shift() || '';

	  if (this.sync) {
	    try {
	      const written = fs.writeSync(this.fd, this._writingBuf, 'utf8');
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    fs.write(this.fd, this._writingBuf, 'utf8', release);
	  }
	}

	function actualWriteBuffer () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());

	  if (this.sync) {
	    try {
	      const written = fs.writeSync(this.fd, this._writingBuf);
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    // fs.write will need to copy string to buffer anyway so
	    // we do it here to avoid the overhead of calculating the buffer size
	    // in releaseWritingBuf.
	    if (kCopyBuffer) {
	      this._writingBuf = Buffer.from(this._writingBuf);
	    }
	    fs.write(this.fd, this._writingBuf, release);
	  }
	}

	function actualClose (sonic) {
	  if (sonic.fd === -1) {
	    sonic.once('ready', actualClose.bind(null, sonic));
	    return
	  }

	  if (sonic._periodicFlushTimer !== undefined) {
	    clearInterval(sonic._periodicFlushTimer);
	  }

	  sonic.destroyed = true;
	  sonic._bufs = [];
	  sonic._lens = [];

	  assert(typeof sonic.fd === 'number', `sonic.fd must be a number, got ${typeof sonic.fd}`);
	  try {
	    fs.fsync(sonic.fd, closeWrapped);
	  } catch {
	  }

	  function closeWrapped () {
	    // We skip errors in fsync

	    if (sonic.fd !== 1 && sonic.fd !== 2) {
	      fs.close(sonic.fd, done);
	    } else {
	      done();
	    }
	  }

	  function done (err) {
	    if (err) {
	      sonic.emit('error', err);
	      return
	    }

	    if (sonic._ending && !sonic._writing) {
	      sonic.emit('finish');
	    }
	    sonic.emit('close');
	  }
	}

	/**
	 * These export configurations enable JS and TS developers
	 * to consumer SonicBoom in whatever way best suits their needs.
	 * Some examples of supported import syntax includes:
	 * - `const SonicBoom = require('SonicBoom')`
	 * - `const { SonicBoom } = require('SonicBoom')`
	 * - `import * as SonicBoom from 'SonicBoom'`
	 * - `import { SonicBoom } from 'SonicBoom'`
	 * - `import SonicBoom from 'SonicBoom'`
	 */
	SonicBoom.SonicBoom = SonicBoom;
	SonicBoom.default = SonicBoom;
	sonicBoom = SonicBoom;
	return sonicBoom;
}

var onExitLeakFree;
var hasRequiredOnExitLeakFree;

function requireOnExitLeakFree () {
	if (hasRequiredOnExitLeakFree) return onExitLeakFree;
	hasRequiredOnExitLeakFree = 1;

	const refs = {
	  exit: [],
	  beforeExit: []
	};
	const functions = {
	  exit: onExit,
	  beforeExit: onBeforeExit
	};

	let registry;

	function ensureRegistry () {
	  if (registry === undefined) {
	    registry = new FinalizationRegistry(clear);
	  }
	}

	function install (event) {
	  if (refs[event].length > 0) {
	    return
	  }

	  process.on(event, functions[event]);
	}

	function uninstall (event) {
	  if (refs[event].length > 0) {
	    return
	  }
	  process.removeListener(event, functions[event]);
	  if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
	    registry = undefined;
	  }
	}

	function onExit () {
	  callRefs('exit');
	}

	function onBeforeExit () {
	  callRefs('beforeExit');
	}

	function callRefs (event) {
	  for (const ref of refs[event]) {
	    const obj = ref.deref();
	    const fn = ref.fn;

	    // This should always happen, however GC is
	    // undeterministic so it might not happen.
	    /* istanbul ignore else */
	    if (obj !== undefined) {
	      fn(obj, event);
	    }
	  }
	  refs[event] = [];
	}

	function clear (ref) {
	  for (const event of ['exit', 'beforeExit']) {
	    const index = refs[event].indexOf(ref);
	    refs[event].splice(index, index + 1);
	    uninstall(event);
	  }
	}

	function _register (event, obj, fn) {
	  if (obj === undefined) {
	    throw new Error('the object can\'t be undefined')
	  }
	  install(event);
	  const ref = new WeakRef(obj);
	  ref.fn = fn;

	  ensureRegistry();
	  registry.register(obj, ref);
	  refs[event].push(ref);
	}

	function register (obj, fn) {
	  _register('exit', obj, fn);
	}

	function registerBeforeExit (obj, fn) {
	  _register('beforeExit', obj, fn);
	}

	function unregister (obj) {
	  if (registry === undefined) {
	    return
	  }
	  registry.unregister(obj);
	  for (const event of ['exit', 'beforeExit']) {
	    refs[event] = refs[event].filter((ref) => {
	      const _obj = ref.deref();
	      return _obj && _obj !== obj
	    });
	    uninstall(event);
	  }
	}

	onExitLeakFree = {
	  register,
	  registerBeforeExit,
	  unregister
	};
	return onExitLeakFree;
}

var version = "3.1.0";
var require$$0$1 = {
	version: version};

var wait_1;
var hasRequiredWait;

function requireWait () {
	if (hasRequiredWait) return wait_1;
	hasRequiredWait = 1;

	const MAX_TIMEOUT = 1000;

	function wait (state, index, expected, timeout, done) {
	  const max = Date.now() + timeout;
	  let current = Atomics.load(state, index);
	  if (current === expected) {
	    done(null, 'ok');
	    return
	  }
	  let prior = current;
	  const check = (backoff) => {
	    if (Date.now() > max) {
	      done(null, 'timed-out');
	    } else {
	      setTimeout(() => {
	        prior = current;
	        current = Atomics.load(state, index);
	        if (current === prior) {
	          check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
	        } else {
	          if (current === expected) done(null, 'ok');
	          else done(null, 'not-equal');
	        }
	      }, backoff);
	    }
	  };
	  check(1);
	}

	// let waitDiffCount = 0
	function waitDiff (state, index, expected, timeout, done) {
	  // const id = waitDiffCount++
	  // process._rawDebug(`>>> waitDiff ${id}`)
	  const max = Date.now() + timeout;
	  let current = Atomics.load(state, index);
	  if (current !== expected) {
	    done(null, 'ok');
	    return
	  }
	  const check = (backoff) => {
	    // process._rawDebug(`${id} ${index} current ${current} expected ${expected}`)
	    // process._rawDebug('' + backoff)
	    if (Date.now() > max) {
	      done(null, 'timed-out');
	    } else {
	      setTimeout(() => {
	        current = Atomics.load(state, index);
	        if (current !== expected) {
	          done(null, 'ok');
	        } else {
	          check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
	        }
	      }, backoff);
	    }
	  };
	  check(1);
	}

	wait_1 = { wait, waitDiff };
	return wait_1;
}

var indexes;
var hasRequiredIndexes;

function requireIndexes () {
	if (hasRequiredIndexes) return indexes;
	hasRequiredIndexes = 1;

	const WRITE_INDEX = 4;
	const READ_INDEX = 8;

	indexes = {
	  WRITE_INDEX,
	  READ_INDEX
	};
	return indexes;
}

var threadStream;
var hasRequiredThreadStream;

function requireThreadStream () {
	if (hasRequiredThreadStream) return threadStream;
	hasRequiredThreadStream = 1;

	const { version } = require$$0$1;
	const { EventEmitter } = require$$0$7;
	const { Worker } = require$$2$1;
	const { join } = path;
	const { pathToFileURL } = require$$7;
	const { wait } = requireWait();
	const {
	  WRITE_INDEX,
	  READ_INDEX
	} = requireIndexes();
	const buffer = require$$0$8;
	const assert = require$$5;

	const kImpl = Symbol('kImpl');

	// V8 limit for string size
	const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

	class FakeWeakRef {
	  constructor (value) {
	    this._value = value;
	  }

	  deref () {
	    return this._value
	  }
	}

	class FakeFinalizationRegistry {
	  register () {}

	  unregister () {}
	}

	// Currently using FinalizationRegistry with code coverage breaks the world
	// Ref: https://github.com/nodejs/node/issues/49344
	const FinalizationRegistry = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
	const WeakRef = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;

	const registry = new FinalizationRegistry((worker) => {
	  if (worker.exited) {
	    return
	  }
	  worker.terminate();
	});

	function createWorker (stream, opts) {
	  const { filename, workerData } = opts;

	  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
	  const toExecute = bundlerOverrides['thread-stream-worker'] || join(__dirname, 'lib', 'worker.js');

	  const worker = new Worker(toExecute, {
	    ...opts.workerOpts,
	    trackUnmanagedFds: false,
	    workerData: {
	      filename: filename.indexOf('file://') === 0
	        ? filename
	        : pathToFileURL(filename).href,
	      dataBuf: stream[kImpl].dataBuf,
	      stateBuf: stream[kImpl].stateBuf,
	      workerData: {
	        $context: {
	          threadStreamVersion: version
	        },
	        ...workerData
	      }
	    }
	  });

	  // We keep a strong reference for now,
	  // we need to start writing first
	  worker.stream = new FakeWeakRef(stream);

	  worker.on('message', onWorkerMessage);
	  worker.on('exit', onWorkerExit);
	  registry.register(stream, worker);

	  return worker
	}

	function drain (stream) {
	  assert(!stream[kImpl].sync);
	  if (stream[kImpl].needDrain) {
	    stream[kImpl].needDrain = false;
	    stream.emit('drain');
	  }
	}

	function nextFlush (stream) {
	  const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	  let leftover = stream[kImpl].data.length - writeIndex;

	  if (leftover > 0) {
	    if (stream[kImpl].buf.length === 0) {
	      stream[kImpl].flushing = false;

	      if (stream[kImpl].ending) {
	        end(stream);
	      } else if (stream[kImpl].needDrain) {
	        process.nextTick(drain, stream);
	      }

	      return
	    }

	    let toWrite = stream[kImpl].buf.slice(0, leftover);
	    let toWriteBytes = Buffer.byteLength(toWrite);
	    if (toWriteBytes <= leftover) {
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      // process._rawDebug('writing ' + toWrite.length)
	      write(stream, toWrite, nextFlush.bind(null, stream));
	    } else {
	      // multi-byte utf-8
	      stream.flush(() => {
	        // err is already handled in flush()
	        if (stream.destroyed) {
	          return
	        }

	        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);

	        // Find a toWrite length that fits the buffer
	        // it must exists as the buffer is at least 4 bytes length
	        // and the max utf-8 length for a char is 4 bytes.
	        while (toWriteBytes > stream[kImpl].data.length) {
	          leftover = leftover / 2;
	          toWrite = stream[kImpl].buf.slice(0, leftover);
	          toWriteBytes = Buffer.byteLength(toWrite);
	        }
	        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	        write(stream, toWrite, nextFlush.bind(null, stream));
	      });
	    }
	  } else if (leftover === 0) {
	    if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
	      // we had a flushSync in the meanwhile
	      return
	    }
	    stream.flush(() => {
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
	      nextFlush(stream);
	    });
	  } else {
	    // This should never happen
	    destroy(stream, new Error('overwritten'));
	  }
	}

	function onWorkerMessage (msg) {
	  const stream = this.stream.deref();
	  if (stream === undefined) {
	    this.exited = true;
	    // Terminate the worker.
	    this.terminate();
	    return
	  }

	  switch (msg.code) {
	    case 'READY':
	      // Replace the FakeWeakRef with a
	      // proper one.
	      this.stream = new WeakRef(stream);

	      stream.flush(() => {
	        stream[kImpl].ready = true;
	        stream.emit('ready');
	      });
	      break
	    case 'ERROR':
	      destroy(stream, msg.err);
	      break
	    case 'EVENT':
	      if (Array.isArray(msg.args)) {
	        stream.emit(msg.name, ...msg.args);
	      } else {
	        stream.emit(msg.name, msg.args);
	      }
	      break
	    case 'WARNING':
	      process.emitWarning(msg.err);
	      break
	    default:
	      destroy(stream, new Error('this should not happen: ' + msg.code));
	  }
	}

	function onWorkerExit (code) {
	  const stream = this.stream.deref();
	  if (stream === undefined) {
	    // Nothing to do, the worker already exit
	    return
	  }
	  registry.unregister(stream);
	  stream.worker.exited = true;
	  stream.worker.off('exit', onWorkerExit);
	  destroy(stream, code !== 0 ? new Error('the worker thread exited') : null);
	}

	class ThreadStream extends EventEmitter {
	  constructor (opts = {}) {
	    super();

	    if (opts.bufferSize < 4) {
	      throw new Error('bufferSize must at least fit a 4-byte utf-8 char')
	    }

	    this[kImpl] = {};
	    this[kImpl].stateBuf = new SharedArrayBuffer(128);
	    this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
	    this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
	    this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
	    this[kImpl].sync = opts.sync || false;
	    this[kImpl].ending = false;
	    this[kImpl].ended = false;
	    this[kImpl].needDrain = false;
	    this[kImpl].destroyed = false;
	    this[kImpl].flushing = false;
	    this[kImpl].ready = false;
	    this[kImpl].finished = false;
	    this[kImpl].errored = null;
	    this[kImpl].closed = false;
	    this[kImpl].buf = '';

	    // TODO (fix): Make private?
	    this.worker = createWorker(this, opts); // TODO (fix): make private
	    this.on('message', (message, transferList) => {
	      this.worker.postMessage(message, transferList);
	    });
	  }

	  write (data) {
	    if (this[kImpl].destroyed) {
	      error(this, new Error('the worker has exited'));
	      return false
	    }

	    if (this[kImpl].ending) {
	      error(this, new Error('the worker is ending'));
	      return false
	    }

	    if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
	      try {
	        writeSync(this);
	        this[kImpl].flushing = true;
	      } catch (err) {
	        destroy(this, err);
	        return false
	      }
	    }

	    this[kImpl].buf += data;

	    if (this[kImpl].sync) {
	      try {
	        writeSync(this);
	        return true
	      } catch (err) {
	        destroy(this, err);
	        return false
	      }
	    }

	    if (!this[kImpl].flushing) {
	      this[kImpl].flushing = true;
	      setImmediate(nextFlush, this);
	    }

	    this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
	    return !this[kImpl].needDrain
	  }

	  end () {
	    if (this[kImpl].destroyed) {
	      return
	    }

	    this[kImpl].ending = true;
	    end(this);
	  }

	  flush (cb) {
	    if (this[kImpl].destroyed) {
	      if (typeof cb === 'function') {
	        process.nextTick(cb, new Error('the worker has exited'));
	      }
	      return
	    }

	    // TODO write all .buf
	    const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
	    // process._rawDebug(`(flush) readIndex (${Atomics.load(this.state, READ_INDEX)}) writeIndex (${Atomics.load(this.state, WRITE_INDEX)})`)
	    wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
	      if (err) {
	        destroy(this, err);
	        process.nextTick(cb, err);
	        return
	      }
	      if (res === 'not-equal') {
	        // TODO handle deadlock
	        this.flush(cb);
	        return
	      }
	      process.nextTick(cb);
	    });
	  }

	  flushSync () {
	    if (this[kImpl].destroyed) {
	      return
	    }

	    writeSync(this);
	    flushSync(this);
	  }

	  unref () {
	    this.worker.unref();
	  }

	  ref () {
	    this.worker.ref();
	  }

	  get ready () {
	    return this[kImpl].ready
	  }

	  get destroyed () {
	    return this[kImpl].destroyed
	  }

	  get closed () {
	    return this[kImpl].closed
	  }

	  get writable () {
	    return !this[kImpl].destroyed && !this[kImpl].ending
	  }

	  get writableEnded () {
	    return this[kImpl].ending
	  }

	  get writableFinished () {
	    return this[kImpl].finished
	  }

	  get writableNeedDrain () {
	    return this[kImpl].needDrain
	  }

	  get writableObjectMode () {
	    return false
	  }

	  get writableErrored () {
	    return this[kImpl].errored
	  }
	}

	function error (stream, err) {
	  setImmediate(() => {
	    stream.emit('error', err);
	  });
	}

	function destroy (stream, err) {
	  if (stream[kImpl].destroyed) {
	    return
	  }
	  stream[kImpl].destroyed = true;

	  if (err) {
	    stream[kImpl].errored = err;
	    error(stream, err);
	  }

	  if (!stream.worker.exited) {
	    stream.worker.terminate()
	      .catch(() => {})
	      .then(() => {
	        stream[kImpl].closed = true;
	        stream.emit('close');
	      });
	  } else {
	    setImmediate(() => {
	      stream[kImpl].closed = true;
	      stream.emit('close');
	    });
	  }
	}

	function write (stream, data, cb) {
	  // data is smaller than the shared buffer length
	  const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	  const length = Buffer.byteLength(data);
	  stream[kImpl].data.write(data, current);
	  Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
	  Atomics.notify(stream[kImpl].state, WRITE_INDEX);
	  cb();
	  return true
	}

	function end (stream) {
	  if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
	    return
	  }
	  stream[kImpl].ended = true;

	  try {
	    stream.flushSync();

	    let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	    // process._rawDebug('writing index')
	    Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
	    // process._rawDebug(`(end) readIndex (${Atomics.load(stream.state, READ_INDEX)}) writeIndex (${Atomics.load(stream.state, WRITE_INDEX)})`)
	    Atomics.notify(stream[kImpl].state, WRITE_INDEX);

	    // Wait for the process to complete
	    let spins = 0;
	    while (readIndex !== -1) {
	      // process._rawDebug(`read = ${read}`)
	      Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
	      readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	      if (readIndex === -2) {
	        destroy(stream, new Error('end() failed'));
	        return
	      }

	      if (++spins === 10) {
	        destroy(stream, new Error('end() took too long (10s)'));
	        return
	      }
	    }

	    process.nextTick(() => {
	      stream[kImpl].finished = true;
	      stream.emit('finish');
	    });
	  } catch (err) {
	    destroy(stream, err);
	  }
	  // process._rawDebug('end finished...')
	}

	function writeSync (stream) {
	  const cb = () => {
	    if (stream[kImpl].ending) {
	      end(stream);
	    } else if (stream[kImpl].needDrain) {
	      process.nextTick(drain, stream);
	    }
	  };
	  stream[kImpl].flushing = false;

	  while (stream[kImpl].buf.length !== 0) {
	    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
	    let leftover = stream[kImpl].data.length - writeIndex;
	    if (leftover === 0) {
	      flushSync(stream);
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
	      continue
	    } else if (leftover < 0) {
	      // stream should never happen
	      throw new Error('overwritten')
	    }

	    let toWrite = stream[kImpl].buf.slice(0, leftover);
	    let toWriteBytes = Buffer.byteLength(toWrite);
	    if (toWriteBytes <= leftover) {
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      // process._rawDebug('writing ' + toWrite.length)
	      write(stream, toWrite, cb);
	    } else {
	      // multi-byte utf-8
	      flushSync(stream);
	      Atomics.store(stream[kImpl].state, READ_INDEX, 0);
	      Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);

	      // Find a toWrite length that fits the buffer
	      // it must exists as the buffer is at least 4 bytes length
	      // and the max utf-8 length for a char is 4 bytes.
	      while (toWriteBytes > stream[kImpl].buf.length) {
	        leftover = leftover / 2;
	        toWrite = stream[kImpl].buf.slice(0, leftover);
	        toWriteBytes = Buffer.byteLength(toWrite);
	      }
	      stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
	      write(stream, toWrite, cb);
	    }
	  }
	}

	function flushSync (stream) {
	  if (stream[kImpl].flushing) {
	    throw new Error('unable to flush while flushing')
	  }

	  // process._rawDebug('flushSync started')

	  const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);

	  let spins = 0;

	  // TODO handle deadlock
	  while (true) {
	    const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);

	    if (readIndex === -2) {
	      throw Error('_flushSync failed')
	    }

	    // process._rawDebug(`(flushSync) readIndex (${readIndex}) writeIndex (${writeIndex})`)
	    if (readIndex !== writeIndex) {
	      // TODO stream timeouts for some reason.
	      Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
	    } else {
	      break
	    }

	    if (++spins === 10) {
	      throw new Error('_flushSync took too long (10s)')
	    }
	  }
	  // process._rawDebug('flushSync finished')
	}

	threadStream = ThreadStream;
	return threadStream;
}

var transport_1;
var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return transport_1;
	hasRequiredTransport = 1;

	const { createRequire } = require$$0$9;
	const getCallers = requireCaller();
	const { join, isAbsolute, sep } = require$$1$4;
	const sleep = requireAtomicSleep();
	const onExit = requireOnExitLeakFree();
	const ThreadStream = requireThreadStream();

	function setupOnExit (stream) {
	  // This is leak free, it does not leave event handlers
	  onExit.register(stream, autoEnd);
	  onExit.registerBeforeExit(stream, flush);

	  stream.on('close', function () {
	    onExit.unregister(stream);
	  });
	}

	function buildStream (filename, workerData, workerOpts, sync) {
	  const stream = new ThreadStream({
	    filename,
	    workerData,
	    workerOpts,
	    sync
	  });

	  stream.on('ready', onReady);
	  stream.on('close', function () {
	    process.removeListener('exit', onExit);
	  });

	  process.on('exit', onExit);

	  function onReady () {
	    process.removeListener('exit', onExit);
	    stream.unref();

	    if (workerOpts.autoEnd !== false) {
	      setupOnExit(stream);
	    }
	  }

	  function onExit () {
	    /* istanbul ignore next */
	    if (stream.closed) {
	      return
	    }
	    stream.flushSync();
	    // Apparently there is a very sporadic race condition
	    // that in certain OS would prevent the messages to be flushed
	    // because the thread might not have been created still.
	    // Unfortunately we need to sleep(100) in this case.
	    sleep(100);
	    stream.end();
	  }

	  return stream
	}

	function autoEnd (stream) {
	  stream.ref();
	  stream.flushSync();
	  stream.end();
	  stream.once('close', function () {
	    stream.unref();
	  });
	}

	function flush (stream) {
	  stream.flushSync();
	}

	function transport (fullOptions) {
	  const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;

	  const options = {
	    ...fullOptions.options
	  };

	  // Backwards compatibility
	  const callers = typeof caller === 'string' ? [caller] : caller;

	  // This will be eventually modified by bundlers
	  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};

	  let target = fullOptions.target;

	  if (target && targets) {
	    throw new Error('only one of target or targets can be specified')
	  }

	  if (targets) {
	    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js');
	    options.targets = targets.filter(dest => dest.target).map((dest) => {
	      return {
	        ...dest,
	        target: fixTarget(dest.target)
	      }
	    });
	    options.pipelines = targets.filter(dest => dest.pipeline).map((dest) => {
	      return dest.pipeline.map((t) => {
	        return {
	          ...t,
	          level: dest.level, // duplicate the pipeline `level` property defined in the upper level
	          target: fixTarget(t.target)
	        }
	      })
	    });
	  } else if (pipeline) {
	    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js');
	    options.pipelines = [pipeline.map((dest) => {
	      return {
	        ...dest,
	        target: fixTarget(dest.target)
	      }
	    })];
	  }

	  if (levels) {
	    options.levels = levels;
	  }

	  if (dedupe) {
	    options.dedupe = dedupe;
	  }

	  options.pinoWillSendConfig = true;

	  return buildStream(fixTarget(target), options, worker, sync)

	  function fixTarget (origin) {
	    origin = bundlerOverrides[origin] || origin;

	    if (isAbsolute(origin) || origin.indexOf('file://') === 0) {
	      return origin
	    }

	    if (origin === 'pino/file') {
	      return join(__dirname, '..', 'file.js')
	    }

	    let fixTarget;

	    for (const filePath of callers) {
	      try {
	        const context = filePath === 'node:repl'
	          ? process.cwd() + sep
	          : filePath;

	        fixTarget = createRequire(context).resolve(origin);
	        break
	      } catch (err) {
	        // Silent catch
	        continue
	      }
	    }

	    if (!fixTarget) {
	      throw new Error(`unable to determine transport target for "${origin}"`)
	    }

	    return fixTarget
	  }
	}

	transport_1 = transport;
	return transport_1;
}

var tools;
var hasRequiredTools;

function requireTools () {
	if (hasRequiredTools) return tools;
	hasRequiredTools = 1;

	/* eslint no-prototype-builtins: 0 */

	const format = requireQuickFormatUnescaped();
	const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
	const SonicBoom = requireSonicBoom();
	const onExit = requireOnExitLeakFree();
	const {
	  lsCacheSym,
	  chindingsSym,
	  writeSym,
	  serializersSym,
	  formatOptsSym,
	  endSym,
	  stringifiersSym,
	  stringifySym,
	  stringifySafeSym,
	  wildcardFirstSym,
	  nestedKeySym,
	  formattersSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeyStrSym,
	  msgPrefixSym
	} = requireSymbols$1();
	const { isMainThread } = require$$2$1;
	const transport = requireTransport();

	function noop () {
	}

	function genLog (level, hook) {
	  if (!hook) return LOG

	  return function hookWrappedLog (...args) {
	    hook.call(this, args, LOG, level);
	  }

	  function LOG (o, ...n) {
	    if (typeof o === 'object') {
	      let msg = o;
	      if (o !== null) {
	        if (o.method && o.headers && o.socket) {
	          o = mapHttpRequest(o);
	        } else if (typeof o.setHeader === 'function') {
	          o = mapHttpResponse(o);
	        }
	      }
	      let formatParams;
	      if (msg === null && n.length === 0) {
	        formatParams = [null];
	      } else {
	        msg = n.shift();
	        formatParams = n;
	      }
	      // We do not use a coercive check for `msg` as it is
	      // measurably slower than the explicit checks.
	      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
	        msg = this[msgPrefixSym] + msg;
	      }
	      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
	    } else {
	      let msg = o === undefined ? n.shift() : o;

	      // We do not use a coercive check for `msg` as it is
	      // measurably slower than the explicit checks.
	      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
	        msg = this[msgPrefixSym] + msg;
	      }
	      this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
	    }
	  }
	}

	// magically escape strings for json
	// relying on their charCodeAt
	// everything below 32 needs JSON.stringify()
	// 34 and 92 happens all the time, so we
	// have a fast case for them
	function asString (str) {
	  let result = '';
	  let last = 0;
	  let found = false;
	  let point = 255;
	  const l = str.length;
	  if (l > 100) {
	    return JSON.stringify(str)
	  }
	  for (var i = 0; i < l && point >= 32; i++) {
	    point = str.charCodeAt(i);
	    if (point === 34 || point === 92) {
	      result += str.slice(last, i) + '\\';
	      last = i;
	      found = true;
	    }
	  }
	  if (!found) {
	    result = str;
	  } else {
	    result += str.slice(last);
	  }
	  return point < 32 ? JSON.stringify(str) : '"' + result + '"'
	}

	function asJson (obj, msg, num, time) {
	  const stringify = this[stringifySym];
	  const stringifySafe = this[stringifySafeSym];
	  const stringifiers = this[stringifiersSym];
	  const end = this[endSym];
	  const chindings = this[chindingsSym];
	  const serializers = this[serializersSym];
	  const formatters = this[formattersSym];
	  const messageKey = this[messageKeySym];
	  const errorKey = this[errorKeySym];
	  let data = this[lsCacheSym][num] + time;

	  // we need the child bindings added to the output first so instance logged
	  // objects can take precedence when JSON.parse-ing the resulting log line
	  data = data + chindings;

	  let value;
	  if (formatters.log) {
	    obj = formatters.log(obj);
	  }
	  const wildcardStringifier = stringifiers[wildcardFirstSym];
	  let propStr = '';
	  for (const key in obj) {
	    value = obj[key];
	    if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
	      if (serializers[key]) {
	        value = serializers[key](value);
	      } else if (key === errorKey && serializers.err) {
	        value = serializers.err(value);
	      }

	      const stringifier = stringifiers[key] || wildcardStringifier;

	      switch (typeof value) {
	        case 'undefined':
	        case 'function':
	          continue
	        case 'number':
	          /* eslint no-fallthrough: "off" */
	          if (Number.isFinite(value) === false) {
	            value = null;
	          }
	        // this case explicitly falls through to the next one
	        case 'boolean':
	          if (stringifier) value = stringifier(value);
	          break
	        case 'string':
	          value = (stringifier || asString)(value);
	          break
	        default:
	          value = (stringifier || stringify)(value, stringifySafe);
	      }
	      if (value === undefined) continue
	      const strKey = asString(key);
	      propStr += ',' + strKey + ':' + value;
	    }
	  }

	  let msgStr = '';
	  if (msg !== undefined) {
	    value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
	    const stringifier = stringifiers[messageKey] || wildcardStringifier;

	    switch (typeof value) {
	      case 'function':
	        break
	      case 'number':
	        /* eslint no-fallthrough: "off" */
	        if (Number.isFinite(value) === false) {
	          value = null;
	        }
	      // this case explicitly falls through to the next one
	      case 'boolean':
	        if (stringifier) value = stringifier(value);
	        msgStr = ',"' + messageKey + '":' + value;
	        break
	      case 'string':
	        value = (stringifier || asString)(value);
	        msgStr = ',"' + messageKey + '":' + value;
	        break
	      default:
	        value = (stringifier || stringify)(value, stringifySafe);
	        msgStr = ',"' + messageKey + '":' + value;
	    }
	  }

	  if (this[nestedKeySym] && propStr) {
	    // place all the obj properties under the specified key
	    // the nested key is already formatted from the constructor
	    return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end
	  } else {
	    return data + propStr + msgStr + end
	  }
	}

	function asChindings (instance, bindings) {
	  let value;
	  let data = instance[chindingsSym];
	  const stringify = instance[stringifySym];
	  const stringifySafe = instance[stringifySafeSym];
	  const stringifiers = instance[stringifiersSym];
	  const wildcardStringifier = stringifiers[wildcardFirstSym];
	  const serializers = instance[serializersSym];
	  const formatter = instance[formattersSym].bindings;
	  bindings = formatter(bindings);

	  for (const key in bindings) {
	    value = bindings[key];
	    const valid = key !== 'level' &&
	      key !== 'serializers' &&
	      key !== 'formatters' &&
	      key !== 'customLevels' &&
	      bindings.hasOwnProperty(key) &&
	      value !== undefined;
	    if (valid === true) {
	      value = serializers[key] ? serializers[key](value) : value;
	      value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);
	      if (value === undefined) continue
	      data += ',"' + key + '":' + value;
	    }
	  }
	  return data
	}

	function hasBeenTampered (stream) {
	  return stream.write !== stream.constructor.prototype.write
	}

	function buildSafeSonicBoom (opts) {
	  const stream = new SonicBoom(opts);
	  stream.on('error', filterBrokenPipe);
	  // If we are sync: false, we must flush on exit
	  if (!opts.sync && isMainThread) {
	    onExit.register(stream, autoEnd);

	    stream.on('close', function () {
	      onExit.unregister(stream);
	    });
	  }
	  return stream

	  function filterBrokenPipe (err) {
	    // Impossible to replicate across all operating systems
	    /* istanbul ignore next */
	    if (err.code === 'EPIPE') {
	      // If we get EPIPE, we should stop logging here
	      // however we have no control to the consumer of
	      // SonicBoom, so we just overwrite the write method
	      stream.write = noop;
	      stream.end = noop;
	      stream.flushSync = noop;
	      stream.destroy = noop;
	      return
	    }
	    stream.removeListener('error', filterBrokenPipe);
	    stream.emit('error', err);
	  }
	}

	function autoEnd (stream, eventName) {
	  // This check is needed only on some platforms
	  /* istanbul ignore next */
	  if (stream.destroyed) {
	    return
	  }

	  if (eventName === 'beforeExit') {
	    // We still have an event loop, let's use it
	    stream.flush();
	    stream.on('drain', function () {
	      stream.end();
	    });
	  } else {
	    // For some reason istanbul is not detecting this, but it's there
	    /* istanbul ignore next */
	    // We do not have an event loop, so flush synchronously
	    stream.flushSync();
	  }
	}

	function createArgsNormalizer (defaultOptions) {
	  return function normalizeArgs (instance, caller, opts = {}, stream) {
	    // support stream as a string
	    if (typeof opts === 'string') {
	      stream = buildSafeSonicBoom({ dest: opts });
	      opts = {};
	    } else if (typeof stream === 'string') {
	      if (opts && opts.transport) {
	        throw Error('only one of option.transport or stream can be specified')
	      }
	      stream = buildSafeSonicBoom({ dest: stream });
	    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
	      stream = opts;
	      opts = {};
	    } else if (opts.transport) {
	      if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
	        throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)')
	      }
	      if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {
	        throw Error('option.transport.targets do not allow custom level formatters')
	      }

	      let customLevels;
	      if (opts.customLevels) {
	        customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
	      }
	      stream = transport({ caller, ...opts.transport, levels: customLevels });
	    }
	    opts = Object.assign({}, defaultOptions, opts);
	    opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
	    opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);

	    if (opts.prettyPrint) {
	      throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)')
	    }

	    const { enabled, onChild } = opts;
	    if (enabled === false) opts.level = 'silent';
	    if (!onChild) opts.onChild = noop;
	    if (!stream) {
	      if (!hasBeenTampered(process.stdout)) {
	        // If process.stdout.fd is undefined, it means that we are running
	        // in a worker thread. Let's assume we are logging to file descriptor 1.
	        stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
	      } else {
	        stream = process.stdout;
	      }
	    }
	    return { opts, stream }
	  }
	}

	function stringify (obj, stringifySafeFn) {
	  try {
	    return JSON.stringify(obj)
	  } catch (_) {
	    try {
	      const stringify = stringifySafeFn || this[stringifySafeSym];
	      return stringify(obj)
	    } catch (_) {
	      return '"[unable to serialize, circular reference is too complex to analyze]"'
	    }
	  }
	}

	function buildFormatters (level, bindings, log) {
	  return {
	    level,
	    bindings,
	    log
	  }
	}

	/**
	 * Convert a string integer file descriptor to a proper native integer
	 * file descriptor.
	 *
	 * @param {string} destination The file descriptor string to attempt to convert.
	 *
	 * @returns {Number}
	 */
	function normalizeDestFileDescriptor (destination) {
	  const fd = Number(destination);
	  if (typeof destination === 'string' && Number.isFinite(fd)) {
	    return fd
	  }
	  // destination could be undefined if we are in a worker
	  if (destination === undefined) {
	    // This is stdout in UNIX systems
	    return 1
	  }
	  return destination
	}

	tools = {
	  noop,
	  buildSafeSonicBoom,
	  asChindings,
	  asJson,
	  genLog,
	  createArgsNormalizer,
	  stringify,
	  buildFormatters,
	  normalizeDestFileDescriptor
	};
	return tools;
}

/**
 * Represents default log level values
 *
 * @enum {number}
 */

var constants$4;
var hasRequiredConstants$4;

function requireConstants$4 () {
	if (hasRequiredConstants$4) return constants$4;
	hasRequiredConstants$4 = 1;
	const DEFAULT_LEVELS = {
	  trace: 10,
	  debug: 20,
	  info: 30,
	  warn: 40,
	  error: 50,
	  fatal: 60
	};

	/**
	 * Represents sort order direction: `ascending` or `descending`
	 *
	 * @enum {string}
	 */
	const SORTING_ORDER = {
	  ASC: 'ASC',
	  DESC: 'DESC'
	};

	constants$4 = {
	  DEFAULT_LEVELS,
	  SORTING_ORDER
	};
	return constants$4;
}

var levels;
var hasRequiredLevels;

function requireLevels () {
	if (hasRequiredLevels) return levels;
	hasRequiredLevels = 1;
	/* eslint no-prototype-builtins: 0 */
	const {
	  lsCacheSym,
	  levelValSym,
	  useOnlyCustomLevelsSym,
	  streamSym,
	  formattersSym,
	  hooksSym,
	  levelCompSym
	} = requireSymbols$1();
	const { noop, genLog } = requireTools();
	const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$4();

	const levelMethods = {
	  fatal: (hook) => {
	    const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
	    return function (...args) {
	      const stream = this[streamSym];
	      logFatal.call(this, ...args);
	      if (typeof stream.flushSync === 'function') {
	        try {
	          stream.flushSync();
	        } catch (e) {
	          // https://github.com/pinojs/pino/pull/740#discussion_r346788313
	        }
	      }
	    }
	  },
	  error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
	  warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
	  info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
	  debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
	  trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
	};

	const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
	  o[DEFAULT_LEVELS[k]] = k;
	  return o
	}, {});

	const initialLsCache = Object.keys(nums).reduce((o, k) => {
	  o[k] = '{"level":' + Number(k);
	  return o
	}, {});

	function genLsCache (instance) {
	  const formatter = instance[formattersSym].level;
	  const { labels } = instance.levels;
	  const cache = {};
	  for (const label in labels) {
	    const level = formatter(labels[label], Number(label));
	    cache[label] = JSON.stringify(level).slice(0, -1);
	  }
	  instance[lsCacheSym] = cache;
	  return instance
	}

	function isStandardLevel (level, useOnlyCustomLevels) {
	  if (useOnlyCustomLevels) {
	    return false
	  }

	  switch (level) {
	    case 'fatal':
	    case 'error':
	    case 'warn':
	    case 'info':
	    case 'debug':
	    case 'trace':
	      return true
	    default:
	      return false
	  }
	}

	function setLevel (level) {
	  const { labels, values } = this.levels;
	  if (typeof level === 'number') {
	    if (labels[level] === undefined) throw Error('unknown level value' + level)
	    level = labels[level];
	  }
	  if (values[level] === undefined) throw Error('unknown level ' + level)
	  const preLevelVal = this[levelValSym];
	  const levelVal = this[levelValSym] = values[level];
	  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
	  const levelComparison = this[levelCompSym];
	  const hook = this[hooksSym].logMethod;

	  for (const key in values) {
	    if (levelComparison(values[key], levelVal) === false) {
	      this[key] = noop;
	      continue
	    }
	    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
	  }

	  this.emit(
	    'level-change',
	    level,
	    levelVal,
	    labels[preLevelVal],
	    preLevelVal,
	    this
	  );
	}

	function getLevel (level) {
	  const { levels, levelVal } = this;
	  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
	  return (levels && levels.labels) ? levels.labels[levelVal] : ''
	}

	function isLevelEnabled (logLevel) {
	  const { values } = this.levels;
	  const logLevelVal = values[logLevel];
	  return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym])
	}

	/**
	 * Determine if the given `current` level is enabled by comparing it
	 * against the current threshold (`expected`).
	 *
	 * @param {SORTING_ORDER} direction comparison direction "ASC" or "DESC"
	 * @param {number} current current log level number representation
	 * @param {number} expected threshold value to compare with
	 * @returns {boolean}
	 */
	function compareLevel (direction, current, expected) {
	  if (direction === SORTING_ORDER.DESC) {
	    return current <= expected
	  }

	  return current >= expected
	}

	/**
	 * Create a level comparison function based on `levelComparison`
	 * it could a default function which compares levels either in "ascending" or "descending" order or custom comparison function
	 *
	 * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function
	 * @returns Function
	 */
	function genLevelComparison (levelComparison) {
	  if (typeof levelComparison === 'string') {
	    return compareLevel.bind(null, levelComparison)
	  }

	  return levelComparison
	}

	function mappings (customLevels = null, useOnlyCustomLevels = false) {
	  const customNums = customLevels
	    /* eslint-disable */
	    ? Object.keys(customLevels).reduce((o, k) => {
	        o[customLevels[k]] = k;
	        return o
	      }, {})
	    : null;
	    /* eslint-enable */

	  const labels = Object.assign(
	    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),
	    useOnlyCustomLevels ? null : nums,
	    customNums
	  );
	  const values = Object.assign(
	    Object.create(Object.prototype, { silent: { value: Infinity } }),
	    useOnlyCustomLevels ? null : DEFAULT_LEVELS,
	    customLevels
	  );
	  return { labels, values }
	}

	function assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {
	  if (typeof defaultLevel === 'number') {
	    const values = [].concat(
	      Object.keys(customLevels || {}).map(key => customLevels[key]),
	      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),
	      Infinity
	    );
	    if (!values.includes(defaultLevel)) {
	      throw Error(`default level:${defaultLevel} must be included in custom levels`)
	    }
	    return
	  }

	  const labels = Object.assign(
	    Object.create(Object.prototype, { silent: { value: Infinity } }),
	    useOnlyCustomLevels ? null : DEFAULT_LEVELS,
	    customLevels
	  );
	  if (!(defaultLevel in labels)) {
	    throw Error(`default level:${defaultLevel} must be included in custom levels`)
	  }
	}

	function assertNoLevelCollisions (levels, customLevels) {
	  const { labels, values } = levels;
	  for (const k in customLevels) {
	    if (k in values) {
	      throw Error('levels cannot be overridden')
	    }
	    if (customLevels[k] in labels) {
	      throw Error('pre-existing level values cannot be used for new levels')
	    }
	  }
	}

	/**
	 * Validates whether `levelComparison` is correct
	 *
	 * @throws Error
	 * @param {SORTING_ORDER | Function} levelComparison - value to validate
	 * @returns
	 */
	function assertLevelComparison (levelComparison) {
	  if (typeof levelComparison === 'function') {
	    return
	  }

	  if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {
	    return
	  }

	  throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type')
	}

	levels = {
	  initialLsCache,
	  genLsCache,
	  levelMethods,
	  getLevel,
	  setLevel,
	  isLevelEnabled,
	  mappings,
	  assertNoLevelCollisions,
	  assertDefaultLevelFound,
	  genLevelComparison,
	  assertLevelComparison
	};
	return levels;
}

var meta;
var hasRequiredMeta;

function requireMeta () {
	if (hasRequiredMeta) return meta;
	hasRequiredMeta = 1;

	meta = { version: '9.7.0' };
	return meta;
}

var proto;
var hasRequiredProto;

function requireProto () {
	if (hasRequiredProto) return proto;
	hasRequiredProto = 1;

	/* eslint no-prototype-builtins: 0 */

	const { EventEmitter } = require$$0$4;
	const {
	  lsCacheSym,
	  levelValSym,
	  setLevelSym,
	  getLevelSym,
	  chindingsSym,
	  parsedChindingsSym,
	  mixinSym,
	  asJsonSym,
	  writeSym,
	  mixinMergeStrategySym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  serializersSym,
	  formattersSym,
	  errorKeySym,
	  messageKeySym,
	  useOnlyCustomLevelsSym,
	  needsMetadataGsym,
	  redactFmtSym,
	  stringifySym,
	  formatOptsSym,
	  stringifiersSym,
	  msgPrefixSym,
	  hooksSym
	} = requireSymbols$1();
	const {
	  getLevel,
	  setLevel,
	  isLevelEnabled,
	  mappings,
	  initialLsCache,
	  genLsCache,
	  assertNoLevelCollisions
	} = requireLevels();
	const {
	  asChindings,
	  asJson,
	  buildFormatters,
	  stringify
	} = requireTools();
	const {
	  version
	} = requireMeta();
	const redaction = requireRedaction();

	// note: use of class is satirical
	// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
	const constructor = class Pino {};
	const prototype = {
	  constructor,
	  child,
	  bindings,
	  setBindings,
	  flush,
	  isLevelEnabled,
	  version,
	  get level () { return this[getLevelSym]() },
	  set level (lvl) { this[setLevelSym](lvl); },
	  get levelVal () { return this[levelValSym] },
	  set levelVal (n) { throw Error('levelVal is read-only') },
	  [lsCacheSym]: initialLsCache,
	  [writeSym]: write,
	  [asJsonSym]: asJson,
	  [getLevelSym]: getLevel,
	  [setLevelSym]: setLevel
	};

	Object.setPrototypeOf(prototype, EventEmitter.prototype);

	// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
	proto = function () {
	  return Object.create(prototype)
	};

	const resetChildingsFormatter = bindings => bindings;
	function child (bindings, options) {
	  if (!bindings) {
	    throw Error('missing bindings for child Pino')
	  }
	  options = options || {}; // default options to empty object
	  const serializers = this[serializersSym];
	  const formatters = this[formattersSym];
	  const instance = Object.create(this);

	  if (options.hasOwnProperty('serializers') === true) {
	    instance[serializersSym] = Object.create(null);

	    for (const k in serializers) {
	      instance[serializersSym][k] = serializers[k];
	    }
	    const parentSymbols = Object.getOwnPropertySymbols(serializers);
	    /* eslint no-var: off */
	    for (var i = 0; i < parentSymbols.length; i++) {
	      const ks = parentSymbols[i];
	      instance[serializersSym][ks] = serializers[ks];
	    }

	    for (const bk in options.serializers) {
	      instance[serializersSym][bk] = options.serializers[bk];
	    }
	    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
	    for (var bi = 0; bi < bindingsSymbols.length; bi++) {
	      const bks = bindingsSymbols[bi];
	      instance[serializersSym][bks] = options.serializers[bks];
	    }
	  } else instance[serializersSym] = serializers;
	  if (options.hasOwnProperty('formatters')) {
	    const { level, bindings: chindings, log } = options.formatters;
	    instance[formattersSym] = buildFormatters(
	      level || formatters.level,
	      chindings || resetChildingsFormatter,
	      log || formatters.log
	    );
	  } else {
	    instance[formattersSym] = buildFormatters(
	      formatters.level,
	      resetChildingsFormatter,
	      formatters.log
	    );
	  }
	  if (options.hasOwnProperty('customLevels') === true) {
	    assertNoLevelCollisions(this.levels, options.customLevels);
	    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
	    genLsCache(instance);
	  }

	  // redact must place before asChindings and only replace if exist
	  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {
	    instance.redact = options.redact; // replace redact directly
	    const stringifiers = redaction(instance.redact, stringify);
	    const formatOpts = { stringify: stringifiers[redactFmtSym] };
	    instance[stringifySym] = stringify;
	    instance[stringifiersSym] = stringifiers;
	    instance[formatOptsSym] = formatOpts;
	  }

	  if (typeof options.msgPrefix === 'string') {
	    instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix;
	  }

	  instance[chindingsSym] = asChindings(instance, bindings);
	  const childLevel = options.level || this.level;
	  instance[setLevelSym](childLevel);
	  this.onChild(instance);
	  return instance
	}

	function bindings () {
	  const chindings = this[chindingsSym];
	  const chindingsJson = `{${chindings.substr(1)}}`; // at least contains ,"pid":7068,"hostname":"myMac"
	  const bindingsFromJson = JSON.parse(chindingsJson);
	  delete bindingsFromJson.pid;
	  delete bindingsFromJson.hostname;
	  return bindingsFromJson
	}

	function setBindings (newBindings) {
	  const chindings = asChindings(this, newBindings);
	  this[chindingsSym] = chindings;
	  delete this[parsedChindingsSym];
	}

	/**
	 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
	 * Fields from `mergeObject` have higher priority in this strategy.
	 *
	 * @param {Object} mergeObject The object a user has supplied to the logging function.
	 * @param {Object} mixinObject The result of the `mixin` method.
	 * @return {Object}
	 */
	function defaultMixinMergeStrategy (mergeObject, mixinObject) {
	  return Object.assign(mixinObject, mergeObject)
	}

	function write (_obj, msg, num) {
	  const t = this[timeSym]();
	  const mixin = this[mixinSym];
	  const errorKey = this[errorKeySym];
	  const messageKey = this[messageKeySym];
	  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
	  let obj;
	  const streamWriteHook = this[hooksSym].streamWrite;

	  if (_obj === undefined || _obj === null) {
	    obj = {};
	  } else if (_obj instanceof Error) {
	    obj = { [errorKey]: _obj };
	    if (msg === undefined) {
	      msg = _obj.message;
	    }
	  } else {
	    obj = _obj;
	    if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
	      msg = _obj[errorKey].message;
	    }
	  }

	  if (mixin) {
	    obj = mixinMergeStrategy(obj, mixin(obj, num, this));
	  }

	  const s = this[asJsonSym](obj, msg, num, t);

	  const stream = this[streamSym];
	  if (stream[needsMetadataGsym] === true) {
	    stream.lastLevel = num;
	    stream.lastObj = obj;
	    stream.lastMsg = msg;
	    stream.lastTime = t.slice(this[timeSliceIndexSym]);
	    stream.lastLogger = this; // for child loggers
	  }
	  stream.write(streamWriteHook ? streamWriteHook(s) : s);
	}

	function noop () {}

	function flush (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw Error('callback must be a function')
	  }

	  const stream = this[streamSym];

	  if (typeof stream.flush === 'function') {
	    stream.flush(cb || noop);
	  } else if (cb) cb();
	}
	return proto;
}

var safeStableStringify = {exports: {}};

var hasRequiredSafeStableStringify;

function requireSafeStableStringify () {
	if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
	hasRequiredSafeStableStringify = 1;
	(function (module, exports) {

		const { hasOwnProperty } = Object.prototype;

		const stringify = configure();

		// @ts-expect-error
		stringify.configure = configure;
		// @ts-expect-error
		stringify.stringify = stringify;

		// @ts-expect-error
		stringify.default = stringify;

		// @ts-expect-error used for named export
		exports.stringify = stringify;
		// @ts-expect-error used for named export
		exports.configure = configure;

		module.exports = stringify;

		// eslint-disable-next-line no-control-regex
		const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;

		// Escape C0 control characters, double quotes, the backslash and every code
		// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
		function strEscape (str) {
		  // Some magic numbers that worked out fine while benchmarking with v8 8.0
		  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
		    return `"${str}"`
		  }
		  return JSON.stringify(str)
		}

		function sort (array, comparator) {
		  // Insertion sort is very efficient for small input sizes, but it has a bad
		  // worst case complexity. Thus, use native array sort for bigger values.
		  if (array.length > 2e2 || comparator) {
		    return array.sort(comparator)
		  }
		  for (let i = 1; i < array.length; i++) {
		    const currentValue = array[i];
		    let position = i;
		    while (position !== 0 && array[position - 1] > currentValue) {
		      array[position] = array[position - 1];
		      position--;
		    }
		    array[position] = currentValue;
		  }
		  return array
		}

		const typedArrayPrototypeGetSymbolToStringTag =
		  Object.getOwnPropertyDescriptor(
		    Object.getPrototypeOf(
		      Object.getPrototypeOf(
		        new Int8Array()
		      )
		    ),
		    Symbol.toStringTag
		  ).get;

		function isTypedArrayWithEntries (value) {
		  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
		}

		function stringifyTypedArray (array, separator, maximumBreadth) {
		  if (array.length < maximumBreadth) {
		    maximumBreadth = array.length;
		  }
		  const whitespace = separator === ',' ? '' : ' ';
		  let res = `"0":${whitespace}${array[0]}`;
		  for (let i = 1; i < maximumBreadth; i++) {
		    res += `${separator}"${i}":${whitespace}${array[i]}`;
		  }
		  return res
		}

		function getCircularValueOption (options) {
		  if (hasOwnProperty.call(options, 'circularValue')) {
		    const circularValue = options.circularValue;
		    if (typeof circularValue === 'string') {
		      return `"${circularValue}"`
		    }
		    if (circularValue == null) {
		      return circularValue
		    }
		    if (circularValue === Error || circularValue === TypeError) {
		      return {
		        toString () {
		          throw new TypeError('Converting circular structure to JSON')
		        }
		      }
		    }
		    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
		  }
		  return '"[Circular]"'
		}

		function getDeterministicOption (options) {
		  let value;
		  if (hasOwnProperty.call(options, 'deterministic')) {
		    value = options.deterministic;
		    if (typeof value !== 'boolean' && typeof value !== 'function') {
		      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function')
		    }
		  }
		  return value === undefined ? true : value
		}

		function getBooleanOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'boolean') {
		      throw new TypeError(`The "${key}" argument must be of type boolean`)
		    }
		  }
		  return value === undefined ? true : value
		}

		function getPositiveIntegerOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'number') {
		      throw new TypeError(`The "${key}" argument must be of type number`)
		    }
		    if (!Number.isInteger(value)) {
		      throw new TypeError(`The "${key}" argument must be an integer`)
		    }
		    if (value < 1) {
		      throw new RangeError(`The "${key}" argument must be >= 1`)
		    }
		  }
		  return value === undefined ? Infinity : value
		}

		function getItemCount (number) {
		  if (number === 1) {
		    return '1 item'
		  }
		  return `${number} items`
		}

		function getUniqueReplacerSet (replacerArray) {
		  const replacerSet = new Set();
		  for (const value of replacerArray) {
		    if (typeof value === 'string' || typeof value === 'number') {
		      replacerSet.add(String(value));
		    }
		  }
		  return replacerSet
		}

		function getStrictOption (options) {
		  if (hasOwnProperty.call(options, 'strict')) {
		    const value = options.strict;
		    if (typeof value !== 'boolean') {
		      throw new TypeError('The "strict" argument must be of type boolean')
		    }
		    if (value) {
		      return (value) => {
		        let message = `Object can not safely be stringified. Received type ${typeof value}`;
		        if (typeof value !== 'function') message += ` (${value.toString()})`;
		        throw new Error(message)
		      }
		    }
		  }
		}

		function configure (options) {
		  options = { ...options };
		  const fail = getStrictOption(options);
		  if (fail) {
		    if (options.bigint === undefined) {
		      options.bigint = false;
		    }
		    if (!('circularValue' in options)) {
		      options.circularValue = Error;
		    }
		  }
		  const circularValue = getCircularValueOption(options);
		  const bigint = getBooleanOption(options, 'bigint');
		  const deterministic = getDeterministicOption(options);
		  const comparator = typeof deterministic === 'function' ? deterministic : undefined;
		  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
		  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');

		  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
		    let value = parent[key];

		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }
		    value = replacer.call(parent, key, value);

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';
		        let join = ',';
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let whitespace = '';
		        let separator = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (deterministic && !isTypedArrayWithEntries(value)) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        const originalIndentation = indentation;
		        let res = '';
		        let join = ',';

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }
		        stack.push(value);
		        let whitespace = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        let separator = '';
		        for (const key of replacer) {
		          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyIndent (key, value, stack, spacer, indentation) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again.
		          if (typeof value !== 'object') {
		            return stringifyIndent(key, value, stack, spacer, indentation)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          indentation += spacer;
		          let res = `\n${indentation}`;
		          const join = `,\n${indentation}`;
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          res += `\n${originalIndentation}`;
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        indentation += spacer;
		        const join = `,\n${indentation}`;
		        let res = '';
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, join, maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = join;
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}: ${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (separator !== '') {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifySimple (key, value, stack) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again
		          if (typeof value !== 'object') {
		            return stringifySimple(key, value, stack)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';

		        const hasLength = value.length !== undefined;
		        if (hasLength && Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifySimple(String(i), value[i], stack);
		            res += tmp !== undefined ? tmp : 'null';
		            res += ',';
		          }
		          const tmp = stringifySimple(String(i), value[i], stack);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (hasLength && isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, ',', maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = ',';
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifySimple(key, value[key], stack);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${tmp}`;
		            separator = ',';
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringify (value, replacer, space) {
		    if (arguments.length > 1) {
		      let spacer = '';
		      if (typeof space === 'number') {
		        spacer = ' '.repeat(Math.min(space, 10));
		      } else if (typeof space === 'string') {
		        spacer = space.slice(0, 10);
		      }
		      if (replacer != null) {
		        if (typeof replacer === 'function') {
		          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
		        }
		        if (Array.isArray(replacer)) {
		          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
		        }
		      }
		      if (spacer.length !== 0) {
		        return stringifyIndent('', value, [], spacer, '')
		      }
		    }
		    return stringifySimple('', value, [])
		  }

		  return stringify
		} 
	} (safeStableStringify, safeStableStringify.exports));
	return safeStableStringify.exports;
}

var multistream_1;
var hasRequiredMultistream;

function requireMultistream () {
	if (hasRequiredMultistream) return multistream_1;
	hasRequiredMultistream = 1;

	const metadata = Symbol.for('pino.metadata');
	const { DEFAULT_LEVELS } = requireConstants$4();

	const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;

	function multistream (streamsArray, opts) {
	  let counter = 0;
	  streamsArray = streamsArray || [];
	  opts = opts || { dedupe: false };

	  const streamLevels = Object.create(DEFAULT_LEVELS);
	  streamLevels.silent = Infinity;
	  if (opts.levels && typeof opts.levels === 'object') {
	    Object.keys(opts.levels).forEach(i => {
	      streamLevels[i] = opts.levels[i];
	    });
	  }

	  const res = {
	    write,
	    add,
	    emit,
	    flushSync,
	    end,
	    minLevel: 0,
	    streams: [],
	    clone,
	    [metadata]: true,
	    streamLevels
	  };

	  if (Array.isArray(streamsArray)) {
	    streamsArray.forEach(add, res);
	  } else {
	    add.call(res, streamsArray);
	  }

	  // clean this object up
	  // or it will stay allocated forever
	  // as it is closed on the following closures
	  streamsArray = null;

	  return res

	  // we can exit early because the streams are ordered by level
	  function write (data) {
	    let dest;
	    const level = this.lastLevel;
	    const { streams } = this;
	    // for handling situation when several streams has the same level
	    let recordedLevel = 0;
	    let stream;

	    // if dedupe set to true we send logs to the stream with the highest level
	    // therefore, we have to change sorting order
	    for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
	      dest = streams[i];
	      if (dest.level <= level) {
	        if (recordedLevel !== 0 && recordedLevel !== dest.level) {
	          break
	        }
	        stream = dest.stream;
	        if (stream[metadata]) {
	          const { lastTime, lastMsg, lastObj, lastLogger } = this;
	          stream.lastLevel = level;
	          stream.lastTime = lastTime;
	          stream.lastMsg = lastMsg;
	          stream.lastObj = lastObj;
	          stream.lastLogger = lastLogger;
	        }
	        stream.write(data);
	        if (opts.dedupe) {
	          recordedLevel = dest.level;
	        }
	      } else if (!opts.dedupe) {
	        break
	      }
	    }
	  }

	  function emit (...args) {
	    for (const { stream } of this.streams) {
	      if (typeof stream.emit === 'function') {
	        stream.emit(...args);
	      }
	    }
	  }

	  function flushSync () {
	    for (const { stream } of this.streams) {
	      if (typeof stream.flushSync === 'function') {
	        stream.flushSync();
	      }
	    }
	  }

	  function add (dest) {
	    if (!dest) {
	      return res
	    }

	    // Check that dest implements either StreamEntry or DestinationStream
	    const isStream = typeof dest.write === 'function' || dest.stream;
	    const stream_ = dest.write ? dest : dest.stream;
	    // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()
	    if (!isStream) {
	      throw Error('stream object needs to implement either StreamEntry or DestinationStream interface')
	    }

	    const { streams, streamLevels } = this;

	    let level;
	    if (typeof dest.levelVal === 'number') {
	      level = dest.levelVal;
	    } else if (typeof dest.level === 'string') {
	      level = streamLevels[dest.level];
	    } else if (typeof dest.level === 'number') {
	      level = dest.level;
	    } else {
	      level = DEFAULT_INFO_LEVEL;
	    }

	    const dest_ = {
	      stream: stream_,
	      level,
	      levelVal: undefined,
	      id: counter++
	    };

	    streams.unshift(dest_);
	    streams.sort(compareByLevel);

	    this.minLevel = streams[0].level;

	    return res
	  }

	  function end () {
	    for (const { stream } of this.streams) {
	      if (typeof stream.flushSync === 'function') {
	        stream.flushSync();
	      }
	      stream.end();
	    }
	  }

	  function clone (level) {
	    const streams = new Array(this.streams.length);

	    for (let i = 0; i < streams.length; i++) {
	      streams[i] = {
	        level,
	        stream: this.streams[i].stream
	      };
	    }

	    return {
	      write,
	      add,
	      minLevel: level,
	      streams,
	      clone,
	      emit,
	      flushSync,
	      [metadata]: true
	    }
	  }
	}

	function compareByLevel (a, b) {
	  return a.level - b.level
	}

	function initLoopVar (length, dedupe) {
	  return dedupe ? length - 1 : 0
	}

	function adjustLoopVar (i, dedupe) {
	  return dedupe ? i - 1 : i + 1
	}

	function checkLoopVar (i, length, dedupe) {
	  return dedupe ? i >= 0 : i < length
	}

	multistream_1 = multistream;
	return multistream_1;
}

var hasRequiredPino;

function requirePino () {
	if (hasRequiredPino) return pino.exports;
	hasRequiredPino = 1;

	const os = require$$0$6;
	const stdSerializers = requirePinoStdSerializers();
	const caller = requireCaller();
	const redaction = requireRedaction();
	const time = requireTime();
	const proto = requireProto();
	const symbols = requireSymbols$1();
	const { configure } = requireSafeStableStringify();
	const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
	const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants$4();
	const {
	  createArgsNormalizer,
	  asChindings,
	  buildSafeSonicBoom,
	  buildFormatters,
	  stringify,
	  normalizeDestFileDescriptor,
	  noop
	} = requireTools();
	const { version } = requireMeta();
	const {
	  chindingsSym,
	  redactFmtSym,
	  serializersSym,
	  timeSym,
	  timeSliceIndexSym,
	  streamSym,
	  stringifySym,
	  stringifySafeSym,
	  stringifiersSym,
	  setLevelSym,
	  endSym,
	  formatOptsSym,
	  messageKeySym,
	  errorKeySym,
	  nestedKeySym,
	  mixinSym,
	  levelCompSym,
	  useOnlyCustomLevelsSym,
	  formattersSym,
	  hooksSym,
	  nestedKeyStrSym,
	  mixinMergeStrategySym,
	  msgPrefixSym
	} = symbols;
	const { epochTime, nullTime } = time;
	const { pid } = process;
	const hostname = os.hostname();
	const defaultErrorSerializer = stdSerializers.err;
	const defaultOptions = {
	  level: 'info',
	  levelComparison: SORTING_ORDER.ASC,
	  levels: DEFAULT_LEVELS,
	  messageKey: 'msg',
	  errorKey: 'err',
	  nestedKey: null,
	  enabled: true,
	  base: { pid, hostname },
	  serializers: Object.assign(Object.create(null), {
	    err: defaultErrorSerializer
	  }),
	  formatters: Object.assign(Object.create(null), {
	    bindings (bindings) {
	      return bindings
	    },
	    level (label, number) {
	      return { level: number }
	    }
	  }),
	  hooks: {
	    logMethod: undefined,
	    streamWrite: undefined
	  },
	  timestamp: epochTime,
	  name: undefined,
	  redact: null,
	  customLevels: null,
	  useOnlyCustomLevels: false,
	  depthLimit: 5,
	  edgeLimit: 100
	};

	const normalize = createArgsNormalizer(defaultOptions);

	const serializers = Object.assign(Object.create(null), stdSerializers);

	function pino$1 (...args) {
	  const instance = {};
	  const { opts, stream } = normalize(instance, caller(), ...args);

	  if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase();

	  const {
	    redact,
	    crlf,
	    serializers,
	    timestamp,
	    messageKey,
	    errorKey,
	    nestedKey,
	    base,
	    name,
	    level,
	    customLevels,
	    levelComparison,
	    mixin,
	    mixinMergeStrategy,
	    useOnlyCustomLevels,
	    formatters,
	    hooks,
	    depthLimit,
	    edgeLimit,
	    onChild,
	    msgPrefix
	  } = opts;

	  const stringifySafe = configure({
	    maximumDepth: depthLimit,
	    maximumBreadth: edgeLimit
	  });

	  const allFormatters = buildFormatters(
	    formatters.level,
	    formatters.bindings,
	    formatters.log
	  );

	  const stringifyFn = stringify.bind({
	    [stringifySafeSym]: stringifySafe
	  });
	  const stringifiers = redact ? redaction(redact, stringifyFn) : {};
	  const formatOpts = redact
	    ? { stringify: stringifiers[redactFmtSym] }
	    : { stringify: stringifyFn };
	  const end = '}' + (crlf ? '\r\n' : '\n');
	  const coreChindings = asChindings.bind(null, {
	    [chindingsSym]: '',
	    [serializersSym]: serializers,
	    [stringifiersSym]: stringifiers,
	    [stringifySym]: stringify,
	    [stringifySafeSym]: stringifySafe,
	    [formattersSym]: allFormatters
	  });

	  let chindings = '';
	  if (base !== null) {
	    if (name === undefined) {
	      chindings = coreChindings(base);
	    } else {
	      chindings = coreChindings(Object.assign({}, base, { name }));
	    }
	  }

	  const time = (timestamp instanceof Function)
	    ? timestamp
	    : (timestamp ? epochTime : nullTime);
	  const timeSliceIndex = time().indexOf(':') + 1;

	  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')
	  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`)
	  if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`)

	  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
	  const levels = mappings(customLevels, useOnlyCustomLevels);

	  if (typeof stream.emit === 'function') {
	    stream.emit('message', { code: 'PINO_CONFIG', config: { levels, messageKey, errorKey } });
	  }

	  assertLevelComparison(levelComparison);
	  const levelCompFunc = genLevelComparison(levelComparison);

	  Object.assign(instance, {
	    levels,
	    [levelCompSym]: levelCompFunc,
	    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
	    [streamSym]: stream,
	    [timeSym]: time,
	    [timeSliceIndexSym]: timeSliceIndex,
	    [stringifySym]: stringify,
	    [stringifySafeSym]: stringifySafe,
	    [stringifiersSym]: stringifiers,
	    [endSym]: end,
	    [formatOptsSym]: formatOpts,
	    [messageKeySym]: messageKey,
	    [errorKeySym]: errorKey,
	    [nestedKeySym]: nestedKey,
	    // protect against injection
	    [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',
	    [serializersSym]: serializers,
	    [mixinSym]: mixin,
	    [mixinMergeStrategySym]: mixinMergeStrategy,
	    [chindingsSym]: chindings,
	    [formattersSym]: allFormatters,
	    [hooksSym]: hooks,
	    silent: noop,
	    onChild,
	    [msgPrefixSym]: msgPrefix
	  });

	  Object.setPrototypeOf(instance, proto());

	  genLsCache(instance);

	  instance[setLevelSym](level);

	  return instance
	}

	pino.exports = pino$1;

	pino.exports.destination = (dest = process.stdout.fd) => {
	  if (typeof dest === 'object') {
	    dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
	    return buildSafeSonicBoom(dest)
	  } else {
	    return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 })
	  }
	};

	pino.exports.transport = requireTransport();
	pino.exports.multistream = requireMultistream();

	pino.exports.levels = mappings();
	pino.exports.stdSerializers = serializers;
	pino.exports.stdTimeFunctions = Object.assign({}, time);
	pino.exports.symbols = symbols;
	pino.exports.version = version;

	// Enables default and name export with TypeScript and Babel
	pino.exports.default = pino$1;
	pino.exports.pino = pino$1;
	return pino.exports;
}

var loggerPino;
var hasRequiredLoggerPino;

function requireLoggerPino () {
	if (hasRequiredLoggerPino) return loggerPino;
	hasRequiredLoggerPino = 1;

	/**
	 * Code imported from `pino-http`
	 * Repo: https://github.com/pinojs/pino-http
	 * License: MIT (https://raw.githubusercontent.com/pinojs/pino-http/master/LICENSE)
	 */

	const pino = requirePino();
	const { serializersSym } = pino.symbols;
	const {
	  FST_ERR_LOG_INVALID_DESTINATION
	} = requireErrors$2();

	function createPinoLogger (opts) {
	  if (opts.stream && opts.file) {
	    throw new FST_ERR_LOG_INVALID_DESTINATION()
	  } else if (opts.file) {
	    // we do not have stream
	    opts.stream = pino.destination(opts.file);
	    delete opts.file;
	  }

	  const prevLogger = opts.logger;
	  const prevGenReqId = opts.genReqId;
	  let logger = null;

	  if (prevLogger) {
	    opts.logger = undefined;
	    opts.genReqId = undefined;
	    // we need to tap into pino internals because in v5 it supports
	    // adding serializers in child loggers
	    if (prevLogger[serializersSym]) {
	      opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
	    }
	    logger = prevLogger.child({}, opts);
	    opts.logger = prevLogger;
	    opts.genReqId = prevGenReqId;
	  } else {
	    logger = pino(opts, opts.stream);
	  }

	  return logger
	}

	const serializers = {
	  req: function asReqValue (req) {
	    return {
	      method: req.method,
	      url: req.url,
	      version: req.headers && req.headers['accept-version'],
	      host: req.host,
	      remoteAddress: req.ip,
	      remotePort: req.socket ? req.socket.remotePort : undefined
	    }
	  },
	  err: pino.stdSerializers.err,
	  res: function asResValue (reply) {
	    return {
	      statusCode: reply.statusCode
	    }
	  }
	};

	loggerPino = {
	  serializers,
	  createPinoLogger
	};
	return loggerPino;
}

var loggerFactory;
var hasRequiredLoggerFactory;

function requireLoggerFactory () {
	if (hasRequiredLoggerFactory) return loggerFactory;
	hasRequiredLoggerFactory = 1;

	const {
	  FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
	  FST_ERR_LOG_INVALID_LOGGER_CONFIG,
	  FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
	  FST_ERR_LOG_INVALID_LOGGER
	} = requireErrors$2();

	/**
	 * Utility for creating a child logger with the appropriate bindings, logger factory
	 * and validation.
	 * @param {object} context
	 * @param {import('../fastify').FastifyBaseLogger} logger
	 * @param {import('../fastify').RawRequestDefaultExpression<any>} req
	 * @param {string} reqId
	 * @param {import('../types/logger.js').ChildLoggerOptions?} loggerOpts
	 *
	 * @returns {object} New logger instance, inheriting all parent bindings,
	 * with child bindings added.
	 */
	function createChildLogger (context, logger, req, reqId, loggerOpts) {
	  const loggerBindings = {
	    [context.requestIdLogLabel]: reqId
	  };
	  const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);

	  // Optimization: bypass validation if the factory is our own default factory
	  if (context.childLoggerFactory !== defaultChildLoggerFactory) {
	    validateLogger(child, true); // throw if the child is not a valid logger
	  }

	  return child
	}

	/** Default factory to create child logger instance
	 *
	 * @param {import('../fastify.js').FastifyBaseLogger} logger
	 * @param {import('../types/logger.js').Bindings} bindings
	 * @param {import('../types/logger.js').ChildLoggerOptions} opts
	 *
	 * @returns {import('../types/logger.js').FastifyBaseLogger}
	 */
	function defaultChildLoggerFactory (logger, bindings, opts) {
	  return logger.child(bindings, opts)
	}

	/**
	 * Determines if a provided logger object meets the requirements
	 * of a Fastify compatible logger.
	 *
	 * @param {object} logger Object to validate.
	 * @param {boolean?} strict `true` if the object must be a logger (always throw if any methods missing)
	 *
	 * @returns {boolean} `true` when the logger meets the requirements.
	 *
	 * @throws {FST_ERR_LOG_INVALID_LOGGER} When the logger object is
	 * missing required methods.
	 */
	function validateLogger (logger, strict) {
	  const methods = ['info', 'error', 'debug', 'fatal', 'warn', 'trace', 'child'];
	  const missingMethods = logger
	    ? methods.filter(method => !logger[method] || typeof logger[method] !== 'function')
	    : methods;

	  if (!missingMethods.length) {
	    return true
	  } else if ((missingMethods.length === methods.length) && !strict) {
	    return false
	  } else {
	    throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(','))
	  }
	}

	function createLogger (options) {
	  if (options.logger && options.loggerInstance) {
	    throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED()
	  }

	  if (!options.loggerInstance && !options.logger) {
	    const nullLogger = requireAbstractLogging();
	    const logger = nullLogger;
	    logger.child = () => logger;
	    return { logger, hasLogger: false }
	  }

	  const { createPinoLogger, serializers } = requireLoggerPino();

	  // check if the logger instance has all required properties
	  if (validateLogger(options.loggerInstance)) {
	    const logger = createPinoLogger({
	      logger: options.loggerInstance,
	      serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
	    });
	    return { logger, hasLogger: true }
	  }

	  // if a logger instance is passed to logger, throw an exception
	  if (validateLogger(options.logger)) {
	    throw FST_ERR_LOG_INVALID_LOGGER_CONFIG()
	  }

	  if (options.loggerInstance) {
	    throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE()
	  }

	  const localLoggerOptions = {};
	  if (Object.prototype.toString.call(options.logger) === '[object Object]') {
	    Reflect.ownKeys(options.logger).forEach(prop => {
	      Object.defineProperty(localLoggerOptions, prop, {
	        value: options.logger[prop],
	        writable: true,
	        enumerable: true,
	        configurable: true
	      });
	    });
	  }
	  localLoggerOptions.level = localLoggerOptions.level || 'info';
	  localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
	  options.logger = localLoggerOptions;
	  const logger = createPinoLogger(options.logger);
	  return { logger, hasLogger: true }
	}

	function now () {
	  const ts = process.hrtime();
	  return (ts[0] * 1e3) + (ts[1] / 1e6)
	}

	loggerFactory = {
	  createChildLogger,
	  defaultChildLoggerFactory,
	  createLogger,
	  validateLogger,
	  now
	};
	return loggerFactory;
}

var rfdc_1;
var hasRequiredRfdc;

function requireRfdc () {
	if (hasRequiredRfdc) return rfdc_1;
	hasRequiredRfdc = 1;
	rfdc_1 = rfdc;

	function copyBuffer (cur) {
	  if (cur instanceof Buffer) {
	    return Buffer.from(cur)
	  }

	  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
	}

	function rfdc (opts) {
	  opts = opts || {};
	  if (opts.circles) return rfdcCircles(opts)

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;

	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        a2[k] = fn(cur);
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = clone(cur);
	      }
	    }
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = cloneProto(cur);
	      }
	    }
	    return o2
	  }
	}

	function rfdcCircles (opts) {
	  const refs = [];
	  const refsNew = [];

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;
	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        const index = refs.indexOf(cur);
	        if (index !== -1) {
	          a2[k] = refsNew[index];
	        } else {
	          a2[k] = fn(cur);
	        }
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = clone(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = cloneProto(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }
	}
	return rfdc_1;
}

var schemas$1;
var hasRequiredSchemas;

function requireSchemas () {
	if (hasRequiredSchemas) return schemas$1;
	hasRequiredSchemas = 1;

	const fastClone = requireRfdc()({ circles: false, proto: true });
	const { kSchemaVisited, kSchemaResponse } = requireSymbols$2();
	const kFluentSchema = Symbol.for('fluent-schema-object');

	const {
	  FST_ERR_SCH_MISSING_ID,
	  FST_ERR_SCH_ALREADY_PRESENT,
	  FST_ERR_SCH_DUPLICATE,
	  FST_ERR_SCH_CONTENT_MISSING_SCHEMA
	} = requireErrors$2();

	const SCHEMAS_SOURCE = ['params', 'body', 'querystring', 'query', 'headers'];

	function Schemas (initStore) {
	  this.store = initStore || {};
	}

	Schemas.prototype.add = function (inputSchema) {
	  const schema = fastClone((inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema])
	    ? inputSchema.valueOf()
	    : inputSchema
	  );

	  // developers can add schemas without $id, but with $def instead
	  const id = schema.$id;
	  if (!id) {
	    throw new FST_ERR_SCH_MISSING_ID()
	  }

	  if (this.store[id]) {
	    throw new FST_ERR_SCH_ALREADY_PRESENT(id)
	  }

	  this.store[id] = schema;
	};

	Schemas.prototype.getSchemas = function () {
	  return Object.assign({}, this.store)
	};

	Schemas.prototype.getSchema = function (schemaId) {
	  return this.store[schemaId]
	};

	/**
	 * Checks whether a schema is a non-plain object.
	 *
	 * @param {*} schema the schema to check
	 * @returns {boolean} true if schema has a custom prototype
	 */
	function isCustomSchemaPrototype (schema) {
	  return typeof schema === 'object' && Object.getPrototypeOf(schema) !== Object.prototype
	}

	function normalizeSchema (routeSchemas, serverOptions) {
	  if (routeSchemas[kSchemaVisited]) {
	    return routeSchemas
	  }

	  // alias query to querystring schema
	  if (routeSchemas.query) {
	    // check if our schema has both querystring and query
	    if (routeSchemas.querystring) {
	      throw new FST_ERR_SCH_DUPLICATE('querystring')
	    }
	    routeSchemas.querystring = routeSchemas.query;
	  }

	  generateFluentSchema(routeSchemas);

	  for (const key of SCHEMAS_SOURCE) {
	    const schema = routeSchemas[key];
	    if (schema && !isCustomSchemaPrototype(schema)) {
	      if (key === 'body' && schema.content) {
	        const contentProperty = schema.content;
	        const keys = Object.keys(contentProperty);
	        for (let i = 0; i < keys.length; i++) {
	          const contentType = keys[i];
	          const contentSchema = contentProperty[contentType].schema;
	          if (!contentSchema) {
	            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType)
	          }
	        }
	        continue
	      }
	    }
	  }

	  if (routeSchemas.response) {
	    const httpCodes = Object.keys(routeSchemas.response);
	    for (const code of httpCodes) {
	      if (isCustomSchemaPrototype(routeSchemas.response[code])) {
	        continue
	      }

	      const contentProperty = routeSchemas.response[code].content;

	      if (contentProperty) {
	        const keys = Object.keys(contentProperty);
	        for (let i = 0; i < keys.length; i++) {
	          const mediaName = keys[i];
	          if (!contentProperty[mediaName].schema) {
	            throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName)
	          }
	        }
	      }
	    }
	  }

	  routeSchemas[kSchemaVisited] = true;
	  return routeSchemas
	}

	function generateFluentSchema (schema) {
	  for (const key of SCHEMAS_SOURCE) {
	    if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
	      schema[key] = schema[key].valueOf();
	    }
	  }

	  if (schema.response) {
	    const httpCodes = Object.keys(schema.response);
	    for (const code of httpCodes) {
	      if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
	        schema.response[code] = schema.response[code].valueOf();
	      }
	    }
	  }
	}

	/**
	 * Search for the right JSON schema compiled function in the request context
	 * setup by the route configuration `schema.response`.
	 * It will look for the exact match (eg 200) or generic (eg 2xx)
	 *
	 * @param {object} context the request context
	 * @param {number} statusCode the http status code
	 * @param {string} [contentType] the reply content type
	 * @returns {function|false} the right JSON Schema function to serialize
	 * the reply or false if it is not set
	 */
	function getSchemaSerializer (context, statusCode, contentType) {
	  const responseSchemaDef = context[kSchemaResponse];
	  if (!responseSchemaDef) {
	    return false
	  }
	  if (responseSchemaDef[statusCode]) {
	    if (responseSchemaDef[statusCode].constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef[statusCode][mediaName]) {
	        return responseSchemaDef[statusCode][mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef[statusCode]['*/*']) {
	        return responseSchemaDef[statusCode]['*/*']
	      }

	      return false
	    }
	    return responseSchemaDef[statusCode]
	  }
	  const fallbackStatusCode = (statusCode + '')[0] + 'xx';
	  if (responseSchemaDef[fallbackStatusCode]) {
	    if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef[fallbackStatusCode][mediaName]) {
	        return responseSchemaDef[fallbackStatusCode][mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef[fallbackStatusCode]['*/*']) {
	        return responseSchemaDef[fallbackStatusCode]['*/*']
	      }

	      return false
	    }

	    return responseSchemaDef[fallbackStatusCode]
	  }
	  if (responseSchemaDef.default) {
	    if (responseSchemaDef.default.constructor === Object && contentType) {
	      const mediaName = contentType.split(';', 1)[0];
	      if (responseSchemaDef.default[mediaName]) {
	        return responseSchemaDef.default[mediaName]
	      }

	      // fallback to match all media-type
	      if (responseSchemaDef.default['*/*']) {
	        return responseSchemaDef.default['*/*']
	      }

	      return false
	    }

	    return responseSchemaDef.default
	  }
	  return false
	}

	schemas$1 = {
	  buildSchemas (initStore) { return new Schemas(initStore) },
	  getSchemaSerializer,
	  normalizeSchema
	};
	return schemas$1;
}

var serializer;
var hasRequiredSerializer;

function requireSerializer () {
	if (hasRequiredSerializer) return serializer;
	hasRequiredSerializer = 1;

	// eslint-disable-next-line
	const STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;

	serializer = class Serializer {
	  constructor (options) {
	    switch (options && options.rounding) {
	      case 'floor':
	        this.parseInteger = Math.floor;
	        break
	      case 'ceil':
	        this.parseInteger = Math.ceil;
	        break
	      case 'round':
	        this.parseInteger = Math.round;
	        break
	      case 'trunc':
	      default:
	        this.parseInteger = Math.trunc;
	        break
	    }
	    this._options = options;
	  }

	  asInteger (i) {
	    if (Number.isInteger(i)) {
	      return '' + i
	    } else if (typeof i === 'bigint') {
	      return i.toString()
	    }
	    /* eslint no-undef: "off" */
	    const integer = this.parseInteger(i);
	    // check if number is Infinity or NaN
	    // eslint-disable-next-line no-self-compare
	    if (integer === Infinity || integer === -Infinity || integer !== integer) {
	      throw new Error(`The value "${i}" cannot be converted to an integer.`)
	    }
	    return '' + integer
	  }

	  asNumber (i) {
	    // fast cast to number
	    const num = Number(i);
	    // check if number is NaN
	    // eslint-disable-next-line no-self-compare
	    if (num !== num) {
	      throw new Error(`The value "${i}" cannot be converted to a number.`)
	    } else if (num === Infinity || num === -Infinity) {
	      return 'null'
	    } else {
	      return '' + num
	    }
	  }

	  asBoolean (bool) {
	    return bool && 'true' || 'false' // eslint-disable-line
	  }

	  asDateTime (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + date.toISOString() + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a date-time.`)
	  }

	  asDate (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(0, 10) + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a date.`)
	  }

	  asTime (date) {
	    if (date === null) return '""'
	    if (date instanceof Date) {
	      return '"' + new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(11, 19) + '"'
	    }
	    if (typeof date === 'string') {
	      return '"' + date + '"'
	    }
	    throw new Error(`The value "${date}" cannot be converted to a time.`)
	  }

	  asString (str) {
	    const len = str.length;
	    if (len < 42) {
	      // magically escape strings for json
	      // relying on their charCodeAt
	      // everything below 32 needs JSON.stringify()
	      // every string that contain surrogate needs JSON.stringify()
	      // 34 and 92 happens all the time, so we
	      // have a fast case for them
	      let result = '';
	      let last = -1;
	      let point = 255;
	      for (let i = 0; i < len; i++) {
	        point = str.charCodeAt(i);
	        if (
	          point === 0x22 || // '"'
	          point === 0x5c // '\'
	        ) {
	          last === -1 && (last = 0);
	          result += str.slice(last, i) + '\\';
	          last = i;
	        } else if (point < 32 || (point >= 0xD800 && point <= 0xDFFF)) {
	          // The current character is non-printable characters or a surrogate.
	          return JSON.stringify(str)
	        }
	      }
	      return (last === -1 && ('"' + str + '"')) || ('"' + result + str.slice(last) + '"')
	    } else if (len < 5000 && STR_ESCAPE.test(str) === false) {
	      // Only use the regular expression for shorter input. The overhead is otherwise too much.
	      return '"' + str + '"'
	    } else {
	      return JSON.stringify(str)
	    }
	  }

	  asUnsafeString (str) {
	    return '"' + str + '"'
	  }

	  getState () {
	    return this._options
	  }

	  static restoreFromState (state) {
	    return new Serializer(state)
	  }
	};
	return serializer;
}

var errorSerializer;
var hasRequiredErrorSerializer;

function requireErrorSerializer () {
	if (hasRequiredErrorSerializer) return errorSerializer;
	hasRequiredErrorSerializer = 1;

	  const Serializer = requireSerializer();
	  const serializerState = {"mode":"standalone"};
	  const serializer = Serializer.restoreFromState(serializerState);

	  const validator = null;


	  errorSerializer = function anonymous(validator,serializer
	) {

	    const JSON_STR_BEGIN_OBJECT = '{';
	    const JSON_STR_END_OBJECT = '}';
	    const JSON_STR_COMMA = ',';
	    const JSON_STR_QUOTE = '"';
	    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
	    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
	  
	    
	  
	    // #
	    function anonymous0 (input) {
	      const obj = (input && typeof input.toJSON === 'function')
	    ? input.toJSON()
	    : input;
	  
	      if (obj === null) return JSON_STR_EMPTY_OBJECT

	      let value;
	let json = JSON_STR_BEGIN_OBJECT;
	let addComma = false;

	      value = obj["statusCode"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"statusCode\":";
	        json += serializer.asNumber(value);
	      }

	      value = obj["code"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"code\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	      value = obj["error"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"error\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	      value = obj["message"];
	      if (value !== undefined) {
	        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
	        json += "\"message\":";
	        
	        if (typeof value !== 'string') {
	          if (value === null) {
	            json += JSON_STR_EMPTY_STRING;
	          } else if (value instanceof Date) {
	            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
	          } else if (value instanceof RegExp) {
	            json += serializer.asString(value.source);
	          } else {
	            json += serializer.asString(value.toString());
	          }
	        } else {
	          json += serializer.asString(value);
	        }
	        
	      }

	    return json + JSON_STR_END_OBJECT
	  
	    }
	  
	    const main = anonymous0;
	    return main
	    
	}(validator, serializer);
	/* c8 ignore stop */
	return errorSerializer;
}

var errorHandler;
var hasRequiredErrorHandler;

function requireErrorHandler () {
	if (hasRequiredErrorHandler) return errorHandler;
	hasRequiredErrorHandler = 1;

	const statusCodes = require$$0$5.STATUS_CODES;
	const wrapThenable = requireWrapThenable();
	const {
	  kReplyHeaders,
	  kReplyNextErrorHandler,
	  kReplyIsRunningOnErrorHook,
	  kReplyHasStatusCode,
	  kRouteContext,
	  kDisableRequestLogging
	} = requireSymbols$2();

	const {
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE,
	  FST_ERR_FAILED_ERROR_SERIALIZATION
	} = requireErrors$2();

	const { getSchemaSerializer } = requireSchemas();

	const serializeError = requireErrorSerializer();

	const rootErrorHandler = {
	  func: defaultErrorHandler,
	  toJSON () {
	    return this.func.name.toString() + '()'
	  }
	};

	function handleError (reply, error, cb) {
	  reply[kReplyIsRunningOnErrorHook] = false;

	  const context = reply[kRouteContext];
	  if (reply[kReplyNextErrorHandler] === false) {
	    fallbackErrorHandler(error, reply, function (reply, payload) {
	      try {
	        reply.raw.writeHead(reply.raw.statusCode, reply[kReplyHeaders]);
	      } catch (error) {
	        if (!reply.log[kDisableRequestLogging]) {
	          reply.log.warn(
	            { req: reply.request, res: reply, err: error },
	            error && error.message
	          );
	        }
	        reply.raw.writeHead(reply.raw.statusCode);
	      }
	      reply.raw.end(payload);
	    });
	    return
	  }
	  const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;

	  // In case the error handler throws, we set the next errorHandler so we can error again
	  reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);

	  // we need to remove content-type to allow content-type guessing for serialization
	  delete reply[kReplyHeaders]['content-type'];
	  delete reply[kReplyHeaders]['content-length'];

	  const func = errorHandler.func;

	  if (!func) {
	    reply[kReplyNextErrorHandler] = false;
	    fallbackErrorHandler(error, reply, cb);
	    return
	  }

	  try {
	    const result = func(error, reply.request, reply);
	    if (result !== undefined) {
	      if (result !== null && typeof result.then === 'function') {
	        wrapThenable(result, reply);
	      } else {
	        reply.send(result);
	      }
	    }
	  } catch (err) {
	    reply.send(err);
	  }
	}

	function defaultErrorHandler (error, request, reply) {
	  setErrorHeaders(error, reply);
	  if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
	    const statusCode = error.statusCode || error.status;
	    reply.code(statusCode >= 400 ? statusCode : 500);
	  }
	  if (reply.statusCode < 500) {
	    if (!reply.log[kDisableRequestLogging]) {
	      reply.log.info(
	        { res: reply, err: error },
	        error && error.message
	      );
	    }
	  } else {
	    if (!reply.log[kDisableRequestLogging]) {
	      reply.log.error(
	        { req: request, res: reply, err: error },
	        error && error.message
	      );
	    }
	  }
	  reply.send(error);
	}

	function fallbackErrorHandler (error, reply, cb) {
	  const res = reply.raw;
	  const statusCode = reply.statusCode;
	  reply[kReplyHeaders]['content-type'] = reply[kReplyHeaders]['content-type'] ?? 'application/json; charset=utf-8';
	  let payload;
	  try {
	    const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]['content-type']);
	    if (serializerFn === false) {
	      payload = serializeError({
	        error: statusCodes[statusCode + ''],
	        code: error.code,
	        message: error.message,
	        statusCode
	      });
	    } else {
	      payload = serializerFn(Object.create(error, {
	        error: { value: statusCodes[statusCode + ''] },
	        message: { value: error.message },
	        statusCode: { value: statusCode }
	      }));
	    }
	  } catch (err) {
	    if (!reply.log[kDisableRequestLogging]) {
	      // error is always FST_ERR_SCH_SERIALIZATION_BUILD because this is called from route/compileSchemasForSerialization
	      reply.log.error({ err, statusCode: res.statusCode }, 'The serializer for the given status code failed');
	    }
	    reply.code(500);
	    payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
	  }

	  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
	    payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
	  }

	  reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);

	  cb(reply, payload);
	}

	function buildErrorHandler (parent = rootErrorHandler, func) {
	  if (!func) {
	    return parent
	  }

	  const errorHandler = Object.create(parent);
	  errorHandler.func = func;
	  return errorHandler
	}

	function setErrorHeaders (error, reply) {
	  const res = reply.raw;
	  let statusCode = res.statusCode;
	  statusCode = (statusCode >= 400) ? statusCode : 500;
	  // treat undefined and null as same
	  if (error != null) {
	    if (error.headers !== undefined) {
	      reply.headers(error.headers);
	    }
	    if (error.status >= 400) {
	      statusCode = error.status;
	    } else if (error.statusCode >= 400) {
	      statusCode = error.statusCode;
	    }
	  }
	  res.statusCode = statusCode;
	}

	errorHandler = {
	  buildErrorHandler,
	  handleError
	};
	return errorHandler;
}

var decorate_1;
var hasRequiredDecorate;

function requireDecorate () {
	if (hasRequiredDecorate) return decorate_1;
	hasRequiredDecorate = 1;

	const {
	  kReply,
	  kRequest,
	  kState,
	  kHasBeenDecorated
	} = requireSymbols$2();

	const {
	  FST_ERR_DEC_ALREADY_PRESENT,
	  FST_ERR_DEC_MISSING_DEPENDENCY,
	  FST_ERR_DEC_AFTER_START,
	  FST_ERR_DEC_REFERENCE_TYPE,
	  FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
	  FST_ERR_DEC_UNDECLARED
	} = requireErrors$2();

	function decorate (instance, name, fn, dependencies) {
	  if (Object.hasOwn(instance, name)) {
	    throw new FST_ERR_DEC_ALREADY_PRESENT(name)
	  }

	  checkDependencies(instance, name, dependencies);

	  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    Object.defineProperty(instance, name, {
	      get: fn.getter,
	      set: fn.setter
	    });
	  } else {
	    instance[name] = fn;
	  }
	}

	function getInstanceDecorator (name) {
	  if (!checkExistence(this, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'instance')
	  }

	  if (typeof this[name] === 'function') {
	    return this[name].bind(this)
	  }

	  return this[name]
	}

	function decorateConstructor (konstructor, name, fn, dependencies) {
	  const instance = konstructor.prototype;
	  if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
	    throw new FST_ERR_DEC_ALREADY_PRESENT(name)
	  }

	  konstructor[kHasBeenDecorated] = true;
	  checkDependencies(konstructor, name, dependencies);

	  if (fn && (typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    Object.defineProperty(instance, name, {
	      get: fn.getter,
	      set: fn.setter
	    });
	  } else if (typeof fn === 'function') {
	    instance[name] = fn;
	  } else {
	    konstructor.props.push({ key: name, value: fn });
	  }
	}

	function checkReferenceType (name, fn) {
	  if (typeof fn === 'object' && fn && !(typeof fn.getter === 'function' || typeof fn.setter === 'function')) {
	    throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn)
	  }
	}

	function decorateFastify (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  decorate(this, name, fn, dependencies);
	  return this
	}

	function checkExistence (instance, name) {
	  if (name) {
	    return name in instance || (instance.prototype && name in instance.prototype) || hasKey(instance, name)
	  }

	  return instance in this
	}

	function hasKey (fn, name) {
	  if (fn.props) {
	    return fn.props.find(({ key }) => key === name)
	  }
	  return false
	}

	function checkRequestExistence (name) {
	  if (name && hasKey(this[kRequest], name)) return true
	  return checkExistence(this[kRequest].prototype, name)
	}

	function checkReplyExistence (name) {
	  if (name && hasKey(this[kReply], name)) return true
	  return checkExistence(this[kReply].prototype, name)
	}

	function checkDependencies (instance, name, deps) {
	  if (deps === undefined || deps === null) {
	    return
	  }

	  if (!Array.isArray(deps)) {
	    throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name)
	  }

	  for (let i = 0; i !== deps.length; ++i) {
	    if (!checkExistence(instance, deps[i])) {
	      throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i])
	    }
	  }
	}

	function decorateReply (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  checkReferenceType(name, fn);
	  decorateConstructor(this[kReply], name, fn, dependencies);
	  return this
	}

	function decorateRequest (name, fn, dependencies) {
	  assertNotStarted(this, name);
	  checkReferenceType(name, fn);
	  decorateConstructor(this[kRequest], name, fn, dependencies);
	  return this
	}

	function assertNotStarted (instance, name) {
	  if (instance[kState].started) {
	    throw new FST_ERR_DEC_AFTER_START(name)
	  }
	}

	decorate_1 = {
	  add: decorateFastify,
	  exist: checkExistence,
	  existRequest: checkRequestExistence,
	  existReply: checkReplyExistence,
	  dependencies: checkDependencies,
	  decorateReply,
	  decorateRequest,
	  getInstanceDecorator,
	  hasKey
	};
	return decorate_1;
}

var hasRequiredReply;

function requireReply () {
	if (hasRequiredReply) return reply.exports;
	hasRequiredReply = 1;

	const eos = require$$1$5.finished;
	const Readable = require$$1$5.Readable;

	const {
	  kFourOhFourContext,
	  kReplyErrorHandlerCalled,
	  kReplyHijacked,
	  kReplyStartTime,
	  kReplyEndTime,
	  kReplySerializer,
	  kReplySerializerDefault,
	  kReplyIsError,
	  kReplyHeaders,
	  kReplyTrailers,
	  kReplyHasStatusCode,
	  kReplyIsRunningOnErrorHook,
	  kReplyNextErrorHandler,
	  kDisableRequestLogging,
	  kSchemaResponse,
	  kReplyCacheSerializeFns,
	  kSchemaController,
	  kOptions,
	  kRouteContext
	} = requireSymbols$2();
	const {
	  onSendHookRunner,
	  onResponseHookRunner,
	  preHandlerHookRunner,
	  preSerializationHookRunner
	} = requireHooks();

	const internals = requireHandleRequest()[Symbol.for('internals')];
	const loggerUtils = requireLoggerFactory();
	const now = loggerUtils.now;
	const { handleError } = requireErrorHandler();
	const { getSchemaSerializer } = requireSchemas();

	const CONTENT_TYPE = {
	  JSON: 'application/json; charset=utf-8',
	  PLAIN: 'text/plain; charset=utf-8',
	  OCTET: 'application/octet-stream'
	};
	const {
	  FST_ERR_REP_INVALID_PAYLOAD_TYPE,
	  FST_ERR_REP_RESPONSE_BODY_CONSUMED,
	  FST_ERR_REP_READABLE_STREAM_LOCKED,
	  FST_ERR_REP_ALREADY_SENT,
	  FST_ERR_SEND_INSIDE_ONERR,
	  FST_ERR_BAD_STATUS_CODE,
	  FST_ERR_BAD_TRAILER_NAME,
	  FST_ERR_BAD_TRAILER_VALUE,
	  FST_ERR_MISSING_SERIALIZATION_FN,
	  FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
	  FST_ERR_DEC_UNDECLARED
	} = requireErrors$2();
	const decorators = requireDecorate();

	const toString = Object.prototype.toString;

	function Reply (res, request, log) {
	  this.raw = res;
	  this[kReplySerializer] = null;
	  this[kReplyErrorHandlerCalled] = false;
	  this[kReplyIsError] = false;
	  this[kReplyIsRunningOnErrorHook] = false;
	  this.request = request;
	  this[kReplyHeaders] = {};
	  this[kReplyTrailers] = null;
	  this[kReplyHasStatusCode] = false;
	  this[kReplyStartTime] = undefined;
	  this.log = log;
	}
	Reply.props = [];

	Object.defineProperties(Reply.prototype, {
	  [kRouteContext]: {
	    get () {
	      return this.request[kRouteContext]
	    }
	  },
	  elapsedTime: {
	    get () {
	      if (this[kReplyStartTime] === undefined) {
	        return 0
	      }
	      return (this[kReplyEndTime] || now()) - this[kReplyStartTime]
	    }
	  },
	  server: {
	    get () {
	      return this.request[kRouteContext].server
	    }
	  },
	  sent: {
	    enumerable: true,
	    get () {
	      // We are checking whether reply was hijacked or the response has ended.
	      return (this[kReplyHijacked] || this.raw.writableEnded) === true
	    }
	  },
	  statusCode: {
	    get () {
	      return this.raw.statusCode
	    },
	    set (value) {
	      this.code(value);
	    }
	  },
	  routeOptions: {
	    get () {
	      return this.request.routeOptions
	    }
	  }
	});

	Reply.prototype.writeEarlyHints = function (hints, callback) {
	  this.raw.writeEarlyHints(hints, callback);
	  return this
	};

	Reply.prototype.hijack = function () {
	  this[kReplyHijacked] = true;
	  return this
	};

	Reply.prototype.send = function (payload) {
	  if (this[kReplyIsRunningOnErrorHook] === true) {
	    throw new FST_ERR_SEND_INSIDE_ONERR()
	  }

	  if (this.sent) {
	    this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
	    return this
	  }

	  if (payload instanceof Error || this[kReplyIsError] === true) {
	    this[kReplyIsError] = false;
	    onErrorHook(this, payload, onSendHook);
	    return this
	  }

	  if (payload === undefined) {
	    onSendHook(this, payload);
	    return this
	  }

	  const contentType = this.getHeader('content-type');
	  const hasContentType = contentType !== undefined;

	  if (payload !== null) {
	    if (
	      // node:stream
	      typeof payload.pipe === 'function' ||
	      // node:stream/web
	      typeof payload.getReader === 'function' ||
	      // Response
	      toString.call(payload) === '[object Response]'
	    ) {
	      onSendHook(this, payload);
	      return this
	    }

	    if (payload?.buffer instanceof ArrayBuffer) {
	      if (hasContentType === false) {
	        this[kReplyHeaders]['content-type'] = CONTENT_TYPE.OCTET;
	      }
	      const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
	      onSendHook(this, payloadToSend);
	      return this
	    }

	    if (hasContentType === false && typeof payload === 'string') {
	      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.PLAIN;
	      onSendHook(this, payload);
	      return this
	    }
	  }

	  if (this[kReplySerializer] !== null) {
	    if (typeof payload !== 'string') {
	      preSerializationHook(this, payload);
	      return this
	    } else {
	      payload = this[kReplySerializer](payload);
	    }

	    // The indexOf below also matches custom json mimetypes such as 'application/hal+json' or 'application/ld+json'
	  } else if (hasContentType === false || contentType.indexOf('json') > -1) {
	    if (hasContentType === false) {
	      this[kReplyHeaders]['content-type'] = CONTENT_TYPE.JSON;
	    } else {
	      // If user doesn't set charset, we will set charset to utf-8
	      if (contentType.indexOf('charset') === -1) {
	        const customContentType = contentType.trim();
	        if (customContentType.endsWith(';')) {
	          // custom content-type is ended with ';'
	          this[kReplyHeaders]['content-type'] = `${customContentType} charset=utf-8`;
	        } else {
	          this[kReplyHeaders]['content-type'] = `${customContentType}; charset=utf-8`;
	        }
	      }
	    }
	    if (typeof payload !== 'string') {
	      preSerializationHook(this, payload);
	      return this
	    }
	  }

	  onSendHook(this, payload);

	  return this
	};

	Reply.prototype.getHeader = function (key) {
	  key = key.toLowerCase();
	  const value = this[kReplyHeaders][key];
	  return value !== undefined ? value : this.raw.getHeader(key)
	};

	Reply.prototype.getHeaders = function () {
	  return {
	    ...this.raw.getHeaders(),
	    ...this[kReplyHeaders]
	  }
	};

	Reply.prototype.hasHeader = function (key) {
	  key = key.toLowerCase();

	  return this[kReplyHeaders][key] !== undefined || this.raw.hasHeader(key)
	};

	Reply.prototype.removeHeader = function (key) {
	  // Node.js does not like headers with keys set to undefined,
	  // so we have to delete the key.
	  delete this[kReplyHeaders][key.toLowerCase()];
	  return this
	};

	Reply.prototype.header = function (key, value = '') {
	  key = key.toLowerCase();

	  if (this[kReplyHeaders][key] && key === 'set-cookie') {
	    // https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.2
	    if (typeof this[kReplyHeaders][key] === 'string') {
	      this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
	    }

	    if (Array.isArray(value)) {
	      Array.prototype.push.apply(this[kReplyHeaders][key], value);
	    } else {
	      this[kReplyHeaders][key].push(value);
	    }
	  } else {
	    this[kReplyHeaders][key] = value;
	  }

	  return this
	};

	Reply.prototype.headers = function (headers) {
	  const keys = Object.keys(headers);
	  for (let i = 0; i !== keys.length; ++i) {
	    const key = keys[i];
	    this.header(key, headers[key]);
	  }

	  return this
	};

	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer#directives
	// https://datatracker.ietf.org/doc/html/rfc7230.html#chunked.trailer.part
	const INVALID_TRAILERS = new Set([
	  'transfer-encoding',
	  'content-length',
	  'host',
	  'cache-control',
	  'max-forwards',
	  'te',
	  'authorization',
	  'set-cookie',
	  'content-encoding',
	  'content-type',
	  'content-range',
	  'trailer'
	]);

	Reply.prototype.trailer = function (key, fn) {
	  key = key.toLowerCase();
	  if (INVALID_TRAILERS.has(key)) {
	    throw new FST_ERR_BAD_TRAILER_NAME(key)
	  }
	  if (typeof fn !== 'function') {
	    throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn)
	  }
	  if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
	  this[kReplyTrailers][key] = fn;
	  return this
	};

	Reply.prototype.hasTrailer = function (key) {
	  return this[kReplyTrailers]?.[key.toLowerCase()] !== undefined
	};

	Reply.prototype.removeTrailer = function (key) {
	  if (this[kReplyTrailers] === null) return this
	  this[kReplyTrailers][key.toLowerCase()] = undefined;
	  return this
	};

	Reply.prototype.code = function (code) {
	  const statusCode = +code;
	  if (!(statusCode >= 100 && statusCode <= 599)) {
	    throw new FST_ERR_BAD_STATUS_CODE(code || String(code))
	  }

	  this.raw.statusCode = statusCode;
	  this[kReplyHasStatusCode] = true;
	  return this
	};

	Reply.prototype.status = Reply.prototype.code;

	Reply.prototype.getSerializationFunction = function (schemaOrStatus, contentType) {
	  let serialize;

	  if (typeof schemaOrStatus === 'string' || typeof schemaOrStatus === 'number') {
	    if (typeof contentType === 'string') {
	      serialize = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
	    } else {
	      serialize = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
	    }
	  } else if (typeof schemaOrStatus === 'object') {
	    serialize = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
	  }

	  return serialize
	};

	Reply.prototype.compileSerializationSchema = function (schema, httpStatus = null, contentType = null) {
	  const { request } = this;
	  const { method, url } = request;

	  // Check if serialize function already compiled
	  if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
	    return this[kRouteContext][kReplyCacheSerializeFns].get(schema)
	  }

	  const serializerCompiler = this[kRouteContext].serializerCompiler ||
	    this.server[kSchemaController].serializerCompiler ||
	    (
	      // We compile the schemas if no custom serializerCompiler is provided
	      // nor set
	      this.server[kSchemaController].setupSerializer(this.server[kOptions]) ||
	      this.server[kSchemaController].serializerCompiler
	    );

	  const serializeFn = serializerCompiler({
	    schema,
	    method,
	    url,
	    httpStatus,
	    contentType
	  });

	  // We create a WeakMap to compile the schema only once
	  // Its done lazily to avoid add overhead by creating the WeakMap
	  // if it is not used
	  // TODO: Explore a central cache for all the schemas shared across
	  // encapsulated contexts
	  if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
	    this[kRouteContext][kReplyCacheSerializeFns] = new WeakMap();
	  }

	  this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);

	  return serializeFn
	};

	Reply.prototype.serializeInput = function (input, schema, httpStatus, contentType) {
	  const possibleContentType = httpStatus;
	  let serialize;
	  httpStatus = typeof schema === 'string' || typeof schema === 'number'
	    ? schema
	    : httpStatus;

	  contentType = httpStatus && possibleContentType !== httpStatus
	    ? possibleContentType
	    : contentType;

	  if (httpStatus != null) {
	    if (contentType != null) {
	      serialize = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
	    } else {
	      serialize = this[kRouteContext][kSchemaResponse]?.[httpStatus];
	    }

	    if (serialize == null) {
	      if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType)
	      throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus)
	    }
	  } else {
	    // Check if serialize function already compiled
	    if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
	      serialize = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
	    } else {
	      serialize = this.compileSerializationSchema(schema, httpStatus, contentType);
	    }
	  }

	  return serialize(input)
	};

	Reply.prototype.serialize = function (payload) {
	  if (this[kReplySerializer] !== null) {
	    return this[kReplySerializer](payload)
	  } else {
	    if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
	      return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode)
	    } else {
	      return serialize(this[kRouteContext], payload, this.raw.statusCode)
	    }
	  }
	};

	Reply.prototype.serializer = function (fn) {
	  this[kReplySerializer] = fn;
	  return this
	};

	Reply.prototype.type = function (type) {
	  this[kReplyHeaders]['content-type'] = type;
	  return this
	};

	Reply.prototype.redirect = function (url, code) {
	  if (!code) {
	    code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
	  }

	  return this.header('location', url).code(code).send()
	};

	Reply.prototype.callNotFound = function () {
	  notFound(this);
	  return this
	};

	// Make reply a thenable, so it could be used with async/await.
	// See
	// - https://github.com/fastify/fastify/issues/1864 for the discussions
	// - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature
	Reply.prototype.then = function (fulfilled, rejected) {
	  if (this.sent) {
	    fulfilled();
	    return
	  }

	  eos(this.raw, (err) => {
	    // We must not treat ERR_STREAM_PREMATURE_CLOSE as
	    // an error because it is created by eos, not by the stream.
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      if (rejected) {
	        rejected(err);
	      } else {
	        this.log && this.log.warn('unhandled rejection on reply.then');
	      }
	    } else {
	      fulfilled();
	    }
	  });
	};

	Reply.prototype.getDecorator = function (name) {
	  if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'reply')
	  }

	  const decorator = this[name];
	  if (typeof decorator === 'function') {
	    return decorator.bind(this)
	  }

	  return decorator
	};

	function preSerializationHook (reply, payload) {
	  if (reply[kRouteContext].preSerialization !== null) {
	    preSerializationHookRunner(
	      reply[kRouteContext].preSerialization,
	      reply.request,
	      reply,
	      payload,
	      preSerializationHookEnd
	    );
	  } else {
	    preSerializationHookEnd(null, undefined, reply, payload);
	  }
	}

	function preSerializationHookEnd (err, _request, reply, payload) {
	  if (err != null) {
	    onErrorHook(reply, err);
	    return
	  }

	  try {
	    if (reply[kReplySerializer] !== null) {
	      payload = reply[kReplySerializer](payload);
	    } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
	      payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
	    } else {
	      payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]['content-type']);
	    }
	  } catch (e) {
	    wrapSerializationError(e, reply);
	    onErrorHook(reply, e);
	    return
	  }

	  onSendHook(reply, payload);
	}

	function wrapSerializationError (error, reply) {
	  error.serialization = reply[kRouteContext].config;
	}

	function onSendHook (reply, payload) {
	  if (reply[kRouteContext].onSend !== null) {
	    onSendHookRunner(
	      reply[kRouteContext].onSend,
	      reply.request,
	      reply,
	      payload,
	      wrapOnSendEnd
	    );
	  } else {
	    onSendEnd(reply, payload);
	  }
	}

	function wrapOnSendEnd (err, request, reply, payload) {
	  if (err != null) {
	    onErrorHook(reply, err);
	  } else {
	    onSendEnd(reply, payload);
	  }
	}

	function safeWriteHead (reply, statusCode) {
	  const res = reply.raw;
	  try {
	    res.writeHead(statusCode, reply[kReplyHeaders]);
	  } catch (err) {
	    if (err.code === 'ERR_HTTP_HEADERS_SENT') {
	      reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
	    }
	    throw err
	  }
	}

	function onSendEnd (reply, payload) {
	  const res = reply.raw;
	  const req = reply.request;

	  // we check if we need to update the trailers header and set it
	  if (reply[kReplyTrailers] !== null) {
	    const trailerHeaders = Object.keys(reply[kReplyTrailers]);
	    let header = '';
	    for (const trailerName of trailerHeaders) {
	      if (typeof reply[kReplyTrailers][trailerName] !== 'function') continue
	      header += ' ';
	      header += trailerName;
	    }
	    // it must be chunked for trailer to work
	    reply.header('Transfer-Encoding', 'chunked');
	    reply.header('Trailer', header.trim());
	  }

	  // since Response contain status code, headers and body,
	  // we need to update the status, add the headers and use it's body as payload
	  // before continuing
	  if (toString.call(payload) === '[object Response]') {
	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/status
	    if (typeof payload.status === 'number') {
	      reply.code(payload.status);
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/headers
	    if (typeof payload.headers === 'object' && typeof payload.headers.forEach === 'function') {
	      for (const [headerName, headerValue] of payload.headers) {
	        reply.header(headerName, headerValue);
	      }
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Response/body
	    if (payload.body !== null) {
	      if (payload.bodyUsed) {
	        throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED()
	      }
	    }
	    // Keep going, body is either null or ReadableStream
	    payload = payload.body;
	  }
	  const statusCode = res.statusCode;

	  if (payload === undefined || payload === null) {
	    // according to https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2
	    // we cannot send a content-length for 304 and 204, and all status code
	    // < 200
	    // A sender MUST NOT send a Content-Length header field in any message
	    // that contains a Transfer-Encoding header field.
	    // For HEAD we don't overwrite the `content-length`
	    if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== 'HEAD' && reply[kReplyTrailers] === null) {
	      reply[kReplyHeaders]['content-length'] = '0';
	    }

	    safeWriteHead(reply, statusCode);
	    sendTrailer(payload, res, reply);
	    return
	  }

	  if ((statusCode >= 100 && statusCode < 200) || statusCode === 204) {
	    // Responses without a content body must not send content-type
	    // or content-length headers.
	    // See https://www.rfc-editor.org/rfc/rfc9110.html#section-8.6.
	    reply.removeHeader('content-type');
	    reply.removeHeader('content-length');
	    safeWriteHead(reply, statusCode);
	    sendTrailer(undefined, res, reply);
	    if (typeof payload.resume === 'function') {
	      payload.on('error', noop);
	      payload.resume();
	    }
	    return
	  }

	  // node:stream
	  if (typeof payload.pipe === 'function') {
	    sendStream(payload, res, reply);
	    return
	  }

	  // node:stream/web
	  if (typeof payload.getReader === 'function') {
	    sendWebStream(payload, res, reply);
	    return
	  }

	  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
	    throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload)
	  }

	  if (reply[kReplyTrailers] === null) {
	    const contentLength = reply[kReplyHeaders]['content-length'];
	    if (!contentLength ||
	      (req.raw.method !== 'HEAD' &&
	        Number(contentLength) !== Buffer.byteLength(payload)
	      )
	    ) {
	      reply[kReplyHeaders]['content-length'] = '' + Buffer.byteLength(payload);
	    }
	  }

	  safeWriteHead(reply, statusCode);
	  // write payload first
	  res.write(payload);
	  // then send trailers
	  sendTrailer(payload, res, reply);
	}

	function logStreamError (logger, err, res) {
	  if (err.code === 'ERR_STREAM_PREMATURE_CLOSE') {
	    if (!logger[kDisableRequestLogging]) {
	      logger.info({ res }, 'stream closed prematurely');
	    }
	  } else {
	    logger.warn({ err }, 'response terminated with an error with headers already sent');
	  }
	}

	function sendWebStream (payload, res, reply) {
	  if (payload.locked) {
	    throw FST_ERR_REP_READABLE_STREAM_LOCKED()
	  }
	  const nodeStream = Readable.fromWeb(payload);
	  sendStream(nodeStream, res, reply);
	}

	function sendStream (payload, res, reply) {
	  let sourceOpen = true;
	  let errorLogged = false;

	  // set trailer when stream ended
	  sendStreamTrailer(payload, res, reply);

	  eos(payload, { readable: true, writable: false }, function (err) {
	    sourceOpen = false;
	    if (err != null) {
	      if (res.headersSent || reply.request.raw.aborted === true) {
	        if (!errorLogged) {
	          errorLogged = true;
	          logStreamError(reply.log, err, reply);
	        }
	        res.destroy();
	      } else {
	        onErrorHook(reply, err);
	      }
	    }
	    // there is nothing to do if there is not an error
	  });

	  eos(res, function (err) {
	    if (sourceOpen) {
	      if (err != null && res.headersSent && !errorLogged) {
	        errorLogged = true;
	        logStreamError(reply.log, err, res);
	      }
	      if (typeof payload.destroy === 'function') {
	        payload.destroy();
	      } else if (typeof payload.close === 'function') {
	        payload.close(noop);
	      } else if (typeof payload.abort === 'function') {
	        payload.abort();
	      } else {
	        reply.log.warn('stream payload does not end properly');
	      }
	    }
	  });

	  // streams will error asynchronously, and we want to handle that error
	  // appropriately, e.g. a 404 for a missing file. So we cannot use
	  // writeHead, and we need to resort to setHeader, which will trigger
	  // a writeHead when there is data to send.
	  if (!res.headersSent) {
	    for (const key in reply[kReplyHeaders]) {
	      res.setHeader(key, reply[kReplyHeaders][key]);
	    }
	  } else {
	    reply.log.warn('response will send, but you shouldn\'t use res.writeHead in stream mode');
	  }
	  payload.pipe(res);
	}

	function sendTrailer (payload, res, reply) {
	  if (reply[kReplyTrailers] === null) {
	    // when no trailer, we close the stream
	    res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	    return
	  }
	  const trailerHeaders = Object.keys(reply[kReplyTrailers]);
	  const trailers = {};
	  let handled = 0;
	  let skipped = true;
	  function send () {
	    // add trailers when all handler handled
	    /* istanbul ignore else */
	    if (handled === 0) {
	      res.addTrailers(trailers);
	      // we need to properly close the stream
	      // after trailers sent
	      res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	    }
	  }

	  for (const trailerName of trailerHeaders) {
	    if (typeof reply[kReplyTrailers][trailerName] !== 'function') continue
	    skipped = false;
	    handled--;

	    function cb (err, value) {
	      // TODO: we may protect multiple callback calls
	      //       or mixing async-await with callback
	      handled++;

	      // we can safely ignore error for trailer
	      // since it does affect the client
	      // we log in here only for debug usage
	      if (err) reply.log.debug(err);
	      else trailers[trailerName] = value;

	      // we push the check to the end of event
	      // loop, so the registration continue to
	      // process.
	      process.nextTick(send);
	    }

	    const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
	    if (typeof result === 'object' && typeof result.then === 'function') {
	      result.then((v) => cb(null, v), cb);
	    }
	  }

	  // when all trailers are skipped
	  // we need to close the stream
	  if (skipped) res.end(null, null, null); // avoid ArgumentsAdaptorTrampoline from V8
	}

	function sendStreamTrailer (payload, res, reply) {
	  if (reply[kReplyTrailers] === null) return
	  payload.on('end', () => sendTrailer(null, res, reply));
	}

	function onErrorHook (reply, error, cb) {
	  if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
	    reply[kReplyIsRunningOnErrorHook] = true;
	    onSendHookRunner(
	      reply[kRouteContext].onError,
	      reply.request,
	      reply,
	      error,
	      () => handleError(reply, error, cb)
	    );
	  } else {
	    handleError(reply, error, cb);
	  }
	}

	function setupResponseListeners (reply) {
	  reply[kReplyStartTime] = now();

	  const onResFinished = err => {
	    reply[kReplyEndTime] = now();
	    reply.raw.removeListener('finish', onResFinished);
	    reply.raw.removeListener('error', onResFinished);

	    const ctx = reply[kRouteContext];

	    if (ctx && ctx.onResponse !== null) {
	      onResponseHookRunner(
	        ctx.onResponse,
	        reply.request,
	        reply,
	        onResponseCallback
	      );
	    } else {
	      onResponseCallback(err, reply.request, reply);
	    }
	  };

	  reply.raw.on('finish', onResFinished);
	  reply.raw.on('error', onResFinished);
	}

	function onResponseCallback (err, request, reply) {
	  if (reply.log[kDisableRequestLogging]) {
	    return
	  }

	  const responseTime = reply.elapsedTime;

	  if (err != null) {
	    reply.log.error({
	      res: reply,
	      err,
	      responseTime
	    }, 'request errored');
	    return
	  }

	  reply.log.info({
	    res: reply,
	    responseTime
	  }, 'request completed');
	}

	function buildReply (R) {
	  const props = R.props.slice();

	  function _Reply (res, request, log) {
	    this.raw = res;
	    this[kReplyIsError] = false;
	    this[kReplyErrorHandlerCalled] = false;
	    this[kReplyHijacked] = false;
	    this[kReplySerializer] = null;
	    this.request = request;
	    this[kReplyHeaders] = {};
	    this[kReplyTrailers] = null;
	    this[kReplyStartTime] = undefined;
	    this[kReplyEndTime] = undefined;
	    this.log = log;

	    let prop;

	    for (let i = 0; i < props.length; i++) {
	      prop = props[i];
	      this[prop.key] = prop.value;
	    }
	  }
	  Object.setPrototypeOf(_Reply.prototype, R.prototype);
	  Object.setPrototypeOf(_Reply, R);
	  _Reply.parent = R;
	  _Reply.props = props;
	  return _Reply
	}

	function notFound (reply) {
	  if (reply[kRouteContext][kFourOhFourContext] === null) {
	    reply.log.warn('Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.');
	    reply.code(404).send('404 Not Found');
	    return
	  }

	  reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];

	  // preHandler hook
	  if (reply[kRouteContext].preHandler !== null) {
	    preHandlerHookRunner(
	      reply[kRouteContext].preHandler,
	      reply.request,
	      reply,
	      internals.preHandlerCallback
	    );
	  } else {
	    internals.preHandlerCallback(null, reply.request, reply);
	  }
	}

	/**
	 * This function runs when a payload that is not a string|buffer|stream or null
	 * should be serialized to be streamed to the response.
	 * This is the default serializer that can be customized by the user using the replySerializer
	 *
	 * @param {object} context the request context
	 * @param {object} data the JSON payload to serialize
	 * @param {number} statusCode the http status code
	 * @param {string} [contentType] the reply content type
	 * @returns {string} the serialized payload
	 */
	function serialize (context, data, statusCode, contentType) {
	  const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
	  if (fnSerialize) {
	    return fnSerialize(data)
	  }
	  return JSON.stringify(data)
	}

	function noop () { }

	reply.exports = Reply;
	reply.exports.buildReply = buildReply;
	reply.exports.setupResponseListeners = setupResponseListeners;
	return reply.exports;
}

var request$1 = {exports: {}};

var proxyAddr = {exports: {}};

var forwarded = {exports: {}};

/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredForwarded;

function requireForwarded () {
	if (hasRequiredForwarded) return forwarded.exports;
	hasRequiredForwarded = 1;

	/**
	 * Get all addresses in the request used in the `X-Forwarded-For` header.
	 */
	function forwarded$1 (req) {
	  if (!req) {
	    throw new TypeError('argument req is required')
	  }

	  const header = req.headers['x-forwarded-for'];
	  const socketAddr = req.socket.remoteAddress;

	  if (!header || typeof header !== 'string') {
	    return [socketAddr]
	  } else if (header.indexOf(',') === -1) {
	    const remote = header.trim();
	    return (remote.length)
	      ? [socketAddr, remote]
	      : [socketAddr]
	  } else {
	    return parse(header, socketAddr)
	  }
	}

	function parse (header, socketAddr) {
	  const result = [socketAddr];

	  let end = header.length;
	  let start = end;
	  let char;
	  let i;

	  for (i = end - 1; i >= 0; --i) {
	    char = header[i];
	    if (char === ' ') {
	      (start === end) && (start = end = i);
	    } else if (char === ',') {
	      (start !== end) && result.push(header.slice(start, end));
	      start = end = i;
	    } else {
	      start = i;
	    }
	  }

	  (start !== end) && result.push(header.substring(start, end));

	  return result
	}

	forwarded.exports = forwarded$1;
	forwarded.exports.default = forwarded$1;
	forwarded.exports.forwarded = forwarded$1;
	return forwarded.exports;
}

var ipaddr$1 = {exports: {}};

var ipaddr = ipaddr$1.exports;

var hasRequiredIpaddr;

function requireIpaddr () {
	if (hasRequiredIpaddr) return ipaddr$1.exports;
	hasRequiredIpaddr = 1;
	(function (module) {
		(function (root) {
		    // A list of regular expressions that match arbitrary IPv4 addresses,
		    // for which a number of weird notations exist.
		    // Note that an address like 0010.0xa5.1.1 is considered legal.
		    const ipv4Part = '(0?\\d+|0x[a-f0-9]+)';
		    const ipv4Regexes = {
		        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, 'i'),
		        longValue: new RegExp(`^${ipv4Part}$`, 'i')
		    };

		    // Regular Expression for checking Octal numbers
		    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');
		    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');

		    const zoneIndex = '%[0-9a-z]{1,}';

		    // IPv6-matching regular expressions.
		    // For IPv6, the task is simpler: it is enough to match the colon-delimited
		    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at
		    // the end.
		    const ipv6Part = '(?:[0-9a-f]+::?)+';
		    const ipv6Regexes = {
		        zoneIndex: new RegExp(zoneIndex, 'i'),
		        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),
		        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),
		        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, 'i')
		    };

		    // Expand :: in an IPv6 address or address part consisting of `parts` groups.
		    function expandIPv6 (string, parts) {
		        // More than one '::' means invalid adddress
		        if (string.indexOf('::') !== string.lastIndexOf('::')) {
		            return null;
		        }

		        let colonCount = 0;
		        let lastColon = -1;
		        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
		        let replacement, replacementCount;

		        // Remove zone index and save it for later
		        if (zoneId) {
		            zoneId = zoneId.substring(1);
		            string = string.replace(/%.+$/, '');
		        }

		        // How many parts do we already have?
		        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
		            colonCount++;
		        }

		        // 0::0 is two parts more than ::
		        if (string.substr(0, 2) === '::') {
		            colonCount--;
		        }

		        if (string.substr(-2, 2) === '::') {
		            colonCount--;
		        }

		        // The following loop would hang if colonCount > parts
		        if (colonCount > parts) {
		            return null;
		        }

		        // replacement = ':' + '0:' * (parts - colonCount)
		        replacementCount = parts - colonCount;
		        replacement = ':';
		        while (replacementCount--) {
		            replacement += '0:';
		        }

		        // Insert the missing zeroes
		        string = string.replace('::', replacement);

		        // Trim any garbage which may be hanging around if :: was at the edge in
		        // the source strin
		        if (string[0] === ':') {
		            string = string.slice(1);
		        }

		        if (string[string.length - 1] === ':') {
		            string = string.slice(0, -1);
		        }

		        parts = (function () {
		            const ref = string.split(':');
		            const results = [];

		            for (let i = 0; i < ref.length; i++) {
		                results.push(parseInt(ref[i], 16));
		            }

		            return results;
		        })();

		        return {
		            parts: parts,
		            zoneId: zoneId
		        };
		    }

		    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.
		    function matchCIDR (first, second, partSize, cidrBits) {
		        if (first.length !== second.length) {
		            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');
		        }

		        let part = 0;
		        let shift;

		        while (cidrBits > 0) {
		            shift = partSize - cidrBits;
		            if (shift < 0) {
		                shift = 0;
		            }

		            if (first[part] >> shift !== second[part] >> shift) {
		                return false;
		            }

		            cidrBits -= partSize;
		            part += 1;
		        }

		        return true;
		    }

		    function parseIntAuto (string) {
		        // Hexadedimal base 16 (0x#)
		        if (hexRegex.test(string)) {
		            return parseInt(string, 16);
		        }
		        // While octal representation is discouraged by ECMAScript 3
		        // and forbidden by ECMAScript 5, we silently allow it to
		        // work only if the rest of the string has numbers less than 8.
		        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {
		        if (octalRegex.test(string)) {
		            return parseInt(string, 8);
		        }
		            throw new Error(`ipaddr: cannot parse ${string} as octal`);
		        }
		        // Always include the base 10 radix!
		        return parseInt(string, 10);
		    }

		    function padPart (part, length) {
		        while (part.length < length) {
		            part = `0${part}`;
		        }

		        return part;
		    }

		    const ipaddr = {};

		    // An IPv4 address (RFC791).
		    ipaddr.IPv4 = (function () {
		        // Constructs a new IPv4 address from an array of four octets
		        // in network order (MSB first)
		        // Verifies the input.
		        function IPv4 (octets) {
		            if (octets.length !== 4) {
		                throw new Error('ipaddr: ipv4 octet count should be 4');
		            }

		            let i, octet;

		            for (i = 0; i < octets.length; i++) {
		                octet = octets[i];
		                if (!((0 <= octet && octet <= 255))) {
		                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');
		                }
		            }

		            this.octets = octets;
		        }

		        // Special IPv4 address ranges.
		        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses
		        IPv4.prototype.SpecialRanges = {
		            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
		            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
		            // RFC3171
		            multicast: [[new IPv4([224, 0, 0, 0]), 4]],
		            // RFC3927
		            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
		            // RFC5735
		            loopback: [[new IPv4([127, 0, 0, 0]), 8]],
		            // RFC6598
		            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
		            // RFC1918
		            'private': [
		                [new IPv4([10, 0, 0, 0]), 8],
		                [new IPv4([172, 16, 0, 0]), 12],
		                [new IPv4([192, 168, 0, 0]), 16]
		            ],
		            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
		            reserved: [
		                [new IPv4([192, 0, 0, 0]), 24],
		                [new IPv4([192, 0, 2, 0]), 24],
		                [new IPv4([192, 88, 99, 0]), 24],
		                [new IPv4([198, 18, 0, 0]), 15],
		                [new IPv4([198, 51, 100, 0]), 24],
		                [new IPv4([203, 0, 113, 0]), 24],
		                [new IPv4([240, 0, 0, 0]), 4]
		            ],
		            // RFC7534, RFC7535
		            as112: [
		                [new IPv4([192, 175, 48, 0]), 24],
		                [new IPv4([192, 31, 196, 0]), 24],
		            ],
		            // RFC7450
		            amt: [
		                [new IPv4([192, 52, 193, 0]), 24],
		            ],
		        };

		        // The 'kind' method exists on both IPv4 and IPv6 classes.
		        IPv4.prototype.kind = function () {
		            return 'ipv4';
		        };

		        // Checks if this address matches other one within given CIDR range.
		        IPv4.prototype.match = function (other, cidrRange) {
		            let ref;
		            if (cidrRange === undefined) {
		                ref = other;
		                other = ref[0];
		                cidrRange = ref[1];
		            }

		            if (other.kind() !== 'ipv4') {
		                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');
		            }

		            return matchCIDR(this.octets, other.octets, 8, cidrRange);
		        };

		        // returns a number of leading ones in IPv4 address, making sure that
		        // the rest is a solid sequence of 0's (valid netmask)
		        // returns either the CIDR length or null if mask is not valid
		        IPv4.prototype.prefixLengthFromSubnetMask = function () {
		            let cidr = 0;
		            // non-zero encountered stop scanning for zeroes
		            let stop = false;
		            // number of zeroes in octet
		            const zerotable = {
		                0: 8,
		                128: 7,
		                192: 6,
		                224: 5,
		                240: 4,
		                248: 3,
		                252: 2,
		                254: 1,
		                255: 0
		            };
		            let i, octet, zeros;

		            for (i = 3; i >= 0; i -= 1) {
		                octet = this.octets[i];
		                if (octet in zerotable) {
		                    zeros = zerotable[octet];
		                    if (stop && zeros !== 0) {
		                        return null;
		                    }

		                    if (zeros !== 8) {
		                        stop = true;
		                    }

		                    cidr += zeros;
		                } else {
		                    return null;
		                }
		            }

		            return 32 - cidr;
		        };

		        // Checks if the address corresponds to one of the special ranges.
		        IPv4.prototype.range = function () {
		            return ipaddr.subnetMatch(this, this.SpecialRanges);
		        };

		        // Returns an array of byte-sized values in network order (MSB first)
		        IPv4.prototype.toByteArray = function () {
		            return this.octets.slice(0);
		        };

		        // Converts this IPv4 address to an IPv4-mapped IPv6 address.
		        IPv4.prototype.toIPv4MappedAddress = function () {
		            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
		        };

		        // Symmetrical method strictly for aligning with the IPv6 methods.
		        IPv4.prototype.toNormalizedString = function () {
		            return this.toString();
		        };

		        // Returns the address in convenient, decimal-dotted format.
		        IPv4.prototype.toString = function () {
		            return this.octets.join('.');
		        };

		        return IPv4;
		    })();

		    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation
		    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {

		        try {
		            const cidr = this.parseCIDR(string);
		            const ipInterfaceOctets = cidr[0].toByteArray();
		            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            const octets = [];
		            let i = 0;
		            while (i < 4) {
		                // Broadcast address is bitwise OR between ip interface and inverted mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		        }
		    };

		    // Checks if a given string is formatted like IPv4 address.
		    ipaddr.IPv4.isIPv4 = function (string) {
		        return this.parser(string) !== null;
		    };

		    // Checks if a given string is a valid IPv4 address.
		    ipaddr.IPv4.isValid = function (string) {
		        try {
		            new this(this.parser(string));
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a valid IPv4 address in CIDR notation.
		    ipaddr.IPv4.isValidCIDR = function (string) {
		        try {
		            this.parseCIDR(string);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a full four-part IPv4 Address.
		    ipaddr.IPv4.isValidFourPartDecimal = function (string) {
		        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
		            return true;
		        } else {
		            return false;
		        }
		    };

		    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation
		    ipaddr.IPv4.networkAddressFromCIDR = function (string) {
		        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

		        try {
		            cidr = this.parseCIDR(string);
		            ipInterfaceOctets = cidr[0].toByteArray();
		            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            octets = [];
		            i = 0;
		            while (i < 4) {
		                // Network address is bitwise AND between ip interface and mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
		        }
		    };

		    // Tries to parse and validate a string with IPv4 address.
		    // Throws an error if it fails.
		    ipaddr.IPv4.parse = function (string) {
		        const parts = this.parser(string);

		        if (parts === null) {
		            throw new Error('ipaddr: string is not formatted like an IPv4 Address');
		        }

		        return new this(parts);
		    };

		    // Parses the string as an IPv4 Address with CIDR Notation.
		    ipaddr.IPv4.parseCIDR = function (string) {
		        let match;

		        if ((match = string.match(/^(.+)\/(\d+)$/))) {
		            const maskLength = parseInt(match[2]);
		            if (maskLength >= 0 && maskLength <= 32) {
		                const parsed = [this.parse(match[1]), maskLength];
		                Object.defineProperty(parsed, 'toString', {
		                    value: function () {
		                        return this.join('/');
		                    }
		                });
		                return parsed;
		            }
		        }

		        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');
		    };

		    // Classful variants (like a.b, where a is an octet, and b is a 24-bit
		    // value representing last three octets; this corresponds to a class C
		    // address) are omitted due to classless nature of modern Internet.
		    ipaddr.IPv4.parser = function (string) {
		        let match, part, value;

		        // parseInt recognizes all that octal & hexadecimal weirdness for us
		        if ((match = string.match(ipv4Regexes.fourOctet))) {
		            return (function () {
		                const ref = match.slice(1, 6);
		                const results = [];

		                for (let i = 0; i < ref.length; i++) {
		                    part = ref[i];
		                    results.push(parseIntAuto(part));
		                }

		                return results;
		            })();
		        } else if ((match = string.match(ipv4Regexes.longValue))) {
		            value = parseIntAuto(match[1]);
		            if (value > 0xffffffff || value < 0) {
		                throw new Error('ipaddr: address outside defined range');
		            }

		            return ((function () {
		                const results = [];
		                let shift;

		                for (shift = 0; shift <= 24; shift += 8) {
		                    results.push((value >> shift) & 0xff);
		                }

		                return results;
		            })()).reverse();
		        } else if ((match = string.match(ipv4Regexes.twoOctet))) {
		            return (function () {
		                const ref = match.slice(1, 4);
		                const results = [];

		                value = parseIntAuto(ref[1]);
		                if (value > 0xffffff || value < 0) {
		                    throw new Error('ipaddr: address outside defined range');
		                }

		                results.push(parseIntAuto(ref[0]));
		                results.push((value >> 16) & 0xff);
		                results.push((value >>  8) & 0xff);
		                results.push( value        & 0xff);

		                return results;
		            })();
		        } else if ((match = string.match(ipv4Regexes.threeOctet))) {
		            return (function () {
		                const ref = match.slice(1, 5);
		                const results = [];

		                value = parseIntAuto(ref[2]);
		                if (value > 0xffff || value < 0) {
		                    throw new Error('ipaddr: address outside defined range');
		                }

		                results.push(parseIntAuto(ref[0]));
		                results.push(parseIntAuto(ref[1]));
		                results.push((value >> 8) & 0xff);
		                results.push( value       & 0xff);

		                return results;
		            })();
		        } else {
		            return null;
		        }
		    };

		    // A utility function to return subnet mask in IPv4 format given the prefix length
		    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
		        prefix = parseInt(prefix);
		        if (prefix < 0 || prefix > 32) {
		            throw new Error('ipaddr: invalid IPv4 prefix length');
		        }

		        const octets = [0, 0, 0, 0];
		        let j = 0;
		        const filledOctetCount = Math.floor(prefix / 8);

		        while (j < filledOctetCount) {
		            octets[j] = 255;
		            j++;
		        }

		        if (filledOctetCount < 4) {
		            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
		        }

		        return new this(octets);
		    };

		    // An IPv6 address (RFC2460)
		    ipaddr.IPv6 = (function () {
		        // Constructs an IPv6 address from an array of eight 16 - bit parts
		        // or sixteen 8 - bit parts in network order(MSB first).
		        // Throws an error if the input is invalid.
		        function IPv6 (parts, zoneId) {
		            let i, part;

		            if (parts.length === 16) {
		                this.parts = [];
		                for (i = 0; i <= 14; i += 2) {
		                    this.parts.push((parts[i] << 8) | parts[i + 1]);
		                }
		            } else if (parts.length === 8) {
		                this.parts = parts;
		            } else {
		                throw new Error('ipaddr: ipv6 part count should be 8 or 16');
		            }

		            for (i = 0; i < this.parts.length; i++) {
		                part = this.parts[i];
		                if (!((0 <= part && part <= 0xffff))) {
		                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');
		                }
		            }

		            if (zoneId) {
		                this.zoneId = zoneId;
		            }
		        }

		        // Special IPv6 ranges
		        IPv6.prototype.SpecialRanges = {
		            // RFC4291, here and after
		            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
		            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
		            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
		            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
		            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
		            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
		            // RFC6666
		            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],
		            // RFC6145
		            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
		            // RFC6052
		            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
		            // RFC3056
		            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
		            // RFC6052, RFC6146
		            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
		            // RFC5180
		            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],
		            // RFC7450
		            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],
		            as112v6: [
		                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],
		                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],
		            ],
		            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],
		            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],
		            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],
		            reserved: [
		                // RFC3849
		                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],
		                // RFC2928
		                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],
		            ],
		        };

		        // Checks if this address is an IPv4-mapped IPv6 address.
		        IPv6.prototype.isIPv4MappedAddress = function () {
		            return this.range() === 'ipv4Mapped';
		        };

		        // The 'kind' method exists on both IPv4 and IPv6 classes.
		        IPv6.prototype.kind = function () {
		            return 'ipv6';
		        };

		        // Checks if this address matches other one within given CIDR range.
		        IPv6.prototype.match = function (other, cidrRange) {
		            let ref;

		            if (cidrRange === undefined) {
		                ref = other;
		                other = ref[0];
		                cidrRange = ref[1];
		            }

		            if (other.kind() !== 'ipv6') {
		                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');
		            }

		            return matchCIDR(this.parts, other.parts, 16, cidrRange);
		        };

		        // returns a number of leading ones in IPv6 address, making sure that
		        // the rest is a solid sequence of 0's (valid netmask)
		        // returns either the CIDR length or null if mask is not valid
		        IPv6.prototype.prefixLengthFromSubnetMask = function () {
		            let cidr = 0;
		            // non-zero encountered stop scanning for zeroes
		            let stop = false;
		            // number of zeroes in octet
		            const zerotable = {
		                0: 16,
		                32768: 15,
		                49152: 14,
		                57344: 13,
		                61440: 12,
		                63488: 11,
		                64512: 10,
		                65024: 9,
		                65280: 8,
		                65408: 7,
		                65472: 6,
		                65504: 5,
		                65520: 4,
		                65528: 3,
		                65532: 2,
		                65534: 1,
		                65535: 0
		            };
		            let part, zeros;

		            for (let i = 7; i >= 0; i -= 1) {
		                part = this.parts[i];
		                if (part in zerotable) {
		                    zeros = zerotable[part];
		                    if (stop && zeros !== 0) {
		                        return null;
		                    }

		                    if (zeros !== 16) {
		                        stop = true;
		                    }

		                    cidr += zeros;
		                } else {
		                    return null;
		                }
		            }

		            return 128 - cidr;
		        };


		        // Checks if the address corresponds to one of the special ranges.
		        IPv6.prototype.range = function () {
		            return ipaddr.subnetMatch(this, this.SpecialRanges);
		        };

		        // Returns an array of byte-sized values in network order (MSB first)
		        IPv6.prototype.toByteArray = function () {
		            let part;
		            const bytes = [];
		            const ref = this.parts;
		            for (let i = 0; i < ref.length; i++) {
		                part = ref[i];
		                bytes.push(part >> 8);
		                bytes.push(part & 0xff);
		            }

		            return bytes;
		        };

		        // Returns the address in expanded format with all zeroes included, like
		        // 2001:0db8:0008:0066:0000:0000:0000:0001
		        IPv6.prototype.toFixedLengthString = function () {
		            const addr = ((function () {
		                const results = [];
		                for (let i = 0; i < this.parts.length; i++) {
		                    results.push(padPart(this.parts[i].toString(16), 4));
		                }

		                return results;
		            }).call(this)).join(':');

		            let suffix = '';

		            if (this.zoneId) {
		                suffix = `%${this.zoneId}`;
		            }

		            return addr + suffix;
		        };

		        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.
		        // Throws an error otherwise.
		        IPv6.prototype.toIPv4Address = function () {
		            if (!this.isIPv4MappedAddress()) {
		                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');
		            }

		            const ref = this.parts.slice(-2);
		            const high = ref[0];
		            const low = ref[1];

		            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
		        };

		        // Returns the address in expanded format with all zeroes included, like
		        // 2001:db8:8:66:0:0:0:1
		        //
		        // Deprecated: use toFixedLengthString() instead.
		        IPv6.prototype.toNormalizedString = function () {
		            const addr = ((function () {
		                const results = [];

		                for (let i = 0; i < this.parts.length; i++) {
		                    results.push(this.parts[i].toString(16));
		                }

		                return results;
		            }).call(this)).join(':');

		            let suffix = '';

		            if (this.zoneId) {
		                suffix = `%${this.zoneId}`;
		            }

		            return addr + suffix;
		        };

		        // Returns the address in compact, human-readable format like
		        // 2001:db8:8:66::1
		        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)
		        IPv6.prototype.toRFC5952String = function () {
		            const regex = /((^|:)(0(:|$)){2,})/g;
		            const string = this.toNormalizedString();
		            let bestMatchIndex = 0;
		            let bestMatchLength = -1;
		            let match;

		            while ((match = regex.exec(string))) {
		                if (match[0].length > bestMatchLength) {
		                    bestMatchIndex = match.index;
		                    bestMatchLength = match[0].length;
		                }
		            }

		            if (bestMatchLength < 0) {
		                return string;
		            }

		            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
		        };

		        // Returns the address in compact, human-readable format like
		        // 2001:db8:8:66::1
		        // Calls toRFC5952String under the hood.
		        IPv6.prototype.toString = function () {
		            return this.toRFC5952String();
		        };

		        return IPv6;

		    })();

		    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation
		    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {
		        try {
		            const cidr = this.parseCIDR(string);
		            const ipInterfaceOctets = cidr[0].toByteArray();
		            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            const octets = [];
		            let i = 0;
		            while (i < 16) {
		                // Broadcast address is bitwise OR between ip interface and inverted mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
		        }
		    };

		    // Checks if a given string is formatted like IPv6 address.
		    ipaddr.IPv6.isIPv6 = function (string) {
		        return this.parser(string) !== null;
		    };

		    // Checks to see if string is a valid IPv6 Address
		    ipaddr.IPv6.isValid = function (string) {

		        // Since IPv6.isValid is always called first, this shortcut
		        // provides a substantial performance gain.
		        if (typeof string === 'string' && string.indexOf(':') === -1) {
		            return false;
		        }

		        try {
		            const addr = this.parser(string);
		            new this(addr.parts, addr.zoneId);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // Checks if a given string is a valid IPv6 address in CIDR notation.
		    ipaddr.IPv6.isValidCIDR = function (string) {

		        // See note in IPv6.isValid
		        if (typeof string === 'string' && string.indexOf(':') === -1) {
		            return false;
		        }

		        try {
		            this.parseCIDR(string);
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation
		    ipaddr.IPv6.networkAddressFromCIDR = function (string) {
		        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;

		        try {
		            cidr = this.parseCIDR(string);
		            ipInterfaceOctets = cidr[0].toByteArray();
		            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
		            octets = [];
		            i = 0;
		            while (i < 16) {
		                // Network address is bitwise AND between ip interface and mask
		                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
		                i++;
		            }

		            return new this(octets);
		        } catch (e) {
		            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
		        }
		    };

		    // Tries to parse and validate a string with IPv6 address.
		    // Throws an error if it fails.
		    ipaddr.IPv6.parse = function (string) {
		        const addr = this.parser(string);

		        if (addr.parts === null) {
		            throw new Error('ipaddr: string is not formatted like an IPv6 Address');
		        }

		        return new this(addr.parts, addr.zoneId);
		    };

		    ipaddr.IPv6.parseCIDR = function (string) {
		        let maskLength, match, parsed;

		        if ((match = string.match(/^(.+)\/(\d+)$/))) {
		            maskLength = parseInt(match[2]);
		            if (maskLength >= 0 && maskLength <= 128) {
		                parsed = [this.parse(match[1]), maskLength];
		                Object.defineProperty(parsed, 'toString', {
		                    value: function () {
		                        return this.join('/');
		                    }
		                });
		                return parsed;
		            }
		        }

		        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');
		    };

		    // Parse an IPv6 address.
		    ipaddr.IPv6.parser = function (string) {
		        let addr, i, match, octet, octets, zoneId;

		        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {
		            return this.parser(`::ffff:${match[1]}`);
		        }
		        if (ipv6Regexes.native.test(string)) {
		            return expandIPv6(string, 8);
		        }
		        if ((match = string.match(ipv6Regexes.transitional))) {
		            zoneId = match[6] || '';
		            addr = match[1];
		            if (!match[1].endsWith('::')) {
		                addr = addr.slice(0, -1);
		            }
		            addr = expandIPv6(addr + zoneId, 6);
		            if (addr.parts) {
		                octets = [
		                    parseInt(match[2]),
		                    parseInt(match[3]),
		                    parseInt(match[4]),
		                    parseInt(match[5])
		                ];
		                for (i = 0; i < octets.length; i++) {
		                    octet = octets[i];
		                    if (!((0 <= octet && octet <= 255))) {
		                        return null;
		                    }
		                }

		                addr.parts.push(octets[0] << 8 | octets[1]);
		                addr.parts.push(octets[2] << 8 | octets[3]);
		                return {
		                    parts: addr.parts,
		                    zoneId: addr.zoneId
		                };
		            }
		        }

		        return null;
		    };

		    // A utility function to return subnet mask in IPv6 format given the prefix length
		    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {
		        prefix = parseInt(prefix);
		        if (prefix < 0 || prefix > 128) {
		            throw new Error('ipaddr: invalid IPv6 prefix length');
		        }

		        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		        let j = 0;
		        const filledOctetCount = Math.floor(prefix / 8);

		        while (j < filledOctetCount) {
		            octets[j] = 255;
		            j++;
		        }

		        if (filledOctetCount < 16) {
		            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
		        }

		        return new this(octets);
		    };

		    // Try to parse an array in network order (MSB first) for IPv4 and IPv6
		    ipaddr.fromByteArray = function (bytes) {
		        const length = bytes.length;

		        if (length === 4) {
		            return new ipaddr.IPv4(bytes);
		        } else if (length === 16) {
		            return new ipaddr.IPv6(bytes);
		        } else {
		            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');
		        }
		    };

		    // Checks if the address is valid IP address
		    ipaddr.isValid = function (string) {
		        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
		    };

		    // Checks if the address is valid IP address in CIDR notation
		    ipaddr.isValidCIDR = function (string) {
		        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
		    };


		    // Attempts to parse an IP Address, first through IPv6 then IPv4.
		    // Throws an error if it could not be parsed.
		    ipaddr.parse = function (string) {
		        if (ipaddr.IPv6.isValid(string)) {
		            return ipaddr.IPv6.parse(string);
		        } else if (ipaddr.IPv4.isValid(string)) {
		            return ipaddr.IPv4.parse(string);
		        } else {
		            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');
		        }
		    };

		    // Attempt to parse CIDR notation, first through IPv6 then IPv4.
		    // Throws an error if it could not be parsed.
		    ipaddr.parseCIDR = function (string) {
		        try {
		            return ipaddr.IPv6.parseCIDR(string);
		        } catch (e) {
		            try {
		                return ipaddr.IPv4.parseCIDR(string);
		            } catch (e2) {
		                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');
		            }
		        }
		    };

		    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address
		    ipaddr.process = function (string) {
		        const addr = this.parse(string);

		        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
		            return addr.toIPv4Address();
		        } else {
		            return addr;
		        }
		    };

		    // An utility function to ease named range matching. See examples below.
		    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors
		    // on matching IPv4 addresses to IPv6 ranges or vice versa.
		    ipaddr.subnetMatch = function (address, rangeList, defaultName) {
		        let i, rangeName, rangeSubnets, subnet;

		        if (defaultName === undefined || defaultName === null) {
		            defaultName = 'unicast';
		        }

		        for (rangeName in rangeList) {
		            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
		                rangeSubnets = rangeList[rangeName];
		                // ECMA5 Array.isArray isn't available everywhere
		                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
		                    rangeSubnets = [rangeSubnets];
		                }

		                for (i = 0; i < rangeSubnets.length; i++) {
		                    subnet = rangeSubnets[i];
		                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
		                        return rangeName;
		                    }
		                }
		            }
		        }

		        return defaultName;
		    };

		    // Export for both the CommonJS and browser-like environment
		    if (module.exports) {
		        module.exports = ipaddr;

		    } else {
		        root.ipaddr = ipaddr;
		    }

		}(ipaddr)); 
	} (ipaddr$1));
	return ipaddr$1.exports;
}

/*!
 * proxy-addr
 * Copyright(c) 2021 Fastify collaborators
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredProxyAddr;

function requireProxyAddr () {
	if (hasRequiredProxyAddr) return proxyAddr.exports;
	hasRequiredProxyAddr = 1;

	/**
	 * Module exports.
	 * @public
	 */

	proxyAddr.exports = proxyaddr;
	proxyAddr.exports.default = proxyaddr;
	proxyAddr.exports.proxyaddr = proxyaddr;
	proxyAddr.exports.all = alladdrs;
	proxyAddr.exports.compile = compile;

	/**
	 * Module dependencies.
	 * @private
	 */

	const forwarded = requireForwarded();
	const ipaddr = requireIpaddr();

	/**
	 * Variables.
	 * @private
	 */

	const DIGIT_REGEXP = /^\d+$/u;
	const isip = ipaddr.isValid;
	const parseip = ipaddr.parse;

	/**
	 * Pre-defined IP ranges.
	 * @private
	 */

	const IP_RANGES = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};

	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @public
	 */

	function alladdrs (req, trust) {
	  // get addresses
	  const addrs = forwarded(req);

	  if (!trust) {
	    // Return all addresses
	    return addrs
	  }

	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }

	  /* eslint-disable no-var */
	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue

	    addrs.length = i + 1;
	  }

	  return addrs
	}

	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @private
	 */

	function compile (val) {
	  if (!val) {
	    throw new TypeError('argument is required')
	  }

	  let trust;

	  if (typeof val === 'string') {
	    trust = [val];
	  } else if (Array.isArray(val)) {
	    trust = val.slice();
	  } else {
	    throw new TypeError('unsupported trust argument')
	  }

	  /* eslint-disable no-var */
	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];

	    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
	      continue
	    }

	    // Splice in pre-defined range
	    val = IP_RANGES[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }

	  return compileTrust(compileRangeSubnets(trust))
	}

	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @private
	 */

	function compileRangeSubnets (arr) {
	  const rangeSubnets = new Array(arr.length);

	  /* eslint-disable no-var */
	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }

	  return rangeSubnets
	}

	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @private
	 */

	function compileTrust (rangeSubnets) {
	  // Return optimized function based on length
	  const len = rangeSubnets.length;
	  return len === 0
	    ? trustNone
	    : len === 1
	      ? trustSingle(rangeSubnets[0])
	      : trustMulti(rangeSubnets)
	}

	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @private
	 */

	function parseipNotation (note) {
	  const pos = note.lastIndexOf('/');
	  const str = pos !== -1
	    ? note.substring(0, pos)
	    : note;

	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str)
	  }

	  let ip = parseip(str);

	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }

	  const max = ip.kind() === 'ipv6'
	    ? 128
	    : 32;

	  let range = pos !== -1
	    ? note.substring(pos + 1, note.length)
	    : null;

	  if (range === null) {
	    range = max;
	  } else if (DIGIT_REGEXP.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }

	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note)
	  }

	  return [ip, range]
	}

	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @private
	 */

	function parseNetmask (netmask) {
	  const ip = parseip(netmask);
	  const kind = ip.kind();

	  return kind === 'ipv4'
	    ? ip.prefixLengthFromSubnetMask()
	    : null
	}

	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @public
	 */

	function proxyaddr (req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required')
	  }

	  if (!trust) {
	    throw new TypeError('trust argument is required')
	  }

	  const addrs = alladdrs(req, trust);
	  const addr = addrs[addrs.length - 1];

	  return addr
	}

	/**
	 * Static trust function to trust nothing.
	 *
	 * @private
	 */

	function trustNone () {
	  return false
	}

	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @private
	 */

	function trustMulti (subnets) {
	  return function trust (addr) {
	    if (!isip(addr)) return false

	    const ip = parseip(addr);
	    let ipconv;
	    const kind = ip.kind();

	    /* eslint-disable no-var */
	    for (var i = 0; i < subnets.length; i++) {
	      const subnet = subnets[i];
	      const subnetip = subnet[0];
	      const subnetkind = subnetip.kind();
	      const subnetrange = subnet[1];
	      let trusted = ip;

	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue
	        }

	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4'
	            ? ip.toIPv4Address()
	            : ip.toIPv4MappedAddress();
	        }

	        trusted = ipconv;
	      }

	      if (trusted.match(subnetip, subnetrange)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @private
	 */

	function trustSingle (subnet) {
	  const subnetip = subnet[0];
	  const subnetkind = subnetip.kind();
	  const subnetisipv4 = subnetkind === 'ipv4';
	  const subnetrange = subnet[1];

	  return function trust (addr) {
	    if (!isip(addr)) return false

	    let ip = parseip(addr);
	    const kind = ip.kind();

	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false
	      }

	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4
	        ? ip.toIPv4Address()
	        : ip.toIPv4MappedAddress();
	    }

	    return ip.match(subnetip, subnetrange)
	  }
	}
	return proxyAddr.exports;
}

var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$1.exports;
	hasRequiredRequest$1 = 1;

	const proxyAddr = requireProxyAddr();
	const {
	  kHasBeenDecorated,
	  kSchemaBody,
	  kSchemaHeaders,
	  kSchemaParams,
	  kSchemaQuerystring,
	  kSchemaController,
	  kOptions,
	  kRequestCacheValidateFns,
	  kRouteContext,
	  kRequestOriginalUrl
	} = requireSymbols$2();
	const { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = requireErrors$2();
	const decorators = requireDecorate();

	const HTTP_PART_SYMBOL_MAP = {
	  body: kSchemaBody,
	  headers: kSchemaHeaders,
	  params: kSchemaParams,
	  querystring: kSchemaQuerystring,
	  query: kSchemaQuerystring
	};

	function Request (id, params, req, query, log, context) {
	  this.id = id;
	  this[kRouteContext] = context;
	  this.params = params;
	  this.raw = req;
	  this.query = query;
	  this.log = log;
	  this.body = undefined;
	}
	Request.props = [];

	function getTrustProxyFn (tp) {
	  if (typeof tp === 'function') {
	    return tp
	  }
	  if (tp === true) {
	    // Support trusting everything
	    return null
	  }
	  if (typeof tp === 'number') {
	    // Support trusting hop count
	    return function (a, i) { return i < tp }
	  }
	  if (typeof tp === 'string') {
	    // Support comma-separated tps
	    const values = tp.split(',').map(it => it.trim());
	    return proxyAddr.compile(values)
	  }
	  return proxyAddr.compile(tp)
	}

	function buildRequest (R, trustProxy) {
	  if (trustProxy) {
	    return buildRequestWithTrustProxy(R, trustProxy)
	  }

	  return buildRegularRequest(R)
	}

	function buildRegularRequest (R) {
	  const props = R.props.slice();
	  function _Request (id, params, req, query, log, context) {
	    this.id = id;
	    this[kRouteContext] = context;
	    this.params = params;
	    this.raw = req;
	    this.query = query;
	    this.log = log;
	    this.body = undefined;

	    let prop;
	    for (let i = 0; i < props.length; i++) {
	      prop = props[i];
	      this[prop.key] = prop.value;
	    }
	  }
	  Object.setPrototypeOf(_Request.prototype, R.prototype);
	  Object.setPrototypeOf(_Request, R);
	  _Request.props = props;
	  _Request.parent = R;

	  return _Request
	}

	function getLastEntryInMultiHeaderValue (headerValue) {
	  // we use the last one if the header is set more than once
	  const lastIndex = headerValue.lastIndexOf(',');
	  return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim()
	}

	function buildRequestWithTrustProxy (R, trustProxy) {
	  const _Request = buildRegularRequest(R);
	  const proxyFn = getTrustProxyFn(trustProxy);

	  // This is a more optimized version of decoration
	  _Request[kHasBeenDecorated] = true;

	  Object.defineProperties(_Request.prototype, {
	    ip: {
	      get () {
	        const addrs = proxyAddr.all(this.raw, proxyFn);
	        return addrs[addrs.length - 1]
	      }
	    },
	    ips: {
	      get () {
	        return proxyAddr.all(this.raw, proxyFn)
	      }
	    },
	    host: {
	      get () {
	        if (this.ip !== undefined && this.headers['x-forwarded-host']) {
	          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-host'])
	        }
	        /**
	         * The last fallback supports the following cases:
	         * 1. http.requireHostHeader === false
	         * 2. HTTP/1.0 without a Host Header
	         * 3. Headers schema that may remove the Host Header
	         */
	        return this.headers.host ?? this.headers[':authority'] ?? ''
	      }
	    },
	    protocol: {
	      get () {
	        if (this.headers['x-forwarded-proto']) {
	          return getLastEntryInMultiHeaderValue(this.headers['x-forwarded-proto'])
	        }
	        if (this.socket) {
	          return this.socket.encrypted ? 'https' : 'http'
	        }
	      }
	    }
	  });

	  return _Request
	}

	function assertsRequestDecoration (request, name) {
	  if (!decorators.hasKey(request, name) && !decorators.exist(request, name)) {
	    throw new FST_ERR_DEC_UNDECLARED(name, 'request')
	  }
	}

	Object.defineProperties(Request.prototype, {
	  server: {
	    get () {
	      return this[kRouteContext].server
	    }
	  },
	  url: {
	    get () {
	      return this.raw.url
	    }
	  },
	  originalUrl: {
	    get () {
	      /* istanbul ignore else */
	      if (!this[kRequestOriginalUrl]) {
	        this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
	      }
	      return this[kRequestOriginalUrl]
	    }
	  },
	  method: {
	    get () {
	      return this.raw.method
	    }
	  },
	  routeOptions: {
	    get () {
	      const context = this[kRouteContext];
	      const routeLimit = context._parserOptions.limit;
	      const serverLimit = context.server.initialConfig.bodyLimit;
	      const version = context.server.hasConstraintStrategy('version') ? this.raw.headers['accept-version'] : undefined;
	      const options = {
	        method: context.config?.method,
	        url: context.config?.url,
	        bodyLimit: (routeLimit || serverLimit),
	        attachValidation: context.attachValidation,
	        logLevel: context.logLevel,
	        exposeHeadRoute: context.exposeHeadRoute,
	        prefixTrailingSlash: context.prefixTrailingSlash,
	        handler: context.handler,
	        config: context.config,
	        schema: context.schema,
	        version
	      };

	      return options
	    }
	  },
	  is404: {
	    get () {
	      return this[kRouteContext].config?.url === undefined
	    }
	  },
	  socket: {
	    get () {
	      return this.raw.socket
	    }
	  },
	  ip: {
	    get () {
	      if (this.socket) {
	        return this.socket.remoteAddress
	      }
	    }
	  },
	  host: {
	    get () {
	      /**
	       * The last fallback supports the following cases:
	       * 1. http.requireHostHeader === false
	       * 2. HTTP/1.0 without a Host Header
	       * 3. Headers schema that may remove the Host Header
	       */
	      return this.raw.headers.host ?? this.raw.headers[':authority'] ?? ''
	    }
	  },
	  hostname: {
	    get () {
	      return this.host.split(':', 1)[0]
	    }
	  },
	  port: {
	    get () {
	      // first try taking port from host
	      const portFromHost = parseInt(this.host.split(':').slice(-1)[0]);
	      if (!isNaN(portFromHost)) {
	        return portFromHost
	      }
	      // now fall back to port from host/:authority header
	      const host = (this.headers.host ?? this.headers[':authority'] ?? '');
	      const portFromHeader = parseInt(host.split(':').slice(-1)[0]);
	      if (!isNaN(portFromHeader)) {
	        return portFromHeader
	      }
	      // fall back to null
	      return null
	    }
	  },
	  protocol: {
	    get () {
	      if (this.socket) {
	        return this.socket.encrypted ? 'https' : 'http'
	      }
	    }
	  },
	  headers: {
	    get () {
	      if (this.additionalHeaders) {
	        return Object.assign({}, this.raw.headers, this.additionalHeaders)
	      }
	      return this.raw.headers
	    },
	    set (headers) {
	      this.additionalHeaders = headers;
	    }
	  },
	  getValidationFunction: {
	    value: function (httpPartOrSchema) {
	      if (typeof httpPartOrSchema === 'string') {
	        const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
	        return this[kRouteContext][symbol]
	      } else if (typeof httpPartOrSchema === 'object') {
	        return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema)
	      }
	    }
	  },
	  compileValidationSchema: {
	    value: function (schema, httpPart = null) {
	      const { method, url } = this;

	      if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
	        return this[kRouteContext][kRequestCacheValidateFns].get(schema)
	      }

	      const validatorCompiler = this[kRouteContext].validatorCompiler ||
	        this.server[kSchemaController].validatorCompiler ||
	        (
	          // We compile the schemas if no custom validatorCompiler is provided
	          // nor set
	          this.server[kSchemaController].setupValidator(this.server[kOptions]) ||
	          this.server[kSchemaController].validatorCompiler
	        );

	      const validateFn = validatorCompiler({
	        schema,
	        method,
	        url,
	        httpPart
	      });

	      // We create a WeakMap to compile the schema only once
	      // Its done lazily to avoid add overhead by creating the WeakMap
	      // if it is not used
	      // TODO: Explore a central cache for all the schemas shared across
	      // encapsulated contexts
	      if (this[kRouteContext][kRequestCacheValidateFns] == null) {
	        this[kRouteContext][kRequestCacheValidateFns] = new WeakMap();
	      }

	      this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);

	      return validateFn
	    }
	  },
	  validateInput: {
	    value: function (input, schema, httpPart) {
	      httpPart = typeof schema === 'string' ? schema : httpPart;

	      const symbol = (httpPart != null && typeof httpPart === 'string') && HTTP_PART_SYMBOL_MAP[httpPart];
	      let validate;

	      if (symbol) {
	        // Validate using the HTTP Request Part schema
	        validate = this[kRouteContext][symbol];
	      }

	      // We cannot compile if the schema is missed
	      if (validate == null && (schema == null ||
	        typeof schema !== 'object' ||
	        Array.isArray(schema))
	      ) {
	        throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart)
	      }

	      if (validate == null) {
	        if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
	          validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
	        } else {
	          // We proceed to compile if there's no validate function yet
	          validate = this.compileValidationSchema(schema, httpPart);
	        }
	      }

	      return validate(input)
	    }
	  },
	  getDecorator: {
	    value: function (name) {
	      assertsRequestDecoration(this, name);

	      const decorator = this[name];
	      if (typeof decorator === 'function') {
	        return decorator.bind(this)
	      }

	      return decorator
	    }
	  },
	  setDecorator: {
	    value: function (name, value) {
	      assertsRequestDecoration(this, name);

	      this[name] = value;
	    }
	  }
	});

	request$1.exports = Request;
	request$1.exports.buildRequest = buildRequest;
	return request$1.exports;
}

var context;
var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return context;
	hasRequiredContext = 1;

	const {
	  kFourOhFourContext,
	  kReplySerializerDefault,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kChildLoggerFactory,
	  kOptions,
	  kReply,
	  kRequest,
	  kBodyLimit,
	  kLogLevel,
	  kContentTypeParser,
	  kRouteByFastify,
	  kRequestCacheValidateFns,
	  kReplyCacheSerializeFns
	} = requireSymbols$2();

	// Object that holds the context of every request
	// Every route holds an instance of this object.
	function Context ({
	  schema,
	  handler,
	  config,
	  requestIdLogLabel,
	  childLoggerFactory,
	  errorHandler,
	  bodyLimit,
	  logLevel,
	  logSerializers,
	  attachValidation,
	  validatorCompiler,
	  serializerCompiler,
	  replySerializer,
	  schemaErrorFormatter,
	  exposeHeadRoute,
	  prefixTrailingSlash,
	  server,
	  isFastify
	}) {
	  this.schema = schema;
	  this.handler = handler;
	  this.Reply = server[kReply];
	  this.Request = server[kRequest];
	  this.contentTypeParser = server[kContentTypeParser];
	  this.onRequest = null;
	  this.onSend = null;
	  this.onError = null;
	  this.onTimeout = null;
	  this.preHandler = null;
	  this.onResponse = null;
	  this.preSerialization = null;
	  this.onRequestAbort = null;
	  this.config = config;
	  this.errorHandler = errorHandler || server[kErrorHandler];
	  this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
	  this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
	  this._middie = null;
	  this._parserOptions = {
	    limit: bodyLimit || server[kBodyLimit]
	  };
	  this.exposeHeadRoute = exposeHeadRoute;
	  this.prefixTrailingSlash = prefixTrailingSlash;
	  this.logLevel = logLevel || server[kLogLevel];
	  this.logSerializers = logSerializers;
	  this[kFourOhFourContext] = null;
	  this.attachValidation = attachValidation;
	  this[kReplySerializerDefault] = replySerializer;
	  this.schemaErrorFormatter =
	    schemaErrorFormatter ||
	    server[kSchemaErrorFormatter] ||
	    defaultSchemaErrorFormatter;
	  this[kRouteByFastify] = isFastify;

	  this[kRequestCacheValidateFns] = null;
	  this[kReplyCacheSerializeFns] = null;
	  this.validatorCompiler = validatorCompiler || null;
	  this.serializerCompiler = serializerCompiler || null;

	  this.server = server;
	}

	function defaultSchemaErrorFormatter (errors, dataVar) {
	  let text = '';
	  const separator = ', ';

	  for (let i = 0; i !== errors.length; ++i) {
	    const e = errors[i];
	    text += dataVar + (e.instancePath || '') + ' ' + e.message + separator;
	  }
	  return new Error(text.slice(0, -separator.length))
	}

	context = Context;
	return context;
}

var contentTypeParser = {exports: {}};

var toadCache = {};

/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */

var hasRequiredToadCache;

function requireToadCache () {
	if (hasRequiredToadCache) return toadCache;
	hasRequiredToadCache = 1;

	class FifoMap {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = new Map();
	    this.last = null;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  get size() {
	    return this.items.size
	  }

	  clear() {
	    this.items = new Map();
	    this.first = null;
	    this.last = null;
	  }

	  delete(key) {
	    if (this.items.has(key)) {
	      const deletedItem = this.items.get(key);

	      this.items.delete(key);

	      if (deletedItem.prev !== null) {
	        deletedItem.prev.next = deletedItem.next;
	      }

	      if (deletedItem.next !== null) {
	        deletedItem.next.prev = deletedItem.prev;
	      }

	      if (this.first === deletedItem) {
	        this.first = deletedItem.next;
	      }

	      if (this.last === deletedItem) {
	        this.last = deletedItem.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      this.items.delete(item.key);

	      if (this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (this.items.has(key)) {
	      return this.items.get(key).expiry
	    }
	  }

	  get(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return this.items.keys()
	  }

	  set(key, value) {
	    // Replace existing item
	    if (this.items.has(key)) {
	      const item = this.items.get(key);
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items.set(key, item);

	    if (this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class LruMap {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = new Map();
	    this.last = null;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  get size() {
	    return this.items.size
	  }

	  bumpLru(item) {
	    if (this.last === item) {
	      return // Item is already the last one, no need to bump
	    }

	    const last = this.last;
	    const next = item.next;
	    const prev = item.prev;

	    if (this.first === item) {
	      this.first = next;
	    }

	    item.next = null;
	    item.prev = last;
	    last.next = item;

	    if (prev !== null) {
	      prev.next = next;
	    }

	    if (next !== null) {
	      next.prev = prev;
	    }

	    this.last = item;
	  }

	  clear() {
	    this.items = new Map();
	    this.first = null;
	    this.last = null;
	  }

	  delete(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      this.items.delete(key);

	      if (item.prev !== null) {
	        item.prev.next = item.next;
	      }

	      if (item.next !== null) {
	        item.next.prev = item.prev;
	      }

	      if (this.first === item) {
	        this.first = item.next;
	      }

	      if (this.last === item) {
	        this.last = item.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      this.items.delete(item.key);

	      if (this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (this.items.has(key)) {
	      return this.items.get(key).expiry
	    }
	  }

	  get(key) {
	    if (this.items.has(key)) {
	      const item = this.items.get(key);

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return this.items.keys()
	  }

	  set(key, value) {
	    // Replace existing item
	    if (this.items.has(key)) {
	      const item = this.items.get(key);
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      if (this.last !== item) {
	        this.bumpLru(item);
	      }

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items.set(key, item);

	    if (this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class LruObject {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = Object.create(null);
	    this.last = null;
	    this.size = 0;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  bumpLru(item) {
	    if (this.last === item) {
	      return // Item is already the last one, no need to bump
	    }

	    const last = this.last;
	    const next = item.next;
	    const prev = item.prev;

	    if (this.first === item) {
	      this.first = next;
	    }

	    item.next = null;
	    item.prev = last;
	    last.next = item;

	    if (prev !== null) {
	      prev.next = next;
	    }

	    if (next !== null) {
	      next.prev = prev;
	    }

	    this.last = item;
	  }

	  clear() {
	    this.items = Object.create(null);
	    this.first = null;
	    this.last = null;
	    this.size = 0;
	  }

	  delete(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      delete this.items[key];
	      this.size--;

	      if (item.prev !== null) {
	        item.prev.next = item.next;
	      }

	      if (item.next !== null) {
	        item.next.prev = item.prev;
	      }

	      if (this.first === item) {
	        this.first = item.next;
	      }

	      if (this.last === item) {
	        this.last = item.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      delete this.items[item.key];

	      if (--this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      return this.items[key].expiry
	    }
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return Object.keys(this.items)
	  }

	  set(key, value) {
	    // Replace existing item
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      if (this.last !== item) {
	        this.bumpLru(item);
	      }

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items[key] = item;

	    if (++this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	class HitStatisticsRecord {
	  constructor() {
	    this.records = {};
	  }

	  initForCache(cacheId, currentTimeStamp) {
	    this.records[cacheId] = {
	      [currentTimeStamp]: {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	        sets: 0,
	      },
	    };
	  }

	  resetForCache(cacheId) {
	    for (let key of Object.keys(this.records[cacheId])) {
	      this.records[cacheId][key] = {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	        sets: 0,
	      };
	    }
	  }

	  getStatistics() {
	    return this.records
	  }
	}

	/**
	 *
	 * @param {Date} date
	 * @returns {string}
	 */
	function getTimestamp(date) {
	  return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date
	    .getDate()
	    .toString()
	    .padStart(2, '0')}`
	}

	class HitStatistics {
	  constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
	    this.cacheId = cacheId;
	    this.statisticTtlInHours = statisticTtlInHours;

	    this.collectionStart = new Date();
	    this.currentTimeStamp = getTimestamp(this.collectionStart);

	    this.records = globalStatisticsRecord || new HitStatisticsRecord();
	    this.records.initForCache(this.cacheId, this.currentTimeStamp);
	  }

	  get currentRecord() {
	    // safety net
	    /* c8 ignore next 14 */
	    if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
	      this.records.records[this.cacheId][this.currentTimeStamp] = {
	        cacheSize: 0,
	        hits: 0,
	        falsyHits: 0,
	        emptyHits: 0,
	        misses: 0,
	        expirations: 0,
	        evictions: 0,
	        sets: 0,
	        invalidateOne: 0,
	        invalidateAll: 0,
	      };
	    }

	    return this.records.records[this.cacheId][this.currentTimeStamp]
	  }

	  hoursPassed() {
	    return (Date.now() - this.collectionStart) / 1000 / 60 / 60
	  }

	  addHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.hits++;
	  }
	  addFalsyHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.falsyHits++;
	  }

	  addEmptyHit() {
	    this.archiveIfNeeded();
	    this.currentRecord.emptyHits++;
	  }

	  addMiss() {
	    this.archiveIfNeeded();
	    this.currentRecord.misses++;
	  }

	  addEviction() {
	    this.archiveIfNeeded();
	    this.currentRecord.evictions++;
	  }

	  setCacheSize(currentSize) {
	    this.archiveIfNeeded();
	    this.currentRecord.cacheSize = currentSize;
	  }

	  addExpiration() {
	    this.archiveIfNeeded();
	    this.currentRecord.expirations++;
	  }

	  addSet() {
	    this.archiveIfNeeded();
	    this.currentRecord.sets++;
	  }

	  addInvalidateOne() {
	    this.archiveIfNeeded();
	    this.currentRecord.invalidateOne++;
	  }

	  addInvalidateAll() {
	    this.archiveIfNeeded();
	    this.currentRecord.invalidateAll++;
	  }

	  getStatistics() {
	    return this.records.getStatistics()
	  }

	  archiveIfNeeded() {
	    if (this.hoursPassed() >= this.statisticTtlInHours) {
	      this.collectionStart = new Date();
	      this.currentTimeStamp = getTimestamp(this.collectionStart);
	      this.records.initForCache(this.cacheId, this.currentTimeStamp);
	    }
	  }
	}

	class LruObjectHitStatistics extends LruObject {
	  constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
	    super(max || 1000, ttlInMsecs || 0);

	    if (!cacheId) {
	      throw new Error('Cache id is mandatory')
	    }

	    this.hitStatistics = new HitStatistics(
	      cacheId,
	      statisticTtlInHours !== undefined ? statisticTtlInHours : 24,
	      globalStatisticsRecord,
	    );
	  }

	  getStatistics() {
	    return this.hitStatistics.getStatistics()
	  }

	  set(key, value) {
	    super.set(key, value);
	    this.hitStatistics.addSet();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  evict() {
	    super.evict();
	    this.hitStatistics.addEviction();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  delete(key, isExpiration = false) {
	    super.delete(key);

	    if (!isExpiration) {
	      this.hitStatistics.addInvalidateOne();
	    }
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  clear() {
	    super.clear();

	    this.hitStatistics.addInvalidateAll();
	    this.hitStatistics.setCacheSize(this.size);
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      // Item has already expired
	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key, true);
	        this.hitStatistics.addExpiration();
	        return
	      }

	      // Item is still fresh
	      this.bumpLru(item);
	      if (!item.value) {
	        this.hitStatistics.addFalsyHit();
	      }
	      if (item.value === undefined || item.value === null || item.value === '') {
	        this.hitStatistics.addEmptyHit();
	      }
	      this.hitStatistics.addHit();
	      return item.value
	    }
	    this.hitStatistics.addMiss();
	  }
	}

	class FifoObject {
	  constructor(max = 1000, ttlInMsecs = 0) {
	    if (isNaN(max) || max < 0) {
	      throw new Error('Invalid max value')
	    }

	    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
	      throw new Error('Invalid ttl value')
	    }

	    this.first = null;
	    this.items = Object.create(null);
	    this.last = null;
	    this.size = 0;
	    this.max = max;
	    this.ttl = ttlInMsecs;
	  }

	  clear() {
	    this.items = Object.create(null);
	    this.first = null;
	    this.last = null;
	    this.size = 0;
	  }

	  delete(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const deletedItem = this.items[key];

	      delete this.items[key];
	      this.size--;

	      if (deletedItem.prev !== null) {
	        deletedItem.prev.next = deletedItem.next;
	      }

	      if (deletedItem.next !== null) {
	        deletedItem.next.prev = deletedItem.prev;
	      }

	      if (this.first === deletedItem) {
	        this.first = deletedItem.next;
	      }

	      if (this.last === deletedItem) {
	        this.last = deletedItem.prev;
	      }
	    }
	  }

	  deleteMany(keys) {
	    for (var i = 0; i < keys.length; i++) {
	      this.delete(keys[i]);
	    }
	  }

	  evict() {
	    if (this.size > 0) {
	      const item = this.first;

	      delete this.items[item.key];

	      if (--this.size === 0) {
	        this.first = null;
	        this.last = null;
	      } else {
	        this.first = item.next;
	        this.first.prev = null;
	      }
	    }
	  }

	  expiresAt(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      return this.items[key].expiry
	    }
	  }

	  get(key) {
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];

	      if (this.ttl > 0 && item.expiry <= Date.now()) {
	        this.delete(key);
	        return
	      }

	      return item.value
	    }
	  }

	  getMany(keys) {
	    const result = [];

	    for (var i = 0; i < keys.length; i++) {
	      result.push(this.get(keys[i]));
	    }

	    return result
	  }

	  keys() {
	    return Object.keys(this.items)
	  }

	  set(key, value) {
	    // Replace existing item
	    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
	      const item = this.items[key];
	      item.value = value;

	      item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;

	      return
	    }

	    // Add new item
	    if (this.max > 0 && this.size === this.max) {
	      this.evict();
	    }

	    const item = {
	      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
	      key: key,
	      prev: this.last,
	      next: null,
	      value,
	    };
	    this.items[key] = item;

	    if (++this.size === 1) {
	      this.first = item;
	    } else {
	      this.last.next = item;
	    }

	    this.last = item;
	  }
	}

	toadCache.Fifo = FifoObject;
	toadCache.FifoMap = FifoMap;
	toadCache.FifoObject = FifoObject;
	toadCache.HitStatisticsRecord = HitStatisticsRecord;
	toadCache.Lru = LruObject;
	toadCache.LruHitStatistics = LruObjectHitStatistics;
	toadCache.LruMap = LruMap;
	toadCache.LruObject = LruObject;
	toadCache.LruObjectHitStatistics = LruObjectHitStatistics;
	return toadCache;
}

var secureJsonParse = {exports: {}};

var hasRequiredSecureJsonParse;

function requireSecureJsonParse () {
	if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
	hasRequiredSecureJsonParse = 1;

	const hasBuffer = typeof Buffer !== 'undefined';
	const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
	const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

	function _parse (text, reviver, options) {
	  // Normalize arguments
	  if (options == null) {
	    if (reviver !== null && typeof reviver === 'object') {
	      options = reviver;
	      reviver = undefined;
	    }
	  }

	  if (hasBuffer && Buffer.isBuffer(text)) {
	    text = text.toString();
	  }

	  // BOM checker
	  if (text && text.charCodeAt(0) === 0xFEFF) {
	    text = text.slice(1);
	  }

	  // Parse normally, allowing exceptions
	  const obj = JSON.parse(text, reviver);

	  // Ignore null and non-objects
	  if (obj === null || typeof obj !== 'object') {
	    return obj
	  }

	  const protoAction = (options && options.protoAction) || 'error';
	  const constructorAction = (options && options.constructorAction) || 'error';

	  // options: 'error' (default) / 'remove' / 'ignore'
	  if (protoAction === 'ignore' && constructorAction === 'ignore') {
	    return obj
	  }

	  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
	    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
	    if (suspectProtoRx.test(text) === false) {
	      return obj
	    }
	  } else {
	    if (suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  }

	  // Scan result for proto keys
	  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })
	}

	function filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
	  let next = [obj];

	  while (next.length) {
	    const nodes = next;
	    next = [];

	    for (const node of nodes) {
	      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (protoAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.__proto__; // eslint-disable-line no-proto
	      }

	      if (constructorAction !== 'ignore' &&
	          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
	          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (constructorAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.constructor;
	      }

	      for (const key in node) {
	        const value = node[key];
	        if (value && typeof value === 'object') {
	          next.push(value);
	        }
	      }
	    }
	  }
	  return obj
	}

	function parse (text, reviver, options) {
	  const { stackTraceLimit } = Error;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, options)
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	function safeParse (text, reviver) {
	  const { stackTraceLimit } = Error;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, { safe: true })
	  } catch {
	    return undefined
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	secureJsonParse.exports = parse;
	secureJsonParse.exports.default = parse;
	secureJsonParse.exports.parse = parse;
	secureJsonParse.exports.safeParse = safeParse;
	secureJsonParse.exports.scan = filter;
	return secureJsonParse.exports;
}

var hasRequiredContentTypeParser;

function requireContentTypeParser () {
	if (hasRequiredContentTypeParser) return contentTypeParser.exports;
	hasRequiredContentTypeParser = 1;
	(function (module) {

		const { AsyncResource } = require$$0$a;
		const { FifoMap: Fifo } = requireToadCache();
		const { parse: secureJsonParse } = requireSecureJsonParse();
		const {
		  kDefaultJsonParse,
		  kContentTypeParser,
		  kBodyLimit,
		  kRequestPayloadStream,
		  kState,
		  kTestInternals,
		  kReplyIsError,
		  kRouteContext
		} = requireSymbols$2();

		const {
		  FST_ERR_CTP_INVALID_TYPE,
		  FST_ERR_CTP_EMPTY_TYPE,
		  FST_ERR_CTP_ALREADY_PRESENT,
		  FST_ERR_CTP_INVALID_HANDLER,
		  FST_ERR_CTP_INVALID_PARSE_TYPE,
		  FST_ERR_CTP_BODY_TOO_LARGE,
		  FST_ERR_CTP_INVALID_MEDIA_TYPE,
		  FST_ERR_CTP_INVALID_CONTENT_LENGTH,
		  FST_ERR_CTP_EMPTY_JSON_BODY,
		  FST_ERR_CTP_INSTANCE_ALREADY_STARTED
		} = requireErrors$2();
		const { FSTSEC001 } = requireWarnings();

		function ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
		  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
		  // using a map instead of a plain object to avoid prototype hijack attacks
		  this.customParsers = new Map();
		  this.customParsers.set('application/json', new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
		  this.customParsers.set('text/plain', new Parser(true, false, bodyLimit, defaultPlainTextParser));
		  this.parserList = ['application/json', 'text/plain'];
		  this.parserRegExpList = [];
		  this.cache = new Fifo(100);
		}

		ContentTypeParser.prototype.add = function (contentType, opts, parserFn) {
		  const contentTypeIsString = typeof contentType === 'string';

		  if (contentTypeIsString) {
		    contentType = contentType.trim().toLowerCase();
		    if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE()
		  } else if (!(contentType instanceof RegExp)) {
		    throw new FST_ERR_CTP_INVALID_TYPE()
		  }

		  if (typeof parserFn !== 'function') {
		    throw new FST_ERR_CTP_INVALID_HANDLER()
		  }

		  if (this.existingParser(contentType)) {
		    throw new FST_ERR_CTP_ALREADY_PRESENT(contentType)
		  }

		  if (opts.parseAs !== undefined) {
		    if (opts.parseAs !== 'string' && opts.parseAs !== 'buffer') {
		      throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs)
		    }
		  }

		  const parser = new Parser(
		    opts.parseAs === 'string',
		    opts.parseAs === 'buffer',
		    opts.bodyLimit,
		    parserFn
		  );

		  if (contentType === '*') {
		    this.customParsers.set('', parser);
		  } else {
		    if (contentTypeIsString) {
		      this.parserList.unshift(contentType);
		      this.customParsers.set(contentType, parser);
		    } else {
		      validateRegExp(contentType);
		      this.parserRegExpList.unshift(contentType);
		      this.customParsers.set(contentType.toString(), parser);
		    }
		  }
		};

		ContentTypeParser.prototype.hasParser = function (contentType) {
		  if (typeof contentType === 'string') {
		    contentType = contentType.trim().toLowerCase();
		  } else {
		    if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()
		    contentType = contentType.toString();
		  }

		  return this.customParsers.has(contentType)
		};

		ContentTypeParser.prototype.existingParser = function (contentType) {
		  if (contentType === 'application/json' && this.customParsers.has(contentType)) {
		    return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse]
		  }
		  if (contentType === 'text/plain' && this.customParsers.has(contentType)) {
		    return this.customParsers.get(contentType).fn !== defaultPlainTextParser
		  }

		  return this.hasParser(contentType)
		};

		ContentTypeParser.prototype.getParser = function (contentType) {
		  let parser = this.customParsers.get(contentType);
		  if (parser !== undefined) return parser
		  parser = this.cache.get(contentType);
		  if (parser !== undefined) return parser

		  const caseInsensitiveContentType = contentType.toLowerCase();
		  for (let i = 0; i !== this.parserList.length; ++i) {
		    const parserListItem = this.parserList[i];
		    if (
		      caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem &&
		      (
		        caseInsensitiveContentType.length === parserListItem.length ||
		        caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 /* `;` */ ||
		        caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32 /* ` ` */
		      )
		    ) {
		      parser = this.customParsers.get(parserListItem);
		      this.cache.set(contentType, parser);
		      return parser
		    }
		  }

		  for (let j = 0; j !== this.parserRegExpList.length; ++j) {
		    const parserRegExp = this.parserRegExpList[j];
		    if (parserRegExp.test(contentType)) {
		      parser = this.customParsers.get(parserRegExp.toString());
		      this.cache.set(contentType, parser);
		      return parser
		    }
		  }

		  return this.customParsers.get('')
		};

		ContentTypeParser.prototype.removeAll = function () {
		  this.customParsers = new Map();
		  this.parserRegExpList = [];
		  this.parserList = [];
		  this.cache = new Fifo(100);
		};

		ContentTypeParser.prototype.remove = function (contentType) {
		  let parsers;

		  if (typeof contentType === 'string') {
		    contentType = contentType.trim().toLowerCase();
		    parsers = this.parserList;
		  } else {
		    if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE()
		    contentType = contentType.toString();
		    parsers = this.parserRegExpList;
		  }

		  const removed = this.customParsers.delete(contentType);
		  const idx = parsers.findIndex(ct => ct.toString() === contentType);

		  if (idx > -1) {
		    parsers.splice(idx, 1);
		  }

		  return removed || idx > -1
		};

		ContentTypeParser.prototype.run = function (contentType, handler, request, reply) {
		  const parser = this.getParser(contentType);

		  if (parser === undefined) {
		    if (request.is404) {
		      handler(request, reply);
		    } else {
		      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined));
		    }

		    // Early return to avoid allocating an AsyncResource if it's not needed
		    return
		  }

		  const resource = new AsyncResource('content-type-parser:run', request);

		  if (parser.asString === true || parser.asBuffer === true) {
		    rawBody(
		      request,
		      reply,
		      reply[kRouteContext]._parserOptions,
		      parser,
		      done
		    );
		  } else {
		    const result = parser.fn(request, request[kRequestPayloadStream], done);

		    if (result && typeof result.then === 'function') {
		      result.then(body => done(null, body), done);
		    }
		  }

		  function done (error, body) {
		    // We cannot use resource.bind() because it is broken in node v12 and v14
		    resource.runInAsyncScope(() => {
		      resource.emitDestroy();
		      if (error) {
		        reply[kReplyIsError] = true;
		        reply.send(error);
		      } else {
		        request.body = body;
		        handler(request, reply);
		      }
		    });
		  }
		};

		function rawBody (request, reply, options, parser, done) {
		  const asString = parser.asString;
		  const limit = options.limit === null ? parser.bodyLimit : options.limit;
		  const contentLength = Number(request.headers['content-length']);

		  if (contentLength > limit) {
		    // We must close the connection as the client is going
		    // to send this data anyway
		    reply.header('connection', 'close');
		    reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
		    return
		  }

		  let receivedLength = 0;
		  let body = asString === true ? '' : [];

		  const payload = request[kRequestPayloadStream] || request.raw;

		  if (asString === true) {
		    payload.setEncoding('utf8');
		  }

		  payload.on('data', onData);
		  payload.on('end', onEnd);
		  payload.on('error', onEnd);
		  payload.resume();

		  function onData (chunk) {
		    receivedLength += chunk.length;
		    const { receivedEncodedLength = 0 } = payload;
		    // The resulting body length must not exceed bodyLimit (see "zip bomb").
		    // The case when encoded length is larger than received length is rather theoretical,
		    // unless the stream returned by preParsing hook is broken and reports wrong value.
		    if (receivedLength > limit || receivedEncodedLength > limit) {
		      payload.removeListener('data', onData);
		      payload.removeListener('end', onEnd);
		      payload.removeListener('error', onEnd);
		      reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
		      return
		    }

		    if (asString === true) {
		      body += chunk;
		    } else {
		      body.push(chunk);
		    }
		  }

		  function onEnd (err) {
		    payload.removeListener('data', onData);
		    payload.removeListener('end', onEnd);
		    payload.removeListener('error', onEnd);

		    if (err !== undefined) {
		      if (!(typeof err.statusCode === 'number' && err.statusCode >= 400)) {
		        err.statusCode = 400;
		      }
		      reply[kReplyIsError] = true;
		      reply.code(err.statusCode).send(err);
		      return
		    }

		    if (asString === true) {
		      receivedLength = Buffer.byteLength(body);
		    }

		    if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
		      reply.header('connection', 'close');
		      reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
		      return
		    }

		    if (asString === false) {
		      body = Buffer.concat(body);
		    }

		    const result = parser.fn(request, body, done);
		    if (result && typeof result.then === 'function') {
		      result.then(body => done(null, body), done);
		    }
		  }
		}

		function getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {
		  return defaultJsonParser

		  function defaultJsonParser (req, body, done) {
		    if (body.length === 0) {
		      done(new FST_ERR_CTP_EMPTY_JSON_BODY(), undefined);
		      return
		    }
		    try {
		      done(null, secureJsonParse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning }));
		    } catch (err) {
		      err.statusCode = 400;
		      done(err, undefined);
		    }
		  }
		}

		function defaultPlainTextParser (req, body, done) {
		  done(null, body);
		}

		function Parser (asString, asBuffer, bodyLimit, fn) {
		  this.asString = asString;
		  this.asBuffer = asBuffer;
		  this.bodyLimit = bodyLimit;
		  this.fn = fn;
		}

		function buildContentTypeParser (c) {
		  const contentTypeParser = new ContentTypeParser();
		  contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
		  contentTypeParser.customParsers = new Map(c.customParsers.entries());
		  contentTypeParser.parserList = c.parserList.slice();
		  contentTypeParser.parserRegExpList = c.parserRegExpList.slice();
		  return contentTypeParser
		}

		function addContentTypeParser (contentType, opts, parser) {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('addContentTypeParser')
		  }

		  if (typeof opts === 'function') {
		    parser = opts;
		    opts = {};
		  }

		  if (!opts) opts = {};
		  if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];

		  if (Array.isArray(contentType)) {
		    contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
		  } else {
		    this[kContentTypeParser].add(contentType, opts, parser);
		  }

		  return this
		}

		function hasContentTypeParser (contentType) {
		  return this[kContentTypeParser].hasParser(contentType)
		}

		function removeContentTypeParser (contentType) {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('removeContentTypeParser')
		  }

		  if (Array.isArray(contentType)) {
		    for (const type of contentType) {
		      this[kContentTypeParser].remove(type);
		    }
		  } else {
		    this[kContentTypeParser].remove(contentType);
		  }
		}

		function removeAllContentTypeParsers () {
		  if (this[kState].started) {
		    throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED('removeAllContentTypeParsers')
		  }

		  this[kContentTypeParser].removeAll();
		}

		function validateRegExp (regexp) {
		  // RegExp should either start with ^ or include ;?
		  // It can ensure the user is properly detect the essence
		  // MIME types.
		  if (regexp.source[0] !== '^' && regexp.source.includes(';?') === false) {
		    FSTSEC001(regexp.source);
		  }
		}

		module.exports = ContentTypeParser;
		module.exports.helpers = {
		  buildContentTypeParser,
		  addContentTypeParser,
		  hasContentTypeParser,
		  removeContentTypeParser,
		  removeAllContentTypeParsers
		};
		module.exports.defaultParsers = {
		  getDefaultJsonParser,
		  defaultTextParser: defaultPlainTextParser
		};
		module.exports[kTestInternals] = { rawBody }; 
	} (contentTypeParser));
	return contentTypeParser.exports;
}

var fastJsonStringifyCompiler = {exports: {}};

var standalone$3 = {};

var fastJsonStringify = {exports: {}};

var dist$5 = {};

var hasRequiredDist$4;

function requireDist$4 () {
	if (hasRequiredDist$4) return dist$5;
	hasRequiredDist$4 = 1;
	var has = Object.prototype.hasOwnProperty;

	function find(iter, tar, key) {
		for (key of iter.keys()) {
			if (dequal(key, tar)) return key;
		}
	}

	function dequal(foo, bar) {
		var ctor, len, tmp;
		if (foo === bar) return true;

		if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
			if (ctor === Date) return foo.getTime() === bar.getTime();
			if (ctor === RegExp) return foo.toString() === bar.toString();

			if (ctor === Array) {
				if ((len=foo.length) === bar.length) {
					while (len-- && dequal(foo[len], bar[len]));
				}
				return len === -1;
			}

			if (ctor === Set) {
				if (foo.size !== bar.size) {
					return false;
				}
				for (len of foo) {
					tmp = len;
					if (tmp && typeof tmp === 'object') {
						tmp = find(bar, tmp);
						if (!tmp) return false;
					}
					if (!bar.has(tmp)) return false;
				}
				return true;
			}

			if (ctor === Map) {
				if (foo.size !== bar.size) {
					return false;
				}
				for (len of foo) {
					tmp = len[0];
					if (tmp && typeof tmp === 'object') {
						tmp = find(bar, tmp);
						if (!tmp) return false;
					}
					if (!dequal(len[1], bar.get(tmp))) {
						return false;
					}
				}
				return true;
			}

			if (ctor === ArrayBuffer) {
				foo = new Uint8Array(foo);
				bar = new Uint8Array(bar);
			} else if (ctor === DataView) {
				if ((len=foo.byteLength) === bar.byteLength) {
					while (len-- && foo.getInt8(len) === bar.getInt8(len));
				}
				return len === -1;
			}

			if (ArrayBuffer.isView(foo)) {
				if ((len=foo.byteLength) === bar.byteLength) {
					while (len-- && foo[len] === bar[len]);
				}
				return len === -1;
			}

			if (!ctor || typeof foo === 'object') {
				len = 0;
				for (ctor in foo) {
					if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
					if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
				}
				return Object.keys(bar).length === len;
			}
		}

		return foo !== foo && bar !== bar;
	}

	dist$5.dequal = dequal;
	return dist$5;
}

var jsonSchemaRefResolver;
var hasRequiredJsonSchemaRefResolver;

function requireJsonSchemaRefResolver () {
	if (hasRequiredJsonSchemaRefResolver) return jsonSchemaRefResolver;
	hasRequiredJsonSchemaRefResolver = 1;

	const { dequal: deepEqual } = requireDist$4();

	const jsonSchemaRefSymbol = Symbol.for('json-schema-ref');

	class RefResolver {
	  #schemas
	  #derefSchemas
	  #insertRefSymbol
	  #allowEqualDuplicates
	  #cloneSchemaWithoutRefs

	  constructor (opts = {}) {
	    this.#schemas = {};
	    this.#derefSchemas = {};
	    this.#insertRefSymbol = opts.insertRefSymbol ?? false;
	    this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
	    this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
	  }

	  addSchema (schema, rootSchemaId, isRootSchema = true) {
	    if (isRootSchema) {
	      if (schema.$id !== undefined && schema.$id.charAt(0) !== '#') {
	        // Schema has an $id that is not an anchor
	        rootSchemaId = schema.$id;
	      } else {
	        // Schema has no $id or $id is an anchor
	        this.#insertSchemaBySchemaId(schema, rootSchemaId);
	      }
	    }

	    const schemaId = schema.$id;
	    if (schemaId !== undefined && typeof schemaId === 'string') {
	      if (schemaId.charAt(0) === '#') {
	        this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
	      } else {
	        this.#insertSchemaBySchemaId(schema, schemaId);
	        rootSchemaId = schemaId;
	      }
	    }

	    const ref = schema.$ref;
	    if (ref !== undefined && typeof ref === 'string') {
	      const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
	      this.#schemas[rootSchemaId].refs.push({
	        schemaId: refSchemaId,
	        jsonPointer: refJsonPointer
	      });
	    }

	    for (const key in schema) {
	      if (typeof schema[key] === 'object' && schema[key] !== null) {
	        this.addSchema(schema[key], rootSchemaId, false);
	      }
	    }
	  }

	  getSchema (schemaId, jsonPointer = '#') {
	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(
	        `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
	      )
	    }
	    if (schema.anchors[jsonPointer] !== undefined) {
	      return schema.anchors[jsonPointer]
	    }
	    return getDataByJSONPointer(schema.schema, jsonPointer)
	  }

	  hasSchema (schemaId) {
	    return this.#schemas[schemaId] !== undefined
	  }

	  getSchemaRefs (schemaId) {
	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(`Schema with id "${schemaId}" is not found.`)
	    }
	    return schema.refs
	  }

	  getSchemaDependencies (schemaId, dependencies = {}) {
	    const schema = this.#schemas[schemaId];

	    for (const ref of schema.refs) {
	      const dependencySchemaId = ref.schemaId;
	      if (
	        dependencySchemaId === schemaId ||
	        dependencies[dependencySchemaId] !== undefined
	      ) continue

	      dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
	      this.getSchemaDependencies(dependencySchemaId, dependencies);
	    }

	    return dependencies
	  }

	  derefSchema (schemaId) {
	    if (this.#derefSchemas[schemaId] !== undefined) return

	    const schema = this.#schemas[schemaId];
	    if (schema === undefined) {
	      throw new Error(`Schema with id "${schemaId}" is not found.`)
	    }

	    if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
	      this.#derefSchemas[schemaId] = {
	        schema: schema.schema,
	        anchors: schema.anchors
	      };
	    }

	    const refs = [];
	    this.#addDerefSchema(schema.schema, schemaId, true, refs);

	    const dependencies = this.getSchemaDependencies(schemaId);
	    for (const schemaId in dependencies) {
	      const schema = dependencies[schemaId];
	      this.#addDerefSchema(schema, schemaId, true, refs);
	    }

	    for (const ref of refs) {
	      const {
	        refSchemaId,
	        refJsonPointer
	      } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);

	      const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
	      if (targetSchema === null) {
	        throw new Error(
	          `Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
	        )
	      }

	      ref.targetSchema = targetSchema;
	      ref.targetSchemaId = refSchemaId;
	    }

	    for (const ref of refs) {
	      this.#resolveRef(ref, refs);
	    }
	  }

	  getDerefSchema (schemaId, jsonPointer = '#') {
	    let derefSchema = this.#derefSchemas[schemaId];
	    if (derefSchema === undefined) {
	      this.derefSchema(schemaId);
	      derefSchema = this.#derefSchemas[schemaId];
	    }
	    if (derefSchema.anchors[jsonPointer] !== undefined) {
	      return derefSchema.anchors[jsonPointer]
	    }
	    return getDataByJSONPointer(derefSchema.schema, jsonPointer)
	  }

	  #parseSchemaRef (ref, schemaId) {
	    const sharpIndex = ref.indexOf('#');
	    if (sharpIndex === -1) {
	      return { refSchemaId: ref, refJsonPointer: '#' }
	    }
	    if (sharpIndex === 0) {
	      return { refSchemaId: schemaId, refJsonPointer: ref }
	    }
	    return {
	      refSchemaId: ref.slice(0, sharpIndex),
	      refJsonPointer: ref.slice(sharpIndex)
	    }
	  }

	  #addDerefSchema (schema, rootSchemaId, isRootSchema, refs = []) {
	    const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };

	    if (isRootSchema) {
	      if (schema.$id !== undefined && schema.$id.charAt(0) !== '#') {
	        // Schema has an $id that is not an anchor
	        rootSchemaId = schema.$id;
	      } else {
	        // Schema has no $id or $id is an anchor
	        this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
	      }
	    }

	    const schemaId = derefSchema.$id;
	    if (schemaId !== undefined && typeof schemaId === 'string') {
	      if (schemaId.charAt(0) === '#') {
	        this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
	      } else {
	        this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
	        rootSchemaId = schemaId;
	      }
	    }

	    if (derefSchema.$ref !== undefined) {
	      refs.push({
	        ref: derefSchema.$ref,
	        sourceSchemaId: rootSchemaId,
	        sourceSchema: derefSchema
	      });
	    }

	    for (const key in derefSchema) {
	      const value = derefSchema[key];
	      if (typeof value === 'object' && value !== null) {
	        derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
	      }
	    }

	    return derefSchema
	  }

	  #resolveRef (ref, refs) {
	    const { sourceSchema, targetSchema } = ref;

	    if (!sourceSchema.$ref) return
	    if (this.#insertRefSymbol) {
	      sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
	    }

	    delete sourceSchema.$ref;

	    if (targetSchema.$ref) {
	      const targetSchemaRef = refs.find(ref => ref.sourceSchema === targetSchema);
	      this.#resolveRef(targetSchemaRef, refs);
	    }
	    for (const key in targetSchema) {
	      if (key === '$id') continue
	      if (sourceSchema[key] !== undefined) {
	        if (deepEqual(sourceSchema[key], targetSchema[key])) continue
	        throw new Error(
	          `Cannot resolve ref "${ref.ref}". Property "${key}" already exists in schema "${ref.sourceSchemaId}".`
	        )
	      }
	      sourceSchema[key] = targetSchema[key];
	    }
	    ref.isResolved = true;
	  }

	  #insertSchemaBySchemaId (schema, schemaId) {
	    const foundSchema = this.#schemas[schemaId];
	    if (foundSchema !== undefined) {
	      if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return
	      throw new Error(`There is already another schema with id "${schemaId}".`)
	    }
	    this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
	  }

	  #insertSchemaByAnchor (schema, schemaId, anchor) {
	    const { anchors } = this.#schemas[schemaId];
	    if (anchors[anchor] !== undefined) {
	      throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`)
	    }
	    anchors[anchor] = schema;
	  }

	  #insertDerefSchemaBySchemaId (schema, schemaId) {
	    const foundSchema = this.#derefSchemas[schemaId];
	    if (foundSchema !== undefined) return

	    this.#derefSchemas[schemaId] = { schema, anchors: {} };
	  }

	  #insertDerefSchemaByAnchor (schema, schemaId, anchor) {
	    const { anchors } = this.#derefSchemas[schemaId];
	    anchors[anchor] = schema;
	  }
	}

	function getDataByJSONPointer (data, jsonPointer) {
	  const parts = jsonPointer.split('/');
	  let current = data;
	  for (const part of parts) {
	    if (part === '' || part === '#') continue
	    if (typeof current !== 'object' || current === null) {
	      return null
	    }
	    current = current[part];
	  }
	  return current ?? null
	}

	jsonSchemaRefResolver = { RefResolver };
	return jsonSchemaRefResolver;
}

var dist$4 = {exports: {}};

var formats = {};

var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
		function fmtDef(validate, compare) {
		    return { validate, compare };
		}
		exports.fullFormats = {
		    // date: http://tools.ietf.org/html/rfc3339#section-5.6
		    date: fmtDef(date, compareDate),
		    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
		    time: fmtDef(getTime(true), compareTime),
		    "date-time": fmtDef(getDateTime(true), compareDateTime),
		    "iso-time": fmtDef(getTime(), compareIsoTime),
		    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
		    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
		    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
		    uri,
		    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
		    // uri-template: https://tools.ietf.org/html/rfc6570
		    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
		    // For the source: https://gist.github.com/dperini/729294
		    // For test cases: https://mathiasbynens.be/demo/url-regex
		    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
		    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
		    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
		    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
		    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
		    regex,
		    // uuid: http://tools.ietf.org/html/rfc4122
		    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
		    // JSON-pointer: https://tools.ietf.org/html/rfc6901
		    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
		    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
		    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
		    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
		    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
		    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
		    // byte: https://github.com/miguelmota/is-base64
		    byte,
		    // signed 32 bit integer
		    int32: { type: "number", validate: validateInt32 },
		    // signed 64 bit integer
		    int64: { type: "number", validate: validateInt64 },
		    // C-type float
		    float: { type: "number", validate: validateNumber },
		    // C-type double
		    double: { type: "number", validate: validateNumber },
		    // hint to the UI to hide input strings
		    password: true,
		    // unchecked string payload
		    binary: true,
		};
		exports.fastFormats = {
		    ...exports.fullFormats,
		    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
		    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
		    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
		    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
		    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
		    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
		    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		    // email (sources from jsen validator):
		    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
		    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
		    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		};
		exports.formatNames = Object.keys(exports.fullFormats);
		function isLeapYear(year) {
		    // https://tools.ietf.org/html/rfc3339#appendix-C
		    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		}
		const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
		const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		function date(str) {
		    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
		    const matches = DATE.exec(str);
		    if (!matches)
		        return false;
		    const year = +matches[1];
		    const month = +matches[2];
		    const day = +matches[3];
		    return (month >= 1 &&
		        month <= 12 &&
		        day >= 1 &&
		        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
		}
		function compareDate(d1, d2) {
		    if (!(d1 && d2))
		        return undefined;
		    if (d1 > d2)
		        return 1;
		    if (d1 < d2)
		        return -1;
		    return 0;
		}
		const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
		function getTime(strictTimeZone) {
		    return function time(str) {
		        const matches = TIME.exec(str);
		        if (!matches)
		            return false;
		        const hr = +matches[1];
		        const min = +matches[2];
		        const sec = +matches[3];
		        const tz = matches[4];
		        const tzSign = matches[5] === "-" ? -1 : 1;
		        const tzH = +(matches[6] || 0);
		        const tzM = +(matches[7] || 0);
		        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))
		            return false;
		        if (hr <= 23 && min <= 59 && sec < 60)
		            return true;
		        // leap second
		        const utcMin = min - tzM * tzSign;
		        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
		        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
		    };
		}
		function compareTime(s1, s2) {
		    if (!(s1 && s2))
		        return undefined;
		    const t1 = new Date("2020-01-01T" + s1).valueOf();
		    const t2 = new Date("2020-01-01T" + s2).valueOf();
		    if (!(t1 && t2))
		        return undefined;
		    return t1 - t2;
		}
		function compareIsoTime(t1, t2) {
		    if (!(t1 && t2))
		        return undefined;
		    const a1 = TIME.exec(t1);
		    const a2 = TIME.exec(t2);
		    if (!(a1 && a2))
		        return undefined;
		    t1 = a1[1] + a1[2] + a1[3];
		    t2 = a2[1] + a2[2] + a2[3];
		    if (t1 > t2)
		        return 1;
		    if (t1 < t2)
		        return -1;
		    return 0;
		}
		const DATE_TIME_SEPARATOR = /t|\s/i;
		function getDateTime(strictTimeZone) {
		    const time = getTime(strictTimeZone);
		    return function date_time(str) {
		        // http://tools.ietf.org/html/rfc3339#section-5.6
		        const dateTime = str.split(DATE_TIME_SEPARATOR);
		        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
		    };
		}
		function compareDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const d1 = new Date(dt1).valueOf();
		    const d2 = new Date(dt2).valueOf();
		    if (!(d1 && d2))
		        return undefined;
		    return d1 - d2;
		}
		function compareIsoDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
		    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
		    const res = compareDate(d1, d2);
		    if (res === undefined)
		        return undefined;
		    return res || compareTime(t1, t2);
		}
		const NOT_URI_FRAGMENT = /\/|:/;
		const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
		function uri(str) {
		    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
		    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
		}
		const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
		function byte(str) {
		    BYTE.lastIndex = 0;
		    return BYTE.test(str);
		}
		const MIN_INT32 = -2147483648;
		const MAX_INT32 = 2 ** 31 - 1;
		function validateInt32(value) {
		    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
		}
		function validateInt64(value) {
		    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
		    return Number.isInteger(value);
		}
		function validateNumber() {
		    return true;
		}
		const Z_ANCHOR = /[^\\]\\Z/;
		function regex(str) {
		    if (Z_ANCHOR.test(str))
		        return false;
		    try {
		        new RegExp(str);
		        return true;
		    }
		    catch (e) {
		        return false;
		    }
		}
		
	} (formats));
	return formats;
}

var limit = {};

var hasRequiredLimit;

function requireLimit () {
	if (hasRequiredLimit) return limit;
	hasRequiredLimit = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatLimitDefinition = void 0;
		const ajv_1 = requireAjv();
		const codegen_1 = requireCodegen();
		const ops = codegen_1.operators;
		const KWDs = {
		    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
		    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
		    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
		    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
		};
		const error = {
		    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,
		    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
		};
		exports.formatLimitDefinition = {
		    keyword: Object.keys(KWDs),
		    type: "string",
		    schemaType: "string",
		    $data: true,
		    error,
		    code(cxt) {
		        const { gen, data, schemaCode, keyword, it } = cxt;
		        const { opts, self } = it;
		        if (!opts.validateFormats)
		            return;
		        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
		        if (fCxt.$data)
		            validate$DataFormat();
		        else
		            validateFormat();
		        function validate$DataFormat() {
		            const fmts = gen.scopeValue("formats", {
		                ref: self.formats,
		                code: opts.code.formats,
		            });
		            const fmt = gen.const("fmt", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);
		            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != "object"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
		        }
		        function validateFormat() {
		            const format = fCxt.schema;
		            const fmtDef = self.formats[format];
		            if (!fmtDef || fmtDef === true)
		                return;
		            if (typeof fmtDef != "object" ||
		                fmtDef instanceof RegExp ||
		                typeof fmtDef.compare != "function") {
		                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
		            }
		            const fmt = gen.scopeValue("formats", {
		                key: format,
		                ref: fmtDef,
		                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,
		            });
		            cxt.fail$data(compareCode(fmt));
		        }
		        function compareCode(fmt) {
		            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
		        }
		    },
		    dependencies: ["format"],
		};
		const formatLimitPlugin = (ajv) => {
		    ajv.addKeyword(exports.formatLimitDefinition);
		    return ajv;
		};
		exports.default = formatLimitPlugin;
		
	} (limit));
	return limit;
}

var hasRequiredDist$3;

function requireDist$3 () {
	if (hasRequiredDist$3) return dist$4.exports;
	hasRequiredDist$3 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const formats_1 = requireFormats();
		const limit_1 = requireLimit();
		const codegen_1 = requireCodegen();
		const fullName = new codegen_1.Name("fullFormats");
		const fastName = new codegen_1.Name("fastFormats");
		const formatsPlugin = (ajv, opts = { keywords: true }) => {
		    if (Array.isArray(opts)) {
		        addFormats(ajv, opts, formats_1.fullFormats, fullName);
		        return ajv;
		    }
		    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
		    const list = opts.formats || formats_1.formatNames;
		    addFormats(ajv, list, formats, exportName);
		    if (opts.keywords)
		        (0, limit_1.default)(ajv);
		    return ajv;
		};
		formatsPlugin.get = (name, mode = "full") => {
		    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
		    const f = formats[name];
		    if (!f)
		        throw new Error(`Unknown format "${name}"`);
		    return f;
		};
		function addFormats(ajv, list, fs, exportName) {
		    var _a;
		    var _b;
		    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require("ajv-formats/dist/formats").${exportName}`);
		    for (const f of list)
		        ajv.addFormat(f, fs[f]);
		}
		module.exports = exports = formatsPlugin;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = formatsPlugin;
		
	} (dist$4, dist$4.exports));
	return dist$4.exports;
}

var validator;
var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;

	const Ajv = requireAjv();
	const fastUri = requireFastUri();
	const ajvFormats = requireDist$3();
	const clone = requireRfdc()({ proto: true });

	class Validator {
	  constructor (ajvOptions) {
	    this.ajv = new Ajv({
	      ...ajvOptions,
	      strictSchema: false,
	      validateSchema: false,
	      allowUnionTypes: true,
	      uriResolver: fastUri
	    });

	    ajvFormats(this.ajv);

	    this.ajv.addKeyword({
	      keyword: 'fjs_type',
	      type: 'object',
	      errors: false,
	      validate: (_type, date) => {
	        return date instanceof Date
	      }
	    });

	    this._ajvSchemas = {};
	    this._ajvOptions = ajvOptions || {};
	  }

	  addSchema (schema, schemaName) {
	    let schemaKey = schema.$id || schemaName;
	    if (schema.$id !== undefined && schema.$id[0] === '#') {
	      schemaKey = schemaName + schema.$id; // relative URI
	    }

	    if (
	      this.ajv.refs[schemaKey] === undefined &&
	      this.ajv.schemas[schemaKey] === undefined
	    ) {
	      const ajvSchema = clone(schema);
	      this.convertSchemaToAjvFormat(ajvSchema);
	      this.ajv.addSchema(ajvSchema, schemaKey);
	      this._ajvSchemas[schemaKey] = schema;
	    }
	  }

	  validate (schemaRef, data) {
	    return this.ajv.validate(schemaRef, data)
	  }

	  // Ajv does not support js date format. In order to properly validate objects containing a date,
	  // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
	  // (see https://github.com/fastify/fast-json-stringify/pull/441)
	  convertSchemaToAjvFormat (schema) {
	    if (schema === null) return

	    if (schema.type === 'string') {
	      schema.fjs_type = 'string';
	      schema.type = ['string', 'object'];
	    } else if (
	      Array.isArray(schema.type) &&
	      schema.type.includes('string') &&
	      !schema.type.includes('object')
	    ) {
	      schema.fjs_type = 'string';
	      schema.type.push('object');
	    }
	    for (const property in schema) {
	      if (typeof schema[property] === 'object') {
	        this.convertSchemaToAjvFormat(schema[property]);
	      }
	    }
	  }

	  getState () {
	    return {
	      ajvOptions: this._ajvOptions,
	      ajvSchemas: this._ajvSchemas
	    }
	  }

	  static restoreFromState (state) {
	    const validator = new Validator(state.ajvOptions);
	    for (const [id, ajvSchema] of Object.entries(state.ajvSchemas)) {
	      validator.ajv.addSchema(ajvSchema, id);
	    }
	    return validator
	  }
	}

	validator = Validator;
	return validator;
}

var location;
var hasRequiredLocation;

function requireLocation () {
	if (hasRequiredLocation) return location;
	hasRequiredLocation = 1;

	class Location {
	  constructor (schema, schemaId, jsonPointer = '#') {
	    this.schema = schema;
	    this.schemaId = schemaId;
	    this.jsonPointer = jsonPointer;
	  }

	  getPropertyLocation (propertyName) {
	    const propertyLocation = new Location(
	      this.schema[propertyName],
	      this.schemaId,
	      this.jsonPointer + '/' + propertyName
	    );
	    return propertyLocation
	  }

	  getSchemaRef () {
	    return this.schemaId + this.jsonPointer
	  }
	}

	location = Location;
	return location;
}

var schemaValidator = {exports: {}};

/* CODE GENERATED BY 'build-schema-validator.js' DO NOT EDIT! */

var hasRequiredSchemaValidator;

function requireSchemaValidator () {
	if (hasRequiredSchemaValidator) return schemaValidator.exports;
	hasRequiredSchemaValidator = 1;
	schemaValidator.exports = validate10;
	schemaValidator.exports.default = validate10;
	const schema11 = {"type":["object","boolean"]};
	const schema20 = {"enum":["array","boolean","integer","null","number","object","string"]};
	const formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	const formats2 = requireFormats().fullFormats.uri;
	const formats6 = requireFormats().fullFormats.regex;

	function validate11(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(!(((typeof data == "number") && (!(data % 1) && !isNaN(data))) && (isFinite(data)))){
	validate11.errors = [{instancePath,schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	{
	if((typeof data == "number") && (isFinite(data))){
	if(data < 0 || isNaN(data)){
	validate11.errors = [{instancePath,schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	validate11.errors = vErrors;
	return errors === 0;
	}
	const root1 = {validate: validate10};

	function validate13(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(errors === 0){
	if(Array.isArray(data)){
	if(data.length < 1){
	validate13.errors = [{instancePath,schemaPath:"#/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"}];
	return false;
	}
	else {
	var valid0 = true;
	const len0 = data.length;
	for(let i0=0; i0<len0; i0++){
	const _errs1 = errors;
	if(!(root1.validate(data[i0], {instancePath:instancePath+"/" + i0,parentData:data,parentDataProperty:i0,rootData}))){
	vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs1 === errors;
	if(!valid0){
	break;
	}
	}
	}
	}
	else {
	validate13.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	validate13.errors = vErrors;
	return errors === 0;
	}

	const func0 = requireEqual().default;

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if((!(data && typeof data == "object" && !Array.isArray(data))) && (typeof data !== "boolean")){
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: schema11.type},message:"must be object,boolean"}];
	return false;
	}
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.$id !== undefined){
	let data0 = data.$id;
	const _errs1 = errors;
	if(errors === _errs1){
	if(errors === _errs1){
	if(typeof data0 === "string"){
	if(!(formats0.test(data0))){
	validate10.errors = [{instancePath:instancePath+"/$id",schemaPath:"#/properties/%24id/format",keyword:"format",params:{format: "uri-reference"},message:"must match format \""+"uri-reference"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$id",schemaPath:"#/properties/%24id/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs1 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$schema !== undefined){
	let data1 = data.$schema;
	const _errs3 = errors;
	if(errors === _errs3){
	if(errors === _errs3){
	if(typeof data1 === "string"){
	if(!(formats2(data1))){
	validate10.errors = [{instancePath:instancePath+"/$schema",schemaPath:"#/properties/%24schema/format",keyword:"format",params:{format: "uri"},message:"must match format \""+"uri"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$schema",schemaPath:"#/properties/%24schema/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs3 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$ref !== undefined){
	let data2 = data.$ref;
	const _errs5 = errors;
	if(errors === _errs5){
	if(errors === _errs5){
	if(typeof data2 === "string"){
	if(!(formats0.test(data2))){
	validate10.errors = [{instancePath:instancePath+"/$ref",schemaPath:"#/properties/%24ref/format",keyword:"format",params:{format: "uri-reference"},message:"must match format \""+"uri-reference"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/$ref",schemaPath:"#/properties/%24ref/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs5 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.$comment !== undefined){
	const _errs7 = errors;
	if(typeof data.$comment !== "string"){
	validate10.errors = [{instancePath:instancePath+"/$comment",schemaPath:"#/properties/%24comment/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs7 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.title !== undefined){
	const _errs9 = errors;
	if(typeof data.title !== "string"){
	validate10.errors = [{instancePath:instancePath+"/title",schemaPath:"#/properties/title/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs9 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.description !== undefined){
	const _errs11 = errors;
	if(typeof data.description !== "string"){
	validate10.errors = [{instancePath:instancePath+"/description",schemaPath:"#/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs11 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.readOnly !== undefined){
	const _errs13 = errors;
	if(typeof data.readOnly !== "boolean"){
	validate10.errors = [{instancePath:instancePath+"/readOnly",schemaPath:"#/properties/readOnly/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	var valid0 = _errs13 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.examples !== undefined){
	const _errs15 = errors;
	if(errors === _errs15){
	if(!(Array.isArray(data.examples))){
	validate10.errors = [{instancePath:instancePath+"/examples",schemaPath:"#/properties/examples/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs15 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.multipleOf !== undefined){
	let data8 = data.multipleOf;
	const _errs17 = errors;
	if(errors === _errs17){
	if((typeof data8 == "number") && (isFinite(data8))){
	if(data8 <= 0 || isNaN(data8)){
	validate10.errors = [{instancePath:instancePath+"/multipleOf",schemaPath:"#/properties/multipleOf/exclusiveMinimum",keyword:"exclusiveMinimum",params:{comparison: ">", limit: 0},message:"must be > 0"}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/multipleOf",schemaPath:"#/properties/multipleOf/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	}
	var valid0 = _errs17 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maximum !== undefined){
	let data9 = data.maximum;
	const _errs19 = errors;
	if(!((typeof data9 == "number") && (isFinite(data9)))){
	validate10.errors = [{instancePath:instancePath+"/maximum",schemaPath:"#/properties/maximum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs19 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.exclusiveMaximum !== undefined){
	let data10 = data.exclusiveMaximum;
	const _errs21 = errors;
	if(!((typeof data10 == "number") && (isFinite(data10)))){
	validate10.errors = [{instancePath:instancePath+"/exclusiveMaximum",schemaPath:"#/properties/exclusiveMaximum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs21 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minimum !== undefined){
	let data11 = data.minimum;
	const _errs23 = errors;
	if(!((typeof data11 == "number") && (isFinite(data11)))){
	validate10.errors = [{instancePath:instancePath+"/minimum",schemaPath:"#/properties/minimum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs23 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.exclusiveMinimum !== undefined){
	let data12 = data.exclusiveMinimum;
	const _errs25 = errors;
	if(!((typeof data12 == "number") && (isFinite(data12)))){
	validate10.errors = [{instancePath:instancePath+"/exclusiveMinimum",schemaPath:"#/properties/exclusiveMinimum/type",keyword:"type",params:{type: "number"},message:"must be number"}];
	return false;
	}
	var valid0 = _errs25 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxLength !== undefined){
	let data13 = data.maxLength;
	const _errs27 = errors;
	const _errs28 = errors;
	if(!(((typeof data13 == "number") && (!(data13 % 1) && !isNaN(data13))) && (isFinite(data13)))){
	validate10.errors = [{instancePath:instancePath+"/maxLength",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs28){
	if((typeof data13 == "number") && (isFinite(data13))){
	if(data13 < 0 || isNaN(data13)){
	validate10.errors = [{instancePath:instancePath+"/maxLength",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs27 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minLength !== undefined){
	const _errs30 = errors;
	if(!(validate11(data.minLength, {instancePath:instancePath+"/minLength",parentData:data,parentDataProperty:"minLength",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs30 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.pattern !== undefined){
	let data15 = data.pattern;
	const _errs31 = errors;
	if(errors === _errs31){
	if(errors === _errs31){
	if(typeof data15 === "string"){
	if(!(formats6(data15))){
	validate10.errors = [{instancePath:instancePath+"/pattern",schemaPath:"#/properties/pattern/format",keyword:"format",params:{format: "regex"},message:"must match format \""+"regex"+"\""}];
	return false;
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/pattern",schemaPath:"#/properties/pattern/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	}
	var valid0 = _errs31 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.additionalItems !== undefined){
	const _errs33 = errors;
	if(!(validate10(data.additionalItems, {instancePath:instancePath+"/additionalItems",parentData:data,parentDataProperty:"additionalItems",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs33 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.items !== undefined){
	let data17 = data.items;
	const _errs34 = errors;
	const _errs35 = errors;
	let valid2 = false;
	const _errs36 = errors;
	if(!(validate10(data17, {instancePath:instancePath+"/items",parentData:data,parentDataProperty:"items",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var _valid0 = _errs36 === errors;
	valid2 = valid2 || _valid0;
	if(!valid2){
	const _errs37 = errors;
	if(!(validate13(data17, {instancePath:instancePath+"/items",parentData:data,parentDataProperty:"items",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var _valid0 = _errs37 === errors;
	valid2 = valid2 || _valid0;
	}
	if(!valid2){
	const err0 = {instancePath:instancePath+"/items",schemaPath:"#/properties/items/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs35;
	if(vErrors !== null){
	if(_errs35){
	vErrors.length = _errs35;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs34 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxItems !== undefined){
	let data18 = data.maxItems;
	const _errs38 = errors;
	const _errs39 = errors;
	if(!(((typeof data18 == "number") && (!(data18 % 1) && !isNaN(data18))) && (isFinite(data18)))){
	validate10.errors = [{instancePath:instancePath+"/maxItems",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs39){
	if((typeof data18 == "number") && (isFinite(data18))){
	if(data18 < 0 || isNaN(data18)){
	validate10.errors = [{instancePath:instancePath+"/maxItems",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs38 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minItems !== undefined){
	const _errs41 = errors;
	if(!(validate11(data.minItems, {instancePath:instancePath+"/minItems",parentData:data,parentDataProperty:"minItems",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs41 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.uniqueItems !== undefined){
	const _errs42 = errors;
	if(typeof data.uniqueItems !== "boolean"){
	validate10.errors = [{instancePath:instancePath+"/uniqueItems",schemaPath:"#/properties/uniqueItems/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	var valid0 = _errs42 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contains !== undefined){
	const _errs44 = errors;
	if(!(validate10(data.contains, {instancePath:instancePath+"/contains",parentData:data,parentDataProperty:"contains",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs44 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.maxProperties !== undefined){
	let data22 = data.maxProperties;
	const _errs45 = errors;
	const _errs46 = errors;
	if(!(((typeof data22 == "number") && (!(data22 % 1) && !isNaN(data22))) && (isFinite(data22)))){
	validate10.errors = [{instancePath:instancePath+"/maxProperties",schemaPath:"#/definitions/nonNegativeInteger/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	if(errors === _errs46){
	if((typeof data22 == "number") && (isFinite(data22))){
	if(data22 < 0 || isNaN(data22)){
	validate10.errors = [{instancePath:instancePath+"/maxProperties",schemaPath:"#/definitions/nonNegativeInteger/minimum",keyword:"minimum",params:{comparison: ">=", limit: 0},message:"must be >= 0"}];
	return false;
	}
	}
	}
	var valid0 = _errs45 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.minProperties !== undefined){
	const _errs48 = errors;
	if(!(validate11(data.minProperties, {instancePath:instancePath+"/minProperties",parentData:data,parentDataProperty:"minProperties",rootData}))){
	vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs48 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.required !== undefined){
	let data24 = data.required;
	const _errs49 = errors;
	const _errs50 = errors;
	if(errors === _errs50){
	if(Array.isArray(data24)){
	var valid6 = true;
	const len0 = data24.length;
	for(let i0=0; i0<len0; i0++){
	const _errs52 = errors;
	if(typeof data24[i0] !== "string"){
	validate10.errors = [{instancePath:instancePath+"/required/" + i0,schemaPath:"#/definitions/stringArray/items/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid6 = _errs52 === errors;
	if(!valid6){
	break;
	}
	}
	if(valid6){
	let i1 = data24.length;
	let j0;
	if(i1 > 1){
	const indices0 = {};
	for(;i1--;){
	let item0 = data24[i1];
	if(typeof item0 !== "string"){
	continue;
	}
	if(typeof indices0[item0] == "number"){
	j0 = indices0[item0];
	validate10.errors = [{instancePath:instancePath+"/required",schemaPath:"#/definitions/stringArray/uniqueItems",keyword:"uniqueItems",params:{i: i1, j: j0},message:"must NOT have duplicate items (items ## "+j0+" and "+i1+" are identical)"}];
	return false;
	}
	indices0[item0] = i1;
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/required",schemaPath:"#/definitions/stringArray/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs49 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.additionalProperties !== undefined){
	const _errs54 = errors;
	if(!(validate10(data.additionalProperties, {instancePath:instancePath+"/additionalProperties",parentData:data,parentDataProperty:"additionalProperties",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs54 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.definitions !== undefined){
	let data27 = data.definitions;
	const _errs55 = errors;
	if(errors === _errs55){
	if(data27 && typeof data27 == "object" && !Array.isArray(data27)){
	for(const key0 in data27){
	const _errs58 = errors;
	if(!(validate10(data27[key0], {instancePath:instancePath+"/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data27,parentDataProperty:key0,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid8 = _errs58 === errors;
	if(!valid8){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/definitions",schemaPath:"#/properties/definitions/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs55 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.properties !== undefined){
	let data29 = data.properties;
	const _errs59 = errors;
	if(errors === _errs59){
	if(data29 && typeof data29 == "object" && !Array.isArray(data29)){
	for(const key1 in data29){
	const _errs62 = errors;
	if(!(validate10(data29[key1], {instancePath:instancePath+"/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data29,parentDataProperty:key1,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid9 = _errs62 === errors;
	if(!valid9){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/properties",schemaPath:"#/properties/properties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs59 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.patternProperties !== undefined){
	let data31 = data.patternProperties;
	const _errs63 = errors;
	if(errors === _errs63){
	if(data31 && typeof data31 == "object" && !Array.isArray(data31)){
	for(const key2 in data31){
	const _errs65 = errors;
	if(errors === _errs65){
	if(typeof key2 === "string"){
	if(!(formats6(key2))){
	const err1 = {instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/propertyNames/format",keyword:"format",params:{format: "regex"},message:"must match format \""+"regex"+"\"",propertyName:key2};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	}
	var valid10 = _errs65 === errors;
	if(!valid10){
	const err2 = {instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/propertyNames",keyword:"propertyNames",params:{propertyName: key2},message:"property name must be valid"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	}
	if(valid10){
	for(const key3 in data31){
	const _errs67 = errors;
	if(!(validate10(data31[key3], {instancePath:instancePath+"/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data31,parentDataProperty:key3,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid11 = _errs67 === errors;
	if(!valid11){
	break;
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/patternProperties",schemaPath:"#/properties/patternProperties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs63 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.dependencies !== undefined){
	let data33 = data.dependencies;
	const _errs68 = errors;
	if(errors === _errs68){
	if(data33 && typeof data33 == "object" && !Array.isArray(data33)){
	for(const key4 in data33){
	let data34 = data33[key4];
	const _errs71 = errors;
	const _errs72 = errors;
	let valid13 = false;
	const _errs73 = errors;
	if(!(validate10(data34, {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),parentData:data33,parentDataProperty:key4,rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var _valid1 = _errs73 === errors;
	valid13 = valid13 || _valid1;
	if(!valid13){
	const _errs74 = errors;
	const _errs75 = errors;
	if(errors === _errs75){
	if(Array.isArray(data34)){
	var valid15 = true;
	const len1 = data34.length;
	for(let i2=0; i2<len1; i2++){
	const _errs77 = errors;
	if(typeof data34[i2] !== "string"){
	const err3 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1")+"/" + i2,schemaPath:"#/definitions/stringArray/items/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	}
	var valid15 = _errs77 === errors;
	if(!valid15){
	break;
	}
	}
	if(valid15){
	let i3 = data34.length;
	let j1;
	if(i3 > 1){
	const indices1 = {};
	for(;i3--;){
	let item1 = data34[i3];
	if(typeof item1 !== "string"){
	continue;
	}
	if(typeof indices1[item1] == "number"){
	j1 = indices1[item1];
	const err4 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/definitions/stringArray/uniqueItems",keyword:"uniqueItems",params:{i: i3, j: j1},message:"must NOT have duplicate items (items ## "+j1+" and "+i3+" are identical)"};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	break;
	}
	indices1[item1] = i3;
	}
	}
	}
	}
	else {
	const err5 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/definitions/stringArray/type",keyword:"type",params:{type: "array"},message:"must be array"};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	var _valid1 = _errs74 === errors;
	valid13 = valid13 || _valid1;
	}
	if(!valid13){
	const err6 = {instancePath:instancePath+"/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/dependencies/additionalProperties/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs72;
	if(vErrors !== null){
	if(_errs72){
	vErrors.length = _errs72;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid12 = _errs71 === errors;
	if(!valid12){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/dependencies",schemaPath:"#/properties/dependencies/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs68 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.propertyNames !== undefined){
	const _errs79 = errors;
	if(!(validate10(data.propertyNames, {instancePath:instancePath+"/propertyNames",parentData:data,parentDataProperty:"propertyNames",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs79 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.enum !== undefined){
	let data37 = data.enum;
	const _errs80 = errors;
	if(errors === _errs80){
	if(Array.isArray(data37)){
	if(data37.length < 1){
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"}];
	return false;
	}
	else {
	let i4 = data37.length;
	let j2;
	if(i4 > 1){
	for(;i4--;){
	for(j2 = i4; j2--;){
	if(func0(data37[i4], data37[j2])){
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/uniqueItems",keyword:"uniqueItems",params:{i: i4, j: j2},message:"must NOT have duplicate items (items ## "+j2+" and "+i4+" are identical)"}];
	return false;
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/enum",schemaPath:"#/properties/enum/type",keyword:"type",params:{type: "array"},message:"must be array"}];
	return false;
	}
	}
	var valid0 = _errs80 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.type !== undefined){
	let data38 = data.type;
	const _errs82 = errors;
	const _errs83 = errors;
	let valid18 = false;
	const _errs84 = errors;
	if(!(((((((data38 === "array") || (data38 === "boolean")) || (data38 === "integer")) || (data38 === "null")) || (data38 === "number")) || (data38 === "object")) || (data38 === "string"))){
	const err7 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/simpleTypes/enum",keyword:"enum",params:{allowedValues: schema20.enum},message:"must be equal to one of the allowed values"};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	var _valid2 = _errs84 === errors;
	valid18 = valid18 || _valid2;
	if(!valid18){
	const _errs86 = errors;
	if(errors === _errs86){
	if(Array.isArray(data38)){
	if(data38.length < 1){
	const err8 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	else {
	var valid20 = true;
	const len2 = data38.length;
	for(let i5=0; i5<len2; i5++){
	let data39 = data38[i5];
	const _errs88 = errors;
	if(!(((((((data39 === "array") || (data39 === "boolean")) || (data39 === "integer")) || (data39 === "null")) || (data39 === "number")) || (data39 === "object")) || (data39 === "string"))){
	const err9 = {instancePath:instancePath+"/type/" + i5,schemaPath:"#/definitions/simpleTypes/enum",keyword:"enum",params:{allowedValues: schema20.enum},message:"must be equal to one of the allowed values"};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	}
	var valid20 = _errs88 === errors;
	if(!valid20){
	break;
	}
	}
	if(valid20){
	let i6 = data38.length;
	let j3;
	if(i6 > 1){
	outer1:
	for(;i6--;){
	for(j3 = i6; j3--;){
	if(func0(data38[i6], data38[j3])){
	const err10 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/uniqueItems",keyword:"uniqueItems",params:{i: i6, j: j3},message:"must NOT have duplicate items (items ## "+j3+" and "+i6+" are identical)"};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	break outer1;
	}
	}
	}
	}
	}
	}
	}
	else {
	const err11 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf/1/type",keyword:"type",params:{type: "array"},message:"must be array"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	}
	}
	var _valid2 = _errs86 === errors;
	valid18 = valid18 || _valid2;
	}
	if(!valid18){
	const err12 = {instancePath:instancePath+"/type",schemaPath:"#/properties/type/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs83;
	if(vErrors !== null){
	if(_errs83){
	vErrors.length = _errs83;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs82 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.format !== undefined){
	const _errs90 = errors;
	if(typeof data.format !== "string"){
	validate10.errors = [{instancePath:instancePath+"/format",schemaPath:"#/properties/format/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs90 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contentMediaType !== undefined){
	const _errs92 = errors;
	if(typeof data.contentMediaType !== "string"){
	validate10.errors = [{instancePath:instancePath+"/contentMediaType",schemaPath:"#/properties/contentMediaType/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs92 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.contentEncoding !== undefined){
	const _errs94 = errors;
	if(typeof data.contentEncoding !== "string"){
	validate10.errors = [{instancePath:instancePath+"/contentEncoding",schemaPath:"#/properties/contentEncoding/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	var valid0 = _errs94 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.if !== undefined){
	const _errs96 = errors;
	if(!(validate10(data.if, {instancePath:instancePath+"/if",parentData:data,parentDataProperty:"if",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs96 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.then !== undefined){
	const _errs97 = errors;
	if(!(validate10(data.then, {instancePath:instancePath+"/then",parentData:data,parentDataProperty:"then",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs97 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.else !== undefined){
	const _errs98 = errors;
	if(!(validate10(data.else, {instancePath:instancePath+"/else",parentData:data,parentDataProperty:"else",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs98 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.allOf !== undefined){
	const _errs99 = errors;
	if(!(validate13(data.allOf, {instancePath:instancePath+"/allOf",parentData:data,parentDataProperty:"allOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs99 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.anyOf !== undefined){
	const _errs100 = errors;
	if(!(validate13(data.anyOf, {instancePath:instancePath+"/anyOf",parentData:data,parentDataProperty:"anyOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs100 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.oneOf !== undefined){
	const _errs101 = errors;
	if(!(validate13(data.oneOf, {instancePath:instancePath+"/oneOf",parentData:data,parentDataProperty:"oneOf",rootData}))){
	vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs101 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.not !== undefined){
	const _errs102 = errors;
	if(!(validate10(data.not, {instancePath:instancePath+"/not",parentData:data,parentDataProperty:"not",rootData}))){
	vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
	errors = vErrors.length;
	}
	var valid0 = _errs102 === errors;
	}
	else {
	var valid0 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}
	return schemaValidator.exports;
}

var errors$1;
var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;

	class MergeError extends Error {
	  constructor (keyword, schemas) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Failed to merge "${keyword}" keyword schemas.`;
	    this.schemas = schemas;
	  }
	}

	class ResolverNotFoundError extends Error {
	  constructor (keyword, schemas) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Resolver for "${keyword}" keyword not found.`;
	    this.schemas = schemas;
	  }
	}

	class InvalidOnConflictOptionError extends Error {
	  constructor (onConflict) {
	    super();
	    this.name = 'JsonSchemaMergeError';
	    this.code = 'JSON_SCHEMA_MERGE_ERROR';
	    this.message = `Invalid "onConflict" option: "${onConflict}".`;
	  }
	}

	errors$1 = {
	  MergeError,
	  ResolverNotFoundError,
	  InvalidOnConflictOptionError
	};
	return errors$1;
}

var resolvers;
var hasRequiredResolvers;

function requireResolvers () {
	if (hasRequiredResolvers) return resolvers;
	hasRequiredResolvers = 1;

	const { dequal: deepEqual } = requireDist$4();
	const { MergeError } = requireErrors$1();

	function _arraysIntersection (arrays) {
	  let intersection = arrays[0];
	  for (let i = 1; i < arrays.length; i++) {
	    intersection = intersection.filter(
	      value => arrays[i].includes(value)
	    );
	  }
	  return intersection
	}

	function arraysIntersection (keyword, values, mergedSchema) {
	  const intersection = _arraysIntersection(values);
	  if (intersection.length === 0) {
	    throw new MergeError(keyword, values)
	  }
	  mergedSchema[keyword] = intersection;
	}

	function hybridArraysIntersection (keyword, values, mergedSchema) {
	  for (let i = 0; i < values.length; i++) {
	    if (!Array.isArray(values[i])) {
	      values[i] = [values[i]];
	    }
	  }

	  const intersection = _arraysIntersection(values);
	  if (intersection.length === 0) {
	    throw new MergeError(keyword, values)
	  }

	  if (intersection.length === 1) {
	    mergedSchema[keyword] = intersection[0];
	  } else {
	    mergedSchema[keyword] = intersection;
	  }
	}

	function arraysUnion (keyword, values, mergedSchema) {
	  const union = [];

	  for (const array of values) {
	    for (const value of array) {
	      if (!union.includes(value)) {
	        union.push(value);
	      }
	    }
	  }

	  mergedSchema[keyword] = union;
	}

	function minNumber (keyword, values, mergedSchema) {
	  mergedSchema[keyword] = Math.min(...values);
	}

	function maxNumber (keyword, values, mergedSchema) {
	  mergedSchema[keyword] = Math.max(...values);
	}

	function commonMultiple (keyword, values, mergedSchema) {
	  const gcd = (a, b) => (!b ? a : gcd(b, a % b));
	  const lcm = (a, b) => (a * b) / gcd(a, b);

	  let scale = 1;
	  for (const value of values) {
	    while (value * scale % 1 !== 0) {
	      scale *= 10;
	    }
	  }

	  let multiple = values[0] * scale;
	  for (const value of values) {
	    multiple = lcm(multiple, value * scale);
	  }

	  mergedSchema[keyword] = multiple / scale;
	}

	function allEqual (keyword, values, mergedSchema) {
	  const firstValue = values[0];
	  for (let i = 1; i < values.length; i++) {
	    if (!deepEqual(values[i], firstValue)) {
	      throw new MergeError(keyword, values)
	    }
	  }
	  mergedSchema[keyword] = firstValue;
	}

	function skip () {}

	function booleanAnd (keyword, values, mergedSchema) {
	  for (const value of values) {
	    if (value === false) {
	      mergedSchema[keyword] = false;
	      return
	    }
	  }
	  mergedSchema[keyword] = true;
	}

	function booleanOr (keyword, values, mergedSchema) {
	  for (const value of values) {
	    if (value === true) {
	      mergedSchema[keyword] = true;
	      return
	    }
	  }
	  mergedSchema[keyword] = false;
	}

	resolvers = {
	  arraysIntersection,
	  hybridArraysIntersection,
	  arraysUnion,
	  minNumber,
	  maxNumber,
	  commonMultiple,
	  allEqual,
	  booleanAnd,
	  booleanOr,
	  skip
	};
	return resolvers;
}

var mergeJsonSchemas;
var hasRequiredMergeJsonSchemas;

function requireMergeJsonSchemas () {
	if (hasRequiredMergeJsonSchemas) return mergeJsonSchemas;
	hasRequiredMergeJsonSchemas = 1;

	const { dequal: deepEqual } = requireDist$4();
	const resolvers = requireResolvers();
	const errors = requireErrors$1();

	const keywordsResolvers = {
	  $id: resolvers.skip,
	  type: resolvers.hybridArraysIntersection,
	  enum: resolvers.arraysIntersection,
	  minLength: resolvers.maxNumber,
	  maxLength: resolvers.minNumber,
	  minimum: resolvers.maxNumber,
	  maximum: resolvers.minNumber,
	  multipleOf: resolvers.commonMultiple,
	  exclusiveMinimum: resolvers.maxNumber,
	  exclusiveMaximum: resolvers.minNumber,
	  minItems: resolvers.maxNumber,
	  maxItems: resolvers.minNumber,
	  maxProperties: resolvers.minNumber,
	  minProperties: resolvers.maxNumber,
	  const: resolvers.allEqual,
	  default: resolvers.allEqual,
	  format: resolvers.allEqual,
	  required: resolvers.arraysUnion,
	  properties: mergeProperties,
	  patternProperties: mergeObjects,
	  additionalProperties: mergeSchemasResolver,
	  items: mergeItems,
	  additionalItems: mergeAdditionalItems,
	  definitions: mergeObjects,
	  $defs: mergeObjects,
	  nullable: resolvers.booleanAnd,
	  oneOf: mergeOneOf,
	  anyOf: mergeOneOf,
	  allOf: resolvers.arraysUnion,
	  not: mergeSchemasResolver,
	  if: mergeIfThenElseSchemas,
	  then: resolvers.skip,
	  else: resolvers.skip,
	  dependencies: mergeDependencies,
	  dependentRequired: mergeDependencies,
	  dependentSchemas: mergeObjects,
	  propertyNames: mergeSchemasResolver,
	  uniqueItems: resolvers.booleanOr,
	  contains: mergeSchemasResolver
	};

	function mergeSchemasResolver (keyword, values, mergedSchema, _schemas, options) {
	  mergedSchema[keyword] = _mergeSchemas(values, options);
	}

	function cartesianProduct (arrays) {
	  let result = [[]];

	  for (const array of arrays) {
	    const temp = [];
	    for (const x of result) {
	      for (const y of array) {
	        temp.push([...x, y]);
	      }
	    }
	    result = temp;
	  }

	  return result
	}

	function mergeOneOf (keyword, values, mergedSchema, _schemas, options) {
	  if (values.length === 1) {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  const product = cartesianProduct(values);
	  const mergedOneOf = [];
	  for (const combination of product) {
	    try {
	      const mergedSchema = _mergeSchemas(combination, options);
	      if (mergedSchema !== undefined) {
	        mergedOneOf.push(mergedSchema);
	      }
	    } catch (error) {
	      // If this combination is not valid, we can ignore it.
	      if (error instanceof errors.MergeError) continue
	      throw error
	    }
	  }
	  mergedSchema[keyword] = mergedOneOf;
	}

	function getSchemaForItem (schema, index) {
	  const { items, additionalItems } = schema;

	  if (Array.isArray(items)) {
	    if (index < items.length) {
	      return items[index]
	    }
	    return additionalItems
	  }

	  if (items !== undefined) {
	    return items
	  }

	  return additionalItems
	}

	function mergeItems (keyword, values, mergedSchema, schemas, options) {
	  let maxArrayItemsLength = 0;
	  for (const itemsSchema of values) {
	    if (Array.isArray(itemsSchema)) {
	      maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
	    }
	  }

	  if (maxArrayItemsLength === 0) {
	    mergedSchema[keyword] = _mergeSchemas(values, options);
	    return
	  }

	  const mergedItemsSchemas = [];
	  for (let i = 0; i < maxArrayItemsLength; i++) {
	    const indexItemSchemas = [];
	    for (const schema of schemas) {
	      const itemSchema = getSchemaForItem(schema, i);
	      if (itemSchema !== undefined) {
	        indexItemSchemas.push(itemSchema);
	      }
	    }
	    mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
	  }
	  mergedSchema[keyword] = mergedItemsSchemas;
	}

	function mergeAdditionalItems (keyword, values, mergedSchema, schemas, options) {
	  let hasArrayItems = false;
	  for (const schema of schemas) {
	    if (Array.isArray(schema.items)) {
	      hasArrayItems = true;
	      break
	    }
	  }

	  if (!hasArrayItems) {
	    mergedSchema[keyword] = _mergeSchemas(values, options);
	    return
	  }

	  const mergedAdditionalItemsSchemas = [];
	  for (const schema of schemas) {
	    let additionalItemsSchema = schema.additionalItems;
	    if (
	      additionalItemsSchema === undefined &&
	      !Array.isArray(schema.items)
	    ) {
	      additionalItemsSchema = schema.items;
	    }
	    if (additionalItemsSchema !== undefined) {
	      mergedAdditionalItemsSchemas.push(additionalItemsSchema);
	    }
	  }

	  mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
	}

	function getSchemaForProperty (schema, propertyName) {
	  const { properties, patternProperties, additionalProperties } = schema;

	  if (properties?.[propertyName] !== undefined) {
	    return properties[propertyName]
	  }

	  for (const pattern of Object.keys(patternProperties ?? {})) {
	    const regexp = new RegExp(pattern);
	    if (regexp.test(propertyName)) {
	      return patternProperties[pattern]
	    }
	  }

	  return additionalProperties
	}

	function mergeProperties (keyword, _values, mergedSchema, schemas, options) {
	  const foundProperties = {};
	  for (const currentSchema of schemas) {
	    const properties = currentSchema.properties ?? {};
	    for (const propertyName of Object.keys(properties)) {
	      if (foundProperties[propertyName] !== undefined) continue

	      const propertySchema = properties[propertyName];
	      foundProperties[propertyName] = [propertySchema];

	      for (const anotherSchema of schemas) {
	        if (currentSchema === anotherSchema) continue

	        const propertySchema = getSchemaForProperty(anotherSchema, propertyName);
	        if (propertySchema !== undefined) {
	          foundProperties[propertyName].push(propertySchema);
	        }
	      }
	    }
	  }

	  const mergedProperties = {};
	  for (const property of Object.keys(foundProperties)) {
	    const propertySchemas = foundProperties[property];
	    mergedProperties[property] = _mergeSchemas(propertySchemas, options);
	  }
	  mergedSchema[keyword] = mergedProperties;
	}

	function mergeObjects (keyword, values, mergedSchema, _schemas, options) {
	  const objectsProperties = {};

	  for (const properties of values) {
	    for (const propertyName of Object.keys(properties)) {
	      if (objectsProperties[propertyName] === undefined) {
	        objectsProperties[propertyName] = [];
	      }
	      objectsProperties[propertyName].push(properties[propertyName]);
	    }
	  }

	  const mergedProperties = {};
	  for (const propertyName of Object.keys(objectsProperties)) {
	    const propertySchemas = objectsProperties[propertyName];
	    const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
	    mergedProperties[propertyName] = mergedPropertySchema;
	  }

	  mergedSchema[keyword] = mergedProperties;
	}

	function mergeIfThenElseSchemas (_keyword, _values, mergedSchema, schemas, options) {
	  for (let i = 0; i < schemas.length; i++) {
	    const subSchema = {
	      if: schemas[i].if,
	      then: schemas[i].then,
	      else: schemas[i].else
	    };

	    if (subSchema.if === undefined) continue

	    if (mergedSchema.if === undefined) {
	      mergedSchema.if = subSchema.if;
	      if (subSchema.then !== undefined) {
	        mergedSchema.then = subSchema.then;
	      }
	      if (subSchema.else !== undefined) {
	        mergedSchema.else = subSchema.else;
	      }
	      continue
	    }

	    if (mergedSchema.then !== undefined) {
	      mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
	    }
	    if (mergedSchema.else !== undefined) {
	      mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
	    }
	  }
	}

	function mergeDependencies (keyword, values, mergedSchema) {
	  const mergedDependencies = {};
	  for (const dependencies of values) {
	    for (const propertyName of Object.keys(dependencies)) {
	      if (mergedDependencies[propertyName] === undefined) {
	        mergedDependencies[propertyName] = [];
	      }
	      const mergedPropertyDependencies = mergedDependencies[propertyName];
	      for (const propertyDependency of dependencies[propertyName]) {
	        if (!mergedPropertyDependencies.includes(propertyDependency)) {
	          mergedPropertyDependencies.push(propertyDependency);
	        }
	      }
	    }
	  }
	  mergedSchema[keyword] = mergedDependencies;
	}

	function _mergeSchemas (schemas, options) {
	  if (schemas.length === 0) return {}
	  if (schemas.length === 1) return schemas[0]

	  const mergedSchema = {};
	  const keywords = {};

	  let allSchemasAreTrue = true;

	  for (const schema of schemas) {
	    if (schema === false) return false
	    if (schema === true) continue
	    allSchemasAreTrue = false;

	    for (const keyword of Object.keys(schema)) {
	      if (keywords[keyword] === undefined) {
	        keywords[keyword] = [];
	      }
	      keywords[keyword].push(schema[keyword]);
	    }
	  }

	  if (allSchemasAreTrue) return true

	  for (const keyword of Object.keys(keywords)) {
	    const keywordValues = keywords[keyword];
	    const resolver = options.resolvers[keyword] ?? options.defaultResolver;
	    resolver(keyword, keywordValues, mergedSchema, schemas, options);
	  }

	  return mergedSchema
	}

	function defaultResolver (keyword, values, mergedSchema, _schemas, options) {
	  const onConflict = options.onConflict ?? 'throw';

	  if (values.length === 1 || onConflict === 'first') {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  let allValuesEqual = true;
	  for (let i = 1; i < values.length; i++) {
	    if (!deepEqual(values[i], values[0])) {
	      allValuesEqual = false;
	      break
	    }
	  }

	  if (allValuesEqual) {
	    mergedSchema[keyword] = values[0];
	    return
	  }

	  if (onConflict === 'throw') {
	    throw new errors.ResolverNotFoundError(keyword, values)
	  }
	  if (onConflict === 'skip') {
	    return
	  }
	  throw new errors.InvalidOnConflictOptionError(onConflict)
	}

	function mergeSchemas (schemas, options = {}) {
	  if (options.defaultResolver === undefined) {
	    options.defaultResolver = defaultResolver;
	  }

	  options.resolvers = { ...keywordsResolvers, ...options.resolvers };

	  const mergedSchema = _mergeSchemas(schemas, options);
	  return mergedSchema
	}

	mergeJsonSchemas = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
	return mergeJsonSchemas;
}

var mergeSchemas_1;
var hasRequiredMergeSchemas;

function requireMergeSchemas () {
	if (hasRequiredMergeSchemas) return mergeSchemas_1;
	hasRequiredMergeSchemas = 1;

	const { mergeSchemas: _mergeSchemas } = requireMergeJsonSchemas();

	function mergeSchemas (schemas) {
	  return _mergeSchemas(schemas, { onConflict: 'skip' })
	}

	mergeSchemas_1 = mergeSchemas;
	return mergeSchemas_1;
}

var standalone$2 = {exports: {}};

var hasRequiredStandalone$3;

function requireStandalone$3 () {
	if (hasRequiredStandalone$3) return standalone$2.exports;
	hasRequiredStandalone$3 = 1;

	function buildStandaloneCode (contextFunc, context, serializer, validator) {
	  let ajvDependencyCode = '';
	  if (context.validatorSchemasIds.size > 0) {
	    ajvDependencyCode += 'const Validator = require(\'fast-json-stringify/lib/validator\')\n';
	    ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}\n`;
	    ajvDependencyCode += 'const validator = Validator.restoreFromState(validatorState)\n';
	  } else {
	    ajvDependencyCode += 'const validator = null\n';
	  }

	  // Don't need to keep external schemas once compiled
	  // validatorState will hold external schemas if it needs them
	  const { schema, ...serializerState } = serializer.getState();

	  return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`
	}

	standalone$2.exports = buildStandaloneCode;

	standalone$2.exports.dependencies = {
	  Serializer: requireSerializer(),
	  Validator: requireValidator()
	};
	return standalone$2.exports;
}

var hasRequiredFastJsonStringify;

function requireFastJsonStringify () {
	if (hasRequiredFastJsonStringify) return fastJsonStringify.exports;
	hasRequiredFastJsonStringify = 1;

	/* eslint no-prototype-builtins: 0 */

	const { RefResolver } = requireJsonSchemaRefResolver();

	const Serializer = requireSerializer();
	const Validator = requireValidator();
	const Location = requireLocation();
	const validate = requireSchemaValidator();
	const mergeSchemas = requireMergeSchemas();

	const SINGLE_TICK = /'/g;

	let largeArraySize = 2e4;
	let largeArrayMechanism = 'default';

	const validRoundingMethods = [
	  'floor',
	  'ceil',
	  'round',
	  'trunc'
	];

	const validLargeArrayMechanisms = [
	  'default',
	  'json-stringify'
	];

	let schemaIdCounter = 0;

	function isValidSchema (schema, name) {
	  if (!validate(schema)) {
	    if (name) {
	      name = `"${name}" `;
	    } else {
	      name = '';
	    }
	    const first = validate.errors[0];
	    const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
	    err.errors = isValidSchema.errors;
	    throw err
	  }
	}

	function resolveRef (context, location) {
	  const ref = location.schema.$ref;

	  let hashIndex = ref.indexOf('#');
	  if (hashIndex === -1) {
	    hashIndex = ref.length;
	  }

	  const schemaId = ref.slice(0, hashIndex) || location.schemaId;
	  const jsonPointer = ref.slice(hashIndex) || '#';

	  const schema = context.refResolver.getSchema(schemaId, jsonPointer);
	  if (schema === null) {
	    throw new Error(`Cannot find reference "${ref}"`)
	  }

	  const newLocation = new Location(schema, schemaId, jsonPointer);
	  if (schema.$ref !== undefined) {
	    return resolveRef(context, newLocation)
	  }

	  return newLocation
	}

	function getMergedLocation (context, mergedSchemaId) {
	  const mergedSchema = context.refResolver.getSchema(mergedSchemaId, '#');
	  return new Location(mergedSchema, mergedSchemaId, '#')
	}

	function getSchemaId (schema, rootSchemaId) {
	  if (schema.$id && schema.$id.charAt(0) !== '#') {
	    return schema.$id
	  }
	  return rootSchemaId
	}

	function build (schema, options) {
	  isValidSchema(schema);

	  options = options || {};

	  const context = {
	    functions: [],
	    functionsCounter: 0,
	    functionsNamesBySchema: new Map(),
	    options,
	    refResolver: new RefResolver(),
	    rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
	    validatorSchemasIds: new Set(),
	    mergedSchemasIds: new Map()
	  };

	  const schemaId = getSchemaId(schema, context.rootSchemaId);
	  if (!context.refResolver.hasSchema(schemaId)) {
	    context.refResolver.addSchema(schema, context.rootSchemaId);
	  }

	  if (options.schema) {
	    for (const key in options.schema) {
	      const schema = options.schema[key];
	      const schemaId = getSchemaId(schema, key);
	      if (!context.refResolver.hasSchema(schemaId)) {
	        isValidSchema(schema, key);
	        context.refResolver.addSchema(schema, key);
	      }
	    }
	  }

	  if (options.rounding) {
	    if (!validRoundingMethods.includes(options.rounding)) {
	      throw new Error(`Unsupported integer rounding method ${options.rounding}`)
	    }
	  }

	  if (options.largeArrayMechanism) {
	    if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
	      largeArrayMechanism = options.largeArrayMechanism;
	    } else {
	      throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`)
	    }
	  }

	  if (options.largeArraySize) {
	    if (typeof options.largeArraySize === 'string' && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
	      largeArraySize = Number.parseInt(options.largeArraySize, 10);
	    } else if (typeof options.largeArraySize === 'number' && Number.isInteger(options.largeArraySize)) {
	      largeArraySize = options.largeArraySize;
	    } else if (typeof options.largeArraySize === 'bigint') {
	      largeArraySize = Number(options.largeArraySize);
	    } else {
	      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`)
	    }
	  }

	  const location = new Location(schema, context.rootSchemaId);
	  const code = buildValue(context, location, 'input');

	  let contextFunctionCode = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;

	  // If we have only the invocation of the 'anonymous0' function, we would
	  // basically just wrap the 'anonymous0' function in the 'main' function and
	  // and the overhead of the intermediate variable 'json'. We can avoid the
	  // wrapping and the unnecessary memory allocation by aliasing 'anonymous0' to
	  // 'main'
	  if (code === 'json += anonymous0(input)') {
	    contextFunctionCode += `
    ${context.functions.join('\n')}
    const main = anonymous0
    return main
    `;
	  } else {
	    contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join('\n')}
    return main
    `;
	  }

	  const serializer = new Serializer(options);
	  const validator = new Validator(options.ajv);

	  for (const schemaId of context.validatorSchemasIds) {
	    const schema = context.refResolver.getSchema(schemaId);
	    validator.addSchema(schema, schemaId);

	    const dependencies = context.refResolver.getSchemaDependencies(schemaId);
	    for (const [schemaId, schema] of Object.entries(dependencies)) {
	      validator.addSchema(schema, schemaId);
	    }
	  }

	  if (options.debugMode) {
	    options.mode = 'debug';
	  }

	  if (options.mode === 'debug') {
	    return {
	      validator,
	      serializer,
	      code: `validator\nserializer\n${contextFunctionCode}`,
	      ajv: validator.ajv
	    }
	  }

	  /* eslint no-new-func: "off" */
	  const contextFunc = new Function('validator', 'serializer', contextFunctionCode);

	  if (options.mode === 'standalone') {
	    const buildStandaloneCode = requireStandalone$3();
	    return buildStandaloneCode(contextFunc, context, serializer, validator)
	  }

	  return contextFunc(validator, serializer)
	}

	const objectKeywords = [
	  'properties',
	  'required',
	  'additionalProperties',
	  'patternProperties',
	  'maxProperties',
	  'minProperties',
	  'dependencies'
	];

	const arrayKeywords = [
	  'items',
	  'additionalItems',
	  'maxItems',
	  'minItems',
	  'uniqueItems',
	  'contains'
	];

	const stringKeywords = [
	  'maxLength',
	  'minLength',
	  'pattern'
	];

	const numberKeywords = [
	  'multipleOf',
	  'maximum',
	  'exclusiveMaximum',
	  'minimum',
	  'exclusiveMinimum'
	];

	/**
	 * Infer type based on keyword in order to generate optimized code
	 * https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6
	 */
	function inferTypeByKeyword (schema) {
	  for (const keyword of objectKeywords) {
	    if (keyword in schema) return 'object'
	  }
	  for (const keyword of arrayKeywords) {
	    if (keyword in schema) return 'array'
	  }
	  for (const keyword of stringKeywords) {
	    if (keyword in schema) return 'string'
	  }
	  for (const keyword of numberKeywords) {
	    if (keyword in schema) return 'number'
	  }
	  return schema.type
	}

	function buildExtraObjectPropertiesSerializer (context, location, addComma) {
	  const schema = location.schema;
	  const propertiesKeys = Object.keys(schema.properties || {});

	  let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;

	  const patternPropertiesLocation = location.getPropertyLocation('patternProperties');
	  const patternPropertiesSchema = patternPropertiesLocation.schema;

	  if (patternPropertiesSchema !== undefined) {
	    for (const propertyKey in patternPropertiesSchema) {
	      const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);

	      code += `
        if (/${propertyKey.replace(/\\*\//g, '\\/')}/.test(key)) {
          ${addComma}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, 'value')}
          continue
        }
      `;
	    }
	  }

	  const additionalPropertiesLocation = location.getPropertyLocation('additionalProperties');
	  const additionalPropertiesSchema = additionalPropertiesLocation.schema;

	  if (additionalPropertiesSchema !== undefined) {
	    if (additionalPropertiesSchema === true) {
	      code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
	    } else {
	      const propertyLocation = location.getPropertyLocation('additionalProperties');
	      code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, 'value')}
      `;
	    }
	  }

	  code += `
    }
  `;
	  return code
	}

	function buildInnerObject (context, location) {
	  const schema = location.schema;

	  const propertiesLocation = location.getPropertyLocation('properties');
	  const requiredProperties = schema.required || [];

	  // Should serialize required properties first
	  const propertiesKeys = Object.keys(schema.properties || {}).sort(
	    (key1, key2) => {
	      const required1 = requiredProperties.includes(key1);
	      const required2 = requiredProperties.includes(key2);
	      return required1 === required2 ? 0 : required1 ? -1 : 1
	    }
	  );
	  const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);

	  let code = 'let value\n';

	  for (const key of requiredProperties) {
	    if (!propertiesKeys.includes(key)) {
	      const sanitizedKey = JSON.stringify(key);
	      code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, '\\\'')} is required!')\n`;
	    }
	  }

	  code += 'let json = JSON_STR_BEGIN_OBJECT\n';

	  let addComma = '';
	  if (!hasRequiredProperties) {
	    code += 'let addComma = false\n';
	    addComma = '!addComma && (addComma = true) || (json += JSON_STR_COMMA)';
	  }

	  for (const key of propertiesKeys) {
	    let propertyLocation = propertiesLocation.getPropertyLocation(key);
	    if (propertyLocation.schema.$ref) {
	      propertyLocation = resolveRef(context, propertyLocation);
	    }

	    const sanitizedKey = JSON.stringify(key);
	    const defaultValue = propertyLocation.schema.default;
	    const isRequired = requiredProperties.includes(key);

	    code += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ':')}
        ${buildValue(context, propertyLocation, 'value')}
      }`;

	    if (defaultValue !== undefined) {
	      code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ':' + JSON.stringify(defaultValue))}
      }
      `;
	    } else if (isRequired) {
	      code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, '\\\'')} is required!')
      }
      `;
	    } else {
	      code += '\n';
	    }

	    if (hasRequiredProperties) {
	      addComma = 'json += \',\'';
	    }
	  }

	  if (schema.patternProperties || schema.additionalProperties) {
	    code += buildExtraObjectPropertiesSerializer(context, location, addComma);
	  }

	  code += `
    return json + JSON_STR_END_OBJECT
  `;
	  return code
	}

	function mergeLocations (context, mergedSchemaId, mergedLocations) {
	  for (let i = 0; i < mergedLocations.length; i++) {
	    const location = mergedLocations[i];
	    const schema = location.schema;
	    if (schema.$ref) {
	      mergedLocations[i] = resolveRef(context, location);
	    }
	  }

	  const mergedSchemas = [];
	  for (const location of mergedLocations) {
	    const schema = cloneOriginSchema(context, location.schema, location.schemaId);
	    delete schema.$id;

	    mergedSchemas.push(schema);
	  }

	  const mergedSchema = mergeSchemas(mergedSchemas);
	  const mergedLocation = new Location(mergedSchema, mergedSchemaId);

	  context.refResolver.addSchema(mergedSchema, mergedSchemaId);
	  return mergedLocation
	}

	function cloneOriginSchema (context, schema, schemaId) {
	  const clonedSchema = Array.isArray(schema) ? [] : {};

	  if (
	    schema.$id !== undefined &&
	    schema.$id.charAt(0) !== '#'
	  ) {
	    schemaId = schema.$id;
	  }

	  const mergedSchemaRef = context.mergedSchemasIds.get(schema);
	  if (mergedSchemaRef) {
	    context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
	  }

	  for (const key in schema) {
	    let value = schema[key];

	    if (key === '$ref' && typeof value === 'string' && value.charAt(0) === '#') {
	      value = schemaId + value;
	    }

	    if (typeof value === 'object' && value !== null) {
	      value = cloneOriginSchema(context, value, schemaId);
	    }

	    clonedSchema[key] = value;
	  }

	  return clonedSchema
	}

	function toJSON (variableName) {
	  return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `
	}

	function buildObject (context, location) {
	  const schema = location.schema;

	  if (context.functionsNamesBySchema.has(schema)) {
	    return context.functionsNamesBySchema.get(schema)
	  }

	  const functionName = generateFuncName(context);
	  context.functionsNamesBySchema.set(schema, functionName);

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  let functionCode = `
  `;

	  const nullable = schema.nullable === true;
	  functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON('input')}
      ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_OBJECT' : ''}

      ${buildInnerObject(context, location)}
    }
  `;

	  context.functions.push(functionCode);
	  return functionName
	}

	function buildArray (context, location) {
	  const schema = location.schema;

	  let itemsLocation = location.getPropertyLocation('items');
	  itemsLocation.schema = itemsLocation.schema || {};

	  if (itemsLocation.schema.$ref) {
	    itemsLocation = resolveRef(context, itemsLocation);
	  }

	  const itemsSchema = itemsLocation.schema;

	  if (context.functionsNamesBySchema.has(schema)) {
	    return context.functionsNamesBySchema.get(schema)
	  }

	  const functionName = generateFuncName(context);
	  context.functionsNamesBySchema.set(schema, functionName);

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;

	  const nullable = schema.nullable === true;
	  functionCode += `
    ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_ARRAY' : ''}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;

	  if (!schema.additionalItems && Array.isArray(itemsSchema)) {
	    functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
	  }

	  if (largeArrayMechanism === 'json-stringify') {
	    functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)\n`;
	  }

	  functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;

	  if (Array.isArray(itemsSchema)) {
	    for (let i = 0; i < itemsSchema.length; i++) {
	      const item = itemsSchema[i];
	      functionCode += `value = obj[${i}]`;
	      const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), 'value');
	      functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type)}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
	    }

	    if (schema.additionalItems) {
	      functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
	    }
	  } else {
	    const code = buildValue(context, itemsLocation, 'obj[i]');
	    functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        ${code}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
	  }

	  functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;

	  context.functions.push(functionCode);
	  return functionName
	}

	function buildArrayTypeCondition (type, accessor) {
	  let condition;
	  switch (type) {
	    case 'null':
	      condition = 'value === null';
	      break
	    case 'string':
	      condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
	      break
	    case 'integer':
	      condition = 'Number.isInteger(value)';
	      break
	    case 'number':
	      condition = 'Number.isFinite(value)';
	      break
	    case 'boolean':
	      condition = 'typeof value === \'boolean\'';
	      break
	    case 'object':
	      condition = 'value && typeof value === \'object\' && value.constructor === Object';
	      break
	    case 'array':
	      condition = 'Array.isArray(value)';
	      break
	    default:
	      if (Array.isArray(type)) {
	        const conditions = type.map((subType) => {
	          return buildArrayTypeCondition(subType)
	        });
	        condition = `(${conditions.join(' || ')})`;
	      }
	  }
	  return condition
	}

	function generateFuncName (context) {
	  return 'anonymous' + context.functionsCounter++
	}

	function buildMultiTypeSerializer (context, location, input) {
	  const schema = location.schema;
	  const types = schema.type.sort(t1 => t1 === 'null' ? -1 : 1);

	  let code = '';

	  types.forEach((type, index) => {
	    location.schema = { ...location.schema, type };
	    const nestedResult = buildSingleTypeSerializer(context, location, input);

	    const statement = index === 0 ? 'if' : 'else if';
	    switch (type) {
	      case 'null':
	        code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
	        break
	      case 'string': {
	        code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
	        break
	      }
	      case 'array': {
	        code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
	        break
	      }
	      case 'integer': {
	        code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
	        break
	      }
	      default: {
	        code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
	        break
	      }
	    }
	  });
	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }
	  code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;

	  return code
	}

	function buildSingleTypeSerializer (context, location, input) {
	  const schema = location.schema;

	  switch (schema.type) {
	    case 'null':
	      return 'json += JSON_STR_NULL'
	    case 'string': {
	      if (schema.format === 'date-time') {
	        return `json += serializer.asDateTime(${input})`
	      } else if (schema.format === 'date') {
	        return `json += serializer.asDate(${input})`
	      } else if (schema.format === 'time') {
	        return `json += serializer.asTime(${input})`
	      } else if (schema.format === 'unsafe') {
	        return `json += serializer.asUnsafeString(${input})`
	      } else {
	        return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += serializer.asString(${input}.source)
          } else {
            json += serializer.asString(${input}.toString())
          }
        } else {
          json += serializer.asString(${input})
        }
        `
	      }
	    }
	    case 'integer':
	      return `json += serializer.asInteger(${input})`
	    case 'number':
	      return `json += serializer.asNumber(${input})`
	    case 'boolean':
	      return `json += serializer.asBoolean(${input})`
	    case 'object': {
	      const funcName = buildObject(context, location);
	      return `json += ${funcName}(${input})`
	    }
	    case 'array': {
	      const funcName = buildArray(context, location);
	      return `json += ${funcName}(${input})`
	    }
	    case undefined:
	      return `json += JSON.stringify(${input})`
	    default:
	      throw new Error(`${schema.type} unsupported`)
	  }
	}

	function buildConstSerializer (location, input) {
	  const schema = location.schema;
	  const type = schema.type;

	  const hasNullType = Array.isArray(type) && type.includes('null');

	  let code = '';

	  if (hasNullType) {
	    code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
	  }

	  code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;

	  if (hasNullType) {
	    code += `
      }
    `;
	  }

	  return code
	}

	function buildAllOf (context, location, input) {
	  const schema = location.schema;

	  let mergedSchemaId = context.mergedSchemasIds.get(schema);
	  if (mergedSchemaId) {
	    const mergedLocation = getMergedLocation(context, mergedSchemaId);
	    return buildValue(context, mergedLocation, input)
	  }

	  mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	  context.mergedSchemasIds.set(schema, mergedSchemaId);

	  const { allOf, ...schemaWithoutAllOf } = location.schema;
	  const locations = [
	    new Location(
	      schemaWithoutAllOf,
	      location.schemaId,
	      location.jsonPointer
	    )
	  ];

	  const allOfsLocation = location.getPropertyLocation('allOf');
	  for (let i = 0; i < allOf.length; i++) {
	    locations.push(allOfsLocation.getPropertyLocation(i));
	  }

	  const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
	  return buildValue(context, mergedLocation, input)
	}

	function buildOneOf (context, location, input) {
	  context.validatorSchemasIds.add(location.schemaId);

	  const schema = location.schema;

	  const type = schema.anyOf ? 'anyOf' : 'oneOf';
	  const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;

	  const locationWithoutOneOf = new Location(
	    schemaWithoutAnyOf,
	    location.schemaId,
	    location.jsonPointer
	  );
	  const oneOfsLocation = location.getPropertyLocation(type);

	  let code = '';

	  for (let index = 0; index < oneOfs.length; index++) {
	    const optionLocation = oneOfsLocation.getPropertyLocation(index);
	    const optionSchema = optionLocation.schema;

	    let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
	    let mergedLocation = null;
	    if (mergedSchemaId) {
	      mergedLocation = getMergedLocation(context, mergedSchemaId);
	    } else {
	      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	      context.mergedSchemasIds.set(optionSchema, mergedSchemaId);

	      mergedLocation = mergeLocations(context, mergedSchemaId, [
	        locationWithoutOneOf,
	        optionLocation
	      ]);
	    }

	    const nestedResult = buildValue(context, mergedLocation, input);
	    const schemaRef = optionLocation.getSchemaRef();
	    code += `
      ${index === 0 ? 'if' : 'else if'}(validator.validate("${schemaRef}", ${input}))
        ${nestedResult}
    `;
	  }

	  let schemaRef = location.getSchemaRef();
	  if (schemaRef.startsWith(context.rootSchemaId)) {
	    schemaRef = schemaRef.replace(context.rootSchemaId, '');
	  }

	  code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;

	  return code
	}

	function buildIfThenElse (context, location, input) {
	  context.validatorSchemasIds.add(location.schemaId);

	  const {
	    if: ifSchema,
	    then: thenSchema,
	    else: elseSchema,
	    ...schemaWithoutIfThenElse
	  } = location.schema;

	  const rootLocation = new Location(
	    schemaWithoutIfThenElse,
	    location.schemaId,
	    location.jsonPointer
	  );

	  const ifLocation = location.getPropertyLocation('if');
	  const ifSchemaRef = ifLocation.getSchemaRef();

	  const thenLocation = location.getPropertyLocation('then');
	  let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
	  let thenMergedLocation = null;
	  if (thenMergedSchemaId) {
	    thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
	  } else {
	    thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	    context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);

	    thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
	      rootLocation,
	      thenLocation
	    ]);
	  }

	  if (!elseSchema) {
	    return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `
	  }

	  const elseLocation = location.getPropertyLocation('else');
	  let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
	  let elseMergedLocation = null;
	  if (elseMergedSchemaId) {
	    elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
	  } else {
	    elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
	    context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);

	    elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
	      rootLocation,
	      elseLocation
	    ]);
	  }

	  return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `
	}

	function buildValue (context, location, input) {
	  let schema = location.schema;

	  if (typeof schema === 'boolean') {
	    return `json += JSON.stringify(${input})`
	  }

	  if (schema.$ref) {
	    location = resolveRef(context, location);
	    schema = location.schema;
	  }

	  if (schema.allOf) {
	    return buildAllOf(context, location, input)
	  }

	  if (schema.anyOf || schema.oneOf) {
	    return buildOneOf(context, location, input)
	  }

	  if (schema.if && schema.then) {
	    return buildIfThenElse(context, location, input)
	  }

	  if (schema.type === undefined) {
	    const inferredType = inferTypeByKeyword(schema);
	    if (inferredType) {
	      schema.type = inferredType;
	    }
	  }

	  let code = '';

	  const type = schema.type;
	  const nullable = schema.nullable === true;
	  if (nullable) {
	    code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
	  }

	  if (schema.const !== undefined) {
	    code += buildConstSerializer(location, input);
	  } else if (Array.isArray(type)) {
	    code += buildMultiTypeSerializer(context, location, input);
	  } else {
	    code += buildSingleTypeSerializer(context, location, input);
	  }

	  if (nullable) {
	    code += `
      }
    `;
	  }

	  return code
	}

	fastJsonStringify.exports = build;
	fastJsonStringify.exports.default = build;
	fastJsonStringify.exports.build = build;

	fastJsonStringify.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;

	fastJsonStringify.exports.restore = function ({ code, validator, serializer }) {
	  // eslint-disable-next-line
	  return (Function.apply(null, ['validator', 'serializer', code])
	    .apply(null, [validator, serializer]))
	};
	return fastJsonStringify.exports;
}

var hasRequiredStandalone$2;

function requireStandalone$2 () {
	if (hasRequiredStandalone$2) return standalone$3;
	hasRequiredStandalone$2 = 1;

	const fastJsonStringify = requireFastJsonStringify();

	function SerializerSelector () {
	  return function buildSerializerFactory (externalSchemas, serializerOpts) {
	    const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
	    return responseSchemaCompiler.bind(null, fjsOpts)
	  }
	}

	function responseSchemaCompiler (fjsOpts, { schema /* method, url, httpStatus */ }) {
	  if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
	    fjsOpts.schema = { ...fjsOpts.schema };
	    delete fjsOpts.schema[schema.$id];
	  }
	  return fastJsonStringify(schema, fjsOpts)
	}

	function StandaloneSerializer (options = { readMode: true }) {
	  if (options.readMode === true && typeof options.restoreFunction !== 'function') {
	    throw new Error('You must provide a function for the restoreFunction-option when readMode ON')
	  }

	  if (options.readMode !== true && typeof options.storeFunction !== 'function') {
	    throw new Error('You must provide a function for the storeFunction-option when readMode OFF')
	  }

	  if (options.readMode === true) {
	    // READ MODE: it behalf only in the restore function provided by the user
	    return function wrapper () {
	      return function (opts) {
	        return options.restoreFunction(opts)
	      }
	    }
	  }

	  // WRITE MODE: it behalf on the default SerializerSelector, wrapping the API to run the Ajv Standalone code generation
	  const factory = SerializerSelector();
	  return function wrapper (externalSchemas, serializerOpts = {}) {
	    // to generate the serialization source code, this option is mandatory
	    serializerOpts.mode = 'standalone';

	    const compiler = factory(externalSchemas, serializerOpts);
	    return function (opts) { // { schema/*, method, url, httpPart */ }
	      const serializeFuncCode = compiler(opts);

	      options.storeFunction(opts, serializeFuncCode);

	      // eslint-disable-next-line no-new-func
	      return new Function(serializeFuncCode)
	    }
	  }
	}

	standalone$3.SerializerSelector = SerializerSelector;
	standalone$3.StandaloneSerializer = StandaloneSerializer;
	standalone$3.default = StandaloneSerializer;
	return standalone$3;
}

var hasRequiredFastJsonStringifyCompiler;

function requireFastJsonStringifyCompiler () {
	if (hasRequiredFastJsonStringifyCompiler) return fastJsonStringifyCompiler.exports;
	hasRequiredFastJsonStringifyCompiler = 1;

	const { SerializerSelector, StandaloneSerializer } = requireStandalone$2();

	fastJsonStringifyCompiler.exports = SerializerSelector;
	fastJsonStringifyCompiler.exports.default = SerializerSelector;
	fastJsonStringifyCompiler.exports.SerializerSelector = SerializerSelector;
	fastJsonStringifyCompiler.exports.StandaloneSerializer = StandaloneSerializer;
	return fastJsonStringifyCompiler.exports;
}

var ajvCompiler = {exports: {}};

var jtd$1 = {exports: {}};

var jtd = {};

var ref = {};

var metadata = {};

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.checkMetadata = void 0;
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "metadata",
	    schemaType: "object",
	    code(cxt) {
	        checkMetadata(cxt);
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
	        cxt.ok(valid);
	    },
	};
	function checkMetadata({ it, keyword }, metadata) {
	    if (it.jtdMetadata !== metadata) {
	        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
	    }
	}
	metadata.checkMetadata = checkMetadata;
	metadata.default = def;
	
	return metadata;
}

var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	Object.defineProperty(ref, "__esModule", { value: true });
	ref.hasRef = void 0;
	const compile_1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const ref_1 = requireRef$1();
	const metadata_1 = requireMetadata();
	const def = {
	    keyword: "ref",
	    schemaType: "string",
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema: ref, parentSchema, it } = cxt;
	        const { schemaEnv: { root }, } = it;
	        const valid = gen.name("valid");
	        if (parentSchema.nullable) {
	            gen.var(valid, (0, codegen_1._) `${data} === null`);
	            gen.if((0, codegen_1.not)(valid), validateJtdRef);
	        }
	        else {
	            gen.var(valid, false);
	            validateJtdRef();
	        }
	        cxt.ok(valid);
	        function validateJtdRef() {
	            var _a;
	            const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
	            if (!refSchema) {
	                throw new ref_error_1.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
	            }
	            if (hasRef(refSchema) || !it.opts.inlineRefs)
	                callValidate(refSchema);
	            else
	                inlineRefSchema(refSchema);
	        }
	        function callValidate(schema) {
	            const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
	            const v = (0, ref_1.getValidate)(cxt, sch);
	            const errsCount = gen.const("_errs", names_1.default.errors);
	            (0, ref_1.callRef)(cxt, v, sch, sch.$async);
	            gen.assign(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        }
	        function inlineRefSchema(schema) {
	            const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
	            cxt.subschema({
	                schema,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: `/definitions/${ref}`,
	            }, valid);
	        }
	    },
	};
	function hasRef(schema) {
	    for (const key in schema) {
	        let sch;
	        if (key === "ref" || (typeof (sch = schema[key]) == "object" && hasRef(sch)))
	            return true;
	    }
	    return false;
	}
	ref.hasRef = hasRef;
	ref.default = def;
	
	return ref;
}

var type = {};

var timestamp$1 = {};

var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp$1;
	hasRequiredTimestamp = 1;
	Object.defineProperty(timestamp$1, "__esModule", { value: true });
	const DT_SEPARATOR = /t|\s/i;
	const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
	const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	function validTimestamp(str, allowDate) {
	    // http://tools.ietf.org/html/rfc3339#section-5.6
	    const dt = str.split(DT_SEPARATOR);
	    return ((dt.length === 2 && validDate(dt[0]) && validTime(dt[1])) ||
	        (allowDate && dt.length === 1 && validDate(dt[0])));
	}
	timestamp$1.default = validTimestamp;
	function validDate(str) {
	    const matches = DATE.exec(str);
	    if (!matches)
	        return false;
	    const y = +matches[1];
	    const m = +matches[2];
	    const d = +matches[3];
	    return (m >= 1 &&
	        m <= 12 &&
	        d >= 1 &&
	        (d <= DAYS[m] ||
	            // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
	            (m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0))));
	}
	function validTime(str) {
	    const matches = TIME.exec(str);
	    if (!matches)
	        return false;
	    const hr = +matches[1];
	    const min = +matches[2];
	    const sec = +matches[3];
	    const tzH = +(matches[4] || 0);
	    const tzM = +(matches[5] || 0);
	    return ((hr <= 23 && min <= 59 && sec <= 59) ||
	        // leap second
	        (hr - tzH === 23 && min - tzM === 59 && sec === 60));
	}
	validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
	
	return timestamp$1;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	Object.defineProperty(error, "__esModule", { value: true });
	error.typeErrorParams = error.typeErrorMessage = error.typeError = void 0;
	const codegen_1 = requireCodegen();
	function typeError(t) {
	    return {
	        message: (cxt) => typeErrorMessage(cxt, t),
	        params: (cxt) => typeErrorParams(cxt, t),
	    };
	}
	error.typeError = typeError;
	function typeErrorMessage({ parentSchema }, t) {
	    return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
	}
	error.typeErrorMessage = typeErrorMessage;
	function typeErrorParams({ parentSchema }, t) {
	    return (0, codegen_1._) `{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
	}
	error.typeErrorParams = typeErrorParams;
	
	return error;
}

var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.intRange = void 0;
		const codegen_1 = requireCodegen();
		const timestamp_1 = requireTimestamp();
		const util_1 = requireUtil$1();
		const metadata_1 = requireMetadata();
		const error_1 = requireError();
		exports.intRange = {
		    int8: [-128, 127, 3],
		    uint8: [0, 255, 3],
		    int16: [-32768, 32767, 5],
		    uint16: [0, 65535, 5],
		    int32: [-2147483648, 2147483647, 10],
		    uint32: [0, 4294967295, 10],
		};
		const error = {
		    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
		    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema),
		};
		function timestampCode(cxt) {
		    const { gen, data, it } = cxt;
		    const { timestamp, allowDate } = it.opts;
		    if (timestamp === "date")
		        return (0, codegen_1._) `${data} instanceof Date `;
		    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
		    const allowDateArg = allowDate ? (0, codegen_1._) `, true` : codegen_1.nil;
		    const validString = (0, codegen_1._) `typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
		    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._) `${data} instanceof Date`, validString);
		}
		const def = {
		    keyword: "type",
		    schemaType: "string",
		    error,
		    code(cxt) {
		        (0, metadata_1.checkMetadata)(cxt);
		        const { data, schema, parentSchema, it } = cxt;
		        let cond;
		        switch (schema) {
		            case "boolean":
		            case "string":
		                cond = (0, codegen_1._) `typeof ${data} == ${schema}`;
		                break;
		            case "timestamp": {
		                cond = timestampCode(cxt);
		                break;
		            }
		            case "float32":
		            case "float64":
		                cond = (0, codegen_1._) `typeof ${data} == "number"`;
		                break;
		            default: {
		                const sch = schema;
		                cond = (0, codegen_1._) `typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
		                if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
		                    if (sch === "uint32")
		                        cond = (0, codegen_1._) `${cond} && ${data} >= 0`;
		                }
		                else {
		                    const [min, max] = exports.intRange[sch];
		                    cond = (0, codegen_1._) `${cond} && ${data} >= ${min} && ${data} <= ${max}`;
		                }
		            }
		        }
		        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._) `${data} === null`, cond) : cond);
		    },
		};
		exports.default = def;
		
	} (type));
	return type;
}

var _enum = {};

var nullable = {};

var hasRequiredNullable;

function requireNullable () {
	if (hasRequiredNullable) return nullable;
	hasRequiredNullable = 1;
	Object.defineProperty(nullable, "__esModule", { value: true });
	nullable.checkNullableObject = nullable.checkNullable = void 0;
	const codegen_1 = requireCodegen();
	function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
	    const valid = gen.name("valid");
	    if (parentSchema.nullable) {
	        gen.let(valid, (0, codegen_1._) `${data} === null`);
	        cond = (0, codegen_1.not)(valid);
	    }
	    else {
	        gen.let(valid, false);
	    }
	    return [valid, cond];
	}
	nullable.checkNullable = checkNullable;
	function checkNullableObject(cxt, cond) {
	    const [valid, cond_] = checkNullable(cxt, cond);
	    return [valid, (0, codegen_1._) `${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
	}
	nullable.checkNullableObject = checkNullableObject;
	
	return nullable;
}

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	Object.defineProperty(_enum, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata();
	const nullable_1 = requireNullable();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    error,
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, schemaValue, parentSchema, it } = cxt;
	        if (schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        if (schema.length !== new Set(schema).size)
	            throw new Error("enum items must be unique");
	        let valid;
	        const isString = (0, codegen_1._) `typeof ${data} == "string"`;
	        if (schema.length >= it.opts.loopEnum) {
	            let cond;
	            [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
	            gen.if(cond, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._) `${data} === ${value}`)));
	            if (parentSchema.nullable)
	                valid = (0, codegen_1.or)((0, codegen_1._) `${data} === null`, valid);
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._) `${valid} = ${data} === ${v}`, () => gen.break()));
	        }
	    },
	};
	_enum.default = def;
	
	return _enum;
}

var elements = {};

var hasRequiredElements;

function requireElements () {
	if (hasRequiredElements) return elements;
	hasRequiredElements = 1;
	Object.defineProperty(elements, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const def = {
	    keyword: "elements",
	    schemaType: "object",
	    error: (0, error_1.typeError)("array"),
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const [valid] = (0, nullable_1.checkNullable)(cxt);
	        gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._) `Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
	        cxt.ok(valid);
	    },
	};
	elements.default = def;
	
	return elements;
}

var properties = {};

var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties;
	hasRequiredProperties = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateProperties = exports.error = void 0;
		const code_1 = requireCode();
		const util_1 = requireUtil$1();
		const codegen_1 = requireCodegen();
		const metadata_1 = requireMetadata();
		const nullable_1 = requireNullable();
		const error_1 = requireError();
		var PropError;
		(function (PropError) {
		    PropError["Additional"] = "additional";
		    PropError["Missing"] = "missing";
		})(PropError || (PropError = {}));
		exports.error = {
		    message: (cxt) => {
		        const { params } = cxt;
		        return params.propError
		            ? params.propError === PropError.Additional
		                ? "must NOT have additional properties"
		                : `must have property '${params.missingProperty}'`
		            : (0, error_1.typeErrorMessage)(cxt, "object");
		    },
		    params: (cxt) => {
		        const { params } = cxt;
		        return params.propError
		            ? params.propError === PropError.Additional
		                ? (0, codegen_1._) `{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`
		                : (0, codegen_1._) `{error: ${params.propError}, missingProperty: ${params.missingProperty}}`
		            : (0, error_1.typeErrorParams)(cxt, "object");
		    },
		};
		const def = {
		    keyword: "properties",
		    schemaType: "object",
		    error: exports.error,
		    code: validateProperties,
		};
		// const error: KeywordErrorDefinition = {
		//   message: "should NOT have additional properties",
		//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
		// }
		function validateProperties(cxt) {
		    (0, metadata_1.checkMetadata)(cxt);
		    const { gen, data, parentSchema, it } = cxt;
		    const { additionalProperties, nullable } = parentSchema;
		    if (it.jtdDiscriminator && nullable)
		        throw new Error("JTD: nullable inside discriminator mapping");
		    if (commonProperties()) {
		        throw new Error("JTD: properties and optionalProperties have common members");
		    }
		    const [allProps, properties] = schemaProperties("properties");
		    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
		    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
		        return;
		    }
		    const [valid, cond] = it.jtdDiscriminator === undefined
		        ? (0, nullable_1.checkNullableObject)(cxt, data)
		        : [gen.let("valid", false), true];
		    gen.if(cond, () => gen.assign(valid, true).block(() => {
		        validateProps(properties, "properties", true);
		        validateProps(optProperties, "optionalProperties");
		        if (!additionalProperties)
		            validateAdditional();
		    }));
		    cxt.pass(valid);
		    function commonProperties() {
		        const props = parentSchema.properties;
		        const optProps = parentSchema.optionalProperties;
		        if (!(props && optProps))
		            return false;
		        for (const p in props) {
		            if (Object.prototype.hasOwnProperty.call(optProps, p))
		                return true;
		        }
		        return false;
		    }
		    function schemaProperties(keyword) {
		        const schema = parentSchema[keyword];
		        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
		        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
		            throw new Error(`JTD: discriminator tag used in ${keyword}`);
		        }
		        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
		        return [allPs, ps];
		    }
		    function validateProps(props, keyword, required) {
		        const _valid = gen.var("valid");
		        for (const prop of props) {
		            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
		            cxt.ok(_valid);
		        }
		        function missingProperty(prop) {
		            if (required) {
		                gen.assign(_valid, false);
		                cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
		            }
		            else {
		                gen.assign(_valid, true);
		            }
		        }
		    }
		    function applyPropertySchema(prop, keyword, _valid) {
		        cxt.subschema({
		            keyword,
		            schemaProp: prop,
		            dataProp: prop,
		        }, _valid);
		    }
		    function validateAdditional() {
		        gen.forIn("key", data, (key) => {
		            const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
		            const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
		            const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
		            gen.if(extra, () => {
		                if (it.opts.removeAdditional) {
		                    gen.code((0, codegen_1._) `delete ${data}[${key}]`);
		                }
		                else {
		                    cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
		                    if (!it.opts.allErrors)
		                        gen.break();
		                }
		            });
		        });
		    }
		    function isAdditional(key, props, keyword, jtdDiscriminator) {
		        let additional;
		        if (props.length > 8) {
		            // TODO maybe an option instead of hard-coded 8?
		            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
		            additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
		            if (jtdDiscriminator !== undefined) {
		                additional = (0, codegen_1.and)(additional, (0, codegen_1._) `${key} !== ${jtdDiscriminator}`);
		            }
		        }
		        else if (props.length || jtdDiscriminator !== undefined) {
		            const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
		            additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`));
		        }
		        else {
		            additional = true;
		        }
		        return additional;
		    }
		}
		exports.validateProperties = validateProperties;
		exports.default = def;
		
	} (properties));
	return properties;
}

var optionalProperties = {};

var hasRequiredOptionalProperties;

function requireOptionalProperties () {
	if (hasRequiredOptionalProperties) return optionalProperties;
	hasRequiredOptionalProperties = 1;
	Object.defineProperty(optionalProperties, "__esModule", { value: true });
	const properties_1 = requireProperties();
	const def = {
	    keyword: "optionalProperties",
	    schemaType: "object",
	    error: properties_1.error,
	    code(cxt) {
	        if (cxt.parentSchema.properties)
	            return;
	        (0, properties_1.validateProperties)(cxt);
	    },
	};
	optionalProperties.default = def;
	
	return optionalProperties;
}

var discriminator = {};

var hasRequiredDiscriminator;

function requireDiscriminator () {
	if (hasRequiredDiscriminator) return discriminator;
	hasRequiredDiscriminator = 1;
	Object.defineProperty(discriminator, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const types_1 = requireTypes$3();
	const error = {
	    message: (cxt) => {
	        const { schema, params } = cxt;
	        return params.discrError
	            ? params.discrError === types_1.DiscrError.Tag
	                ? `tag "${schema}" must be string`
	                : `value of tag "${schema}" must be in mapping`
	            : (0, error_1.typeErrorMessage)(cxt, "object");
	    },
	    params: (cxt) => {
	        const { schema, params } = cxt;
	        return params.discrError
	            ? (0, codegen_1._) `{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`
	            : (0, error_1.typeErrorParams)(cxt, "object");
	    },
	};
	const def = {
	    keyword: "discriminator",
	    schemaType: "string",
	    implements: ["mapping"],
	    error,
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, parentSchema } = cxt;
	        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
	        gen.if(cond);
	        validateDiscriminator();
	        gen.elseIf((0, codegen_1.not)(valid));
	        cxt.error();
	        gen.endIf();
	        cxt.ok(valid);
	        function validateDiscriminator() {
	            const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(schema)}`);
	            gen.if((0, codegen_1._) `${tag} === undefined`);
	            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
	            gen.elseIf((0, codegen_1._) `typeof ${tag} == "string"`);
	            validateMapping(tag);
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
	            gen.endIf();
	        }
	        function validateMapping(tag) {
	            gen.if(false);
	            for (const tagValue in parentSchema.mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(tagValue));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            cxt.subschema({
	                keyword: "mapping",
	                schemaProp,
	                jtdDiscriminator: schema,
	            }, _valid);
	            return _valid;
	        }
	    },
	};
	discriminator.default = def;
	
	return discriminator;
}

var values = {};

var hasRequiredValues;

function requireValues () {
	if (hasRequiredValues) return values;
	hasRequiredValues = 1;
	Object.defineProperty(values, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const codegen_1 = requireCodegen();
	const metadata_1 = requireMetadata();
	const nullable_1 = requireNullable();
	const error_1 = requireError();
	const def = {
	    keyword: "values",
	    schemaType: "object",
	    error: (0, error_1.typeError)("object"),
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { gen, data, schema, it } = cxt;
	        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
	        }
	        else {
	            gen.if(cond);
	            gen.assign(valid, validateMap());
	            gen.elseIf((0, codegen_1.not)(valid));
	            cxt.error();
	            gen.endIf();
	        }
	        cxt.ok(valid);
	        function validateMap() {
	            const _valid = gen.name("valid");
	            if (it.allErrors) {
	                const validMap = gen.let("valid", true);
	                validateValues(() => gen.assign(validMap, false));
	                return validMap;
	            }
	            gen.var(_valid, true);
	            validateValues(() => gen.break());
	            return _valid;
	            function validateValues(notValid) {
	                gen.forIn("key", data, (key) => {
	                    cxt.subschema({
	                        keyword: "values",
	                        dataProp: key,
	                        dataPropType: util_1.Type.Str,
	                    }, _valid);
	                    gen.if((0, codegen_1.not)(_valid), notValid);
	                });
	            }
	        }
	    },
	};
	values.default = def;
	
	return values;
}

var union = {};

var hasRequiredUnion;

function requireUnion () {
	if (hasRequiredUnion) return union;
	hasRequiredUnion = 1;
	Object.defineProperty(union, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "union",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in union" },
	};
	union.default = def;
	
	return union;
}

var hasRequiredJtd$1;

function requireJtd$1 () {
	if (hasRequiredJtd$1) return jtd;
	hasRequiredJtd$1 = 1;
	Object.defineProperty(jtd, "__esModule", { value: true });
	const ref_1 = requireRef();
	const type_1 = requireType();
	const enum_1 = require_enum();
	const elements_1 = requireElements();
	const properties_1 = requireProperties();
	const optionalProperties_1 = requireOptionalProperties();
	const discriminator_1 = requireDiscriminator();
	const values_1 = requireValues();
	const union_1 = requireUnion();
	const metadata_1 = requireMetadata();
	const jtdVocabulary = [
	    "definitions",
	    ref_1.default,
	    type_1.default,
	    enum_1.default,
	    elements_1.default,
	    properties_1.default,
	    optionalProperties_1.default,
	    discriminator_1.default,
	    values_1.default,
	    union_1.default,
	    metadata_1.default,
	    { keyword: "additionalProperties", schemaType: "boolean" },
	    { keyword: "nullable", schemaType: "boolean" },
	];
	jtd.default = jtdVocabulary;
	
	return jtd;
}

var jtdSchema = {};

var hasRequiredJtdSchema;

function requireJtdSchema () {
	if (hasRequiredJtdSchema) return jtdSchema;
	hasRequiredJtdSchema = 1;
	Object.defineProperty(jtdSchema, "__esModule", { value: true });
	const shared = (root) => {
	    const sch = {
	        nullable: { type: "boolean" },
	        metadata: {
	            optionalProperties: {
	                union: { elements: { ref: "schema" } },
	            },
	            additionalProperties: true,
	        },
	    };
	    if (root)
	        sch.definitions = { values: { ref: "schema" } };
	    return sch;
	};
	const emptyForm = (root) => ({
	    optionalProperties: shared(root),
	});
	const refForm = (root) => ({
	    properties: {
	        ref: { type: "string" },
	    },
	    optionalProperties: shared(root),
	});
	const typeForm = (root) => ({
	    properties: {
	        type: {
	            enum: [
	                "boolean",
	                "timestamp",
	                "string",
	                "float32",
	                "float64",
	                "int8",
	                "uint8",
	                "int16",
	                "uint16",
	                "int32",
	                "uint32",
	            ],
	        },
	    },
	    optionalProperties: shared(root),
	});
	const enumForm = (root) => ({
	    properties: {
	        enum: { elements: { type: "string" } },
	    },
	    optionalProperties: shared(root),
	});
	const elementsForm = (root) => ({
	    properties: {
	        elements: { ref: "schema" },
	    },
	    optionalProperties: shared(root),
	});
	const propertiesForm = (root) => ({
	    properties: {
	        properties: { values: { ref: "schema" } },
	    },
	    optionalProperties: {
	        optionalProperties: { values: { ref: "schema" } },
	        additionalProperties: { type: "boolean" },
	        ...shared(root),
	    },
	});
	const optionalPropertiesForm = (root) => ({
	    properties: {
	        optionalProperties: { values: { ref: "schema" } },
	    },
	    optionalProperties: {
	        additionalProperties: { type: "boolean" },
	        ...shared(root),
	    },
	});
	const discriminatorForm = (root) => ({
	    properties: {
	        discriminator: { type: "string" },
	        mapping: {
	            values: {
	                metadata: {
	                    union: [propertiesForm(false), optionalPropertiesForm(false)],
	                },
	            },
	        },
	    },
	    optionalProperties: shared(root),
	});
	const valuesForm = (root) => ({
	    properties: {
	        values: { ref: "schema" },
	    },
	    optionalProperties: shared(root),
	});
	const schema = (root) => ({
	    metadata: {
	        union: [
	            emptyForm,
	            refForm,
	            typeForm,
	            enumForm,
	            elementsForm,
	            propertiesForm,
	            optionalPropertiesForm,
	            discriminatorForm,
	            valuesForm,
	        ].map((s) => s(root)),
	    },
	});
	const jtdMetaSchema = {
	    definitions: {
	        schema: schema(false),
	    },
	    ...schema(true),
	};
	jtdSchema.default = jtdMetaSchema;
	
	return jtdSchema;
}

var serialize = {};

var types$2 = {};

var hasRequiredTypes$2;

function requireTypes$2 () {
	if (hasRequiredTypes$2) return types$2;
	hasRequiredTypes$2 = 1;
	Object.defineProperty(types$2, "__esModule", { value: true });
	types$2.jtdForms = void 0;
	types$2.jtdForms = [
	    "elements",
	    "values",
	    "discriminator",
	    "properties",
	    "optionalProperties",
	    "enum",
	    "type",
	    "ref",
	];
	
	return types$2;
}

var quote = {};

var hasRequiredQuote;

function requireQuote () {
	if (hasRequiredQuote) return quote;
	hasRequiredQuote = 1;
	Object.defineProperty(quote, "__esModule", { value: true });
	const rxEscapable = 
	// eslint-disable-next-line no-control-regex, no-misleading-character-class
	/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
	const escaped = {
	    "\b": "\\b",
	    "\t": "\\t",
	    "\n": "\\n",
	    "\f": "\\f",
	    "\r": "\\r",
	    '"': '\\"',
	    "\\": "\\\\",
	};
	function quote$1(s) {
	    rxEscapable.lastIndex = 0;
	    return ('"' +
	        (rxEscapable.test(s)
	            ? s.replace(rxEscapable, (a) => {
	                const c = escaped[a];
	                return typeof c === "string"
	                    ? c
	                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
	            })
	            : s) +
	        '"');
	}
	quote.default = quote$1;
	quote$1.code = 'require("ajv/dist/runtime/quote").default';
	
	return quote;
}

var hasRequiredSerialize$1;

function requireSerialize$1 () {
	if (hasRequiredSerialize$1) return serialize;
	hasRequiredSerialize$1 = 1;
	Object.defineProperty(serialize, "__esModule", { value: true });
	const types_1 = requireTypes$2();
	const __1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const ref_1 = requireRef();
	const util_1 = requireUtil$1();
	const quote_1 = requireQuote();
	const genSerialize = {
	    elements: serializeElements,
	    values: serializeValues,
	    discriminator: serializeDiscriminator,
	    properties: serializeProperties,
	    optionalProperties: serializeProperties,
	    enum: serializeString,
	    type: serializeType,
	    ref: serializeRef,
	};
	function compileSerializer(sch, definitions) {
	    const _sch = __1.getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    const serializeName = gen.scopeName("serialize");
	    const cxt = {
	        self: this,
	        gen,
	        schema: sch.schema,
	        schemaEnv: sch,
	        definitions,
	        data: names_1.default.data,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        sch.serializeName = serializeName;
	        gen.func(serializeName, names_1.default.data, false, () => {
	            gen.let(names_1.default.json, (0, codegen_1.str) ``);
	            serializeCode(cxt);
	            gen.return(names_1.default.json);
	        });
	        gen.optimize(this.opts.code.optimize);
	        const serializeFuncCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
	        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
	        const serialize = makeSerialize(this.scope.get());
	        this.scope.value(serializeName, { ref: serialize });
	        sch.serialize = serialize;
	    }
	    catch (e) {
	        if (sourceCode)
	            this.logger.error("Error compiling serializer, function code:", sourceCode);
	        delete sch.serialize;
	        delete sch.serializeName;
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	    return sch;
	}
	serialize.default = compileSerializer;
	function serializeCode(cxt) {
	    let form;
	    for (const key of types_1.jtdForms) {
	        if (key in cxt.schema) {
	            form = key;
	            break;
	        }
	    }
	    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
	}
	function serializeNullable(cxt, serializeForm) {
	    const { gen, schema, data } = cxt;
	    if (!schema.nullable)
	        return serializeForm(cxt);
	    gen.if((0, codegen_1._) `${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._) `"null"`), () => serializeForm(cxt));
	}
	function serializeElements(cxt) {
	    const { gen, schema, data } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `[`);
	    const first = gen.let("first", true);
	    gen.forOf("el", data, (el) => {
	        addComma(cxt, first);
	        serializeCode({ ...cxt, schema: schema.elements, data: el });
	    });
	    gen.add(names_1.default.json, (0, codegen_1.str) `]`);
	}
	function serializeValues(cxt) {
	    const { gen, schema, data } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
	    const first = gen.let("first", true);
	    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeKeyValue(cxt, key, schema, first) {
	    const { gen, data } = cxt;
	    addComma(cxt, first);
	    serializeString({ ...cxt, data: key });
	    gen.add(names_1.default.json, (0, codegen_1.str) `:`);
	    const value = gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
	    serializeCode({ ...cxt, schema, data: value });
	}
	function serializeDiscriminator(cxt) {
	    const { gen, schema, data } = cxt;
	    const { discriminator } = schema;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{${JSON.stringify(discriminator)}:`);
	    const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(discriminator)}`);
	    serializeString({ ...cxt, data: tag });
	    gen.if(false);
	    for (const tagValue in schema.mapping) {
	        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	        const sch = schema.mapping[tagValue];
	        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
	    }
	    gen.endIf();
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeProperties(cxt) {
	    const { gen } = cxt;
	    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
	    serializeSchemaProperties(cxt);
	    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
	}
	function serializeSchemaProperties(cxt, discriminator) {
	    const { gen, schema, data } = cxt;
	    const { properties, optionalProperties } = schema;
	    const props = keys(properties);
	    const optProps = keys(optionalProperties);
	    const allProps = allProperties(props.concat(optProps));
	    let first = !discriminator;
	    let firstProp;
	    for (const key of props) {
	        if (first)
	            first = false;
	        else
	            gen.add(names_1.default.json, (0, codegen_1.str) `,`);
	        serializeProperty(key, properties[key], keyValue(key));
	    }
	    if (first)
	        firstProp = gen.let("first", true);
	    for (const key of optProps) {
	        const value = keyValue(key);
	        gen.if((0, codegen_1.and)((0, codegen_1._) `${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
	            addComma(cxt, firstProp);
	            serializeProperty(key, optionalProperties[key], value);
	        });
	    }
	    if (schema.additionalProperties) {
	        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
	    }
	    function keys(ps) {
	        return ps ? Object.keys(ps) : [];
	    }
	    function allProperties(ps) {
	        if (discriminator)
	            ps.push(discriminator);
	        if (new Set(ps).size !== ps.length) {
	            throw new Error("JTD: properties/optionalProperties/disciminator overlap");
	        }
	        return ps;
	    }
	    function keyValue(key) {
	        return gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
	    }
	    function serializeProperty(key, propSchema, value) {
	        gen.add(names_1.default.json, (0, codegen_1.str) `${JSON.stringify(key)}:`);
	        serializeCode({ ...cxt, schema: propSchema, data: value });
	    }
	    function isAdditional(key, ps) {
	        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`)) : true;
	    }
	}
	function serializeType(cxt) {
	    const { gen, schema, data } = cxt;
	    switch (schema.type) {
	        case "boolean":
	            gen.add(names_1.default.json, (0, codegen_1._) `${data} ? "true" : "false"`);
	            break;
	        case "string":
	            serializeString(cxt);
	            break;
	        case "timestamp":
	            gen.if((0, codegen_1._) `${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._) `'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
	            break;
	        default:
	            serializeNumber(cxt);
	    }
	}
	function serializeString({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
	}
	function serializeNumber({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `"" + ${data}`);
	}
	function serializeRef(cxt) {
	    const { gen, self, data, definitions, schema, schemaEnv } = cxt;
	    const { ref } = schema;
	    const refSchema = definitions[ref];
	    if (!refSchema)
	        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
	    if (!(0, ref_1.hasRef)(refSchema))
	        return serializeCode({ ...cxt, schema: refSchema });
	    const { root } = schemaEnv;
	    const sch = compileSerializer.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
	    gen.add(names_1.default.json, (0, codegen_1._) `${getSerialize(gen, sch)}(${data})`);
	}
	function getSerialize(gen, sch) {
	    return sch.serialize
	        ? gen.scopeValue("serialize", { ref: sch.serialize })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
	}
	function serializeEmpty({ gen, data }) {
	    gen.add(names_1.default.json, (0, codegen_1._) `JSON.stringify(${data})`);
	}
	function addComma({ gen }, first) {
	    if (first) {
	        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str) `,`));
	    }
	    else {
	        gen.add(names_1.default.json, (0, codegen_1.str) `,`);
	    }
	}
	
	return serialize;
}

var parse$1 = {};

var parseJson = {};

var hasRequiredParseJson;

function requireParseJson () {
	if (hasRequiredParseJson) return parseJson;
	hasRequiredParseJson = 1;
	Object.defineProperty(parseJson, "__esModule", { value: true });
	parseJson.parseJsonString = parseJson.parseJsonNumber = parseJson.parseJson = void 0;
	const rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
	function parseJson$1(s, pos) {
	    let endPos;
	    parseJson$1.message = undefined;
	    let matches;
	    if (pos)
	        s = s.slice(pos);
	    try {
	        parseJson$1.position = pos + s.length;
	        return JSON.parse(s);
	    }
	    catch (e) {
	        matches = rxParseJson.exec(e.message);
	        if (!matches) {
	            parseJson$1.message = "unexpected end";
	            return undefined;
	        }
	        endPos = +matches[1];
	        const c = s[endPos];
	        s = s.slice(0, endPos);
	        parseJson$1.position = pos + endPos;
	        try {
	            return JSON.parse(s);
	        }
	        catch (e1) {
	            parseJson$1.message = `unexpected token ${c}`;
	            return undefined;
	        }
	    }
	}
	parseJson.parseJson = parseJson$1;
	parseJson$1.message = undefined;
	parseJson$1.position = 0;
	parseJson$1.code = 'require("ajv/dist/runtime/parseJson").parseJson';
	function parseJsonNumber(s, pos, maxDigits) {
	    let numStr = "";
	    let c;
	    parseJsonNumber.message = undefined;
	    if (s[pos] === "-") {
	        numStr += "-";
	        pos++;
	    }
	    if (s[pos] === "0") {
	        numStr += "0";
	        pos++;
	    }
	    else {
	        if (!parseDigits(maxDigits)) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    if (maxDigits) {
	        parseJsonNumber.position = pos;
	        return +numStr;
	    }
	    if (s[pos] === ".") {
	        numStr += ".";
	        pos++;
	        if (!parseDigits()) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    if (((c = s[pos]), c === "e" || c === "E")) {
	        numStr += "e";
	        pos++;
	        if (((c = s[pos]), c === "+" || c === "-")) {
	            numStr += c;
	            pos++;
	        }
	        if (!parseDigits()) {
	            errorMessage();
	            return undefined;
	        }
	    }
	    parseJsonNumber.position = pos;
	    return +numStr;
	    function parseDigits(maxLen) {
	        let digit = false;
	        while (((c = s[pos]), c >= "0" && c <= "9" && (maxLen === undefined || maxLen-- > 0))) {
	            digit = true;
	            numStr += c;
	            pos++;
	        }
	        return digit;
	    }
	    function errorMessage() {
	        parseJsonNumber.position = pos;
	        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
	    }
	}
	parseJson.parseJsonNumber = parseJsonNumber;
	parseJsonNumber.message = undefined;
	parseJsonNumber.position = 0;
	parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
	const escapedChars = {
	    b: "\b",
	    f: "\f",
	    n: "\n",
	    r: "\r",
	    t: "\t",
	    '"': '"',
	    "/": "/",
	    "\\": "\\",
	};
	const CODE_A = "a".charCodeAt(0);
	const CODE_0 = "0".charCodeAt(0);
	function parseJsonString(s, pos) {
	    let str = "";
	    let c;
	    parseJsonString.message = undefined;
	    // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition
	    while (true) {
	        c = s[pos++];
	        if (c === '"')
	            break;
	        if (c === "\\") {
	            c = s[pos];
	            if (c in escapedChars) {
	                str += escapedChars[c];
	                pos++;
	            }
	            else if (c === "u") {
	                pos++;
	                let count = 4;
	                let code = 0;
	                while (count--) {
	                    code <<= 4;
	                    c = s[pos];
	                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	                    if (c === undefined) {
	                        errorMessage("unexpected end");
	                        return undefined;
	                    }
	                    c = c.toLowerCase();
	                    if (c >= "a" && c <= "f") {
	                        code += c.charCodeAt(0) - CODE_A + 10;
	                    }
	                    else if (c >= "0" && c <= "9") {
	                        code += c.charCodeAt(0) - CODE_0;
	                    }
	                    else {
	                        errorMessage(`unexpected token ${c}`);
	                        return undefined;
	                    }
	                    pos++;
	                }
	                str += String.fromCharCode(code);
	            }
	            else {
	                errorMessage(`unexpected token ${c}`);
	                return undefined;
	            }
	            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	        }
	        else if (c === undefined) {
	            errorMessage("unexpected end");
	            return undefined;
	        }
	        else {
	            if (c.charCodeAt(0) >= 0x20) {
	                str += c;
	            }
	            else {
	                errorMessage(`unexpected token ${c}`);
	                return undefined;
	            }
	        }
	    }
	    parseJsonString.position = pos;
	    return str;
	    function errorMessage(msg) {
	        parseJsonString.position = pos;
	        parseJsonString.message = msg;
	    }
	}
	parseJson.parseJsonString = parseJsonString;
	parseJsonString.message = undefined;
	parseJsonString.position = 0;
	parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
	
	return parseJson;
}

var hasRequiredParse$2;

function requireParse$2 () {
	if (hasRequiredParse$2) return parse$1;
	hasRequiredParse$2 = 1;
	Object.defineProperty(parse$1, "__esModule", { value: true });
	const types_1 = requireTypes$2();
	const __1 = requireCompile();
	const codegen_1 = requireCodegen();
	const ref_error_1 = requireRef_error();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const ref_1 = requireRef();
	const type_1 = requireType();
	const parseJson_1 = requireParseJson();
	const util_1 = requireUtil$1();
	const timestamp_1 = requireTimestamp();
	const genParse = {
	    elements: parseElements,
	    values: parseValues,
	    discriminator: parseDiscriminator,
	    properties: parseProperties,
	    optionalProperties: parseProperties,
	    enum: parseEnum,
	    type: parseType,
	    ref: parseRef,
	};
	function compileParser(sch, definitions) {
	    const _sch = __1.getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    const parseName = gen.scopeName("parse");
	    const cxt = {
	        self: this,
	        gen,
	        schema: sch.schema,
	        schemaEnv: sch,
	        definitions,
	        data: names_1.default.data,
	        parseName,
	        char: gen.name("c"),
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        sch.parseName = parseName;
	        parserFunction(cxt);
	        gen.optimize(this.opts.code.optimize);
	        const parseFuncCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
	        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
	        const parse = makeParse(this.scope.get());
	        this.scope.value(parseName, { ref: parse });
	        sch.parse = parse;
	    }
	    catch (e) {
	        if (sourceCode)
	            this.logger.error("Error compiling parser, function code:", sourceCode);
	        delete sch.parse;
	        delete sch.parseName;
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	    return sch;
	}
	parse$1.default = compileParser;
	const undef = (0, codegen_1._) `undefined`;
	function parserFunction(cxt) {
	    const { gen, parseName, char } = cxt;
	    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
	        gen.let(names_1.default.data);
	        gen.let(char);
	        gen.assign((0, codegen_1._) `${parseName}.message`, undef);
	        gen.assign((0, codegen_1._) `${parseName}.position`, undef);
	        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);
	        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);
	        parseCode(cxt);
	        skipWhitespace(cxt);
	        gen.if(names_1.default.jsonPart, () => {
	            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
	            gen.return(names_1.default.data);
	        });
	        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
	        jsonSyntaxError(cxt);
	    });
	}
	function parseCode(cxt) {
	    let form;
	    for (const key of types_1.jtdForms) {
	        if (key in cxt.schema) {
	            form = key;
	            break;
	        }
	    }
	    if (form)
	        parseNullable(cxt, genParse[form]);
	    else
	        parseEmpty(cxt);
	}
	const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
	function parseNullable(cxt, parseForm) {
	    const { gen, schema, data } = cxt;
	    if (!schema.nullable)
	        return parseForm(cxt);
	    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
	}
	function parseElements(cxt) {
	    const { gen, schema, data } = cxt;
	    parseToken(cxt, "[");
	    const ix = gen.let("i", 0);
	    gen.assign(data, (0, codegen_1._) `[]`);
	    parseItems(cxt, "]", () => {
	        const el = gen.let("el");
	        parseCode({ ...cxt, schema: schema.elements, data: el });
	        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);
	    });
	}
	function parseValues(cxt) {
	    const { gen, schema, data } = cxt;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
	}
	function parseItems(cxt, endToken, block) {
	    tryParseItems(cxt, endToken, block);
	    parseToken(cxt, endToken);
	}
	function tryParseItems(cxt, endToken, block) {
	    const { gen } = cxt;
	    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
	        block();
	        tryParseToken(cxt, ",", () => gen.break(), hasItem);
	    });
	    function hasItem() {
	        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);
	    }
	}
	function parseKeyValue(cxt, schema) {
	    const { gen } = cxt;
	    const key = gen.let("key");
	    parseString({ ...cxt, data: key });
	    parseToken(cxt, ":");
	    parsePropertyValue(cxt, key, schema);
	}
	function parseDiscriminator(cxt) {
	    const { gen, data, schema } = cxt;
	    const { discriminator, mapping } = schema;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    const startPos = gen.const("pos", names_1.default.jsonPos);
	    const value = gen.let("value");
	    const tag = gen.let("tag");
	    tryParseItems(cxt, "}", () => {
	        const key = gen.let("key");
	        parseString({ ...cxt, data: key });
	        parseToken(cxt, ":");
	        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {
	            parseString({ ...cxt, data: tag });
	            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);
	            gen.break();
	        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped
	        );
	    });
	    gen.assign(names_1.default.jsonPos, startPos);
	    gen.if((0, codegen_1._) `${tag} === undefined`);
	    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
	    for (const tagValue in mapping) {
	        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
	    }
	    gen.else();
	    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
	    gen.endIf();
	}
	function parseProperties(cxt) {
	    const { gen, data } = cxt;
	    parseToken(cxt, "{");
	    gen.assign(data, (0, codegen_1._) `{}`);
	    parseSchemaProperties(cxt);
	}
	function parseSchemaProperties(cxt, discriminator) {
	    const { gen, schema, data } = cxt;
	    const { properties, optionalProperties, additionalProperties } = schema;
	    parseItems(cxt, "}", () => {
	        const key = gen.let("key");
	        parseString({ ...cxt, data: key });
	        parseToken(cxt, ":");
	        gen.if(false);
	        parseDefinedProperty(cxt, key, properties);
	        parseDefinedProperty(cxt, key, optionalProperties);
	        if (discriminator) {
	            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);
	            const tag = gen.let("tag");
	            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned
	        }
	        gen.else();
	        if (additionalProperties) {
	            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });
	        }
	        else {
	            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);
	        }
	        gen.endIf();
	    });
	    if (properties) {
	        const hasProp = (0, code_1.hasPropFunc)(gen);
	        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));
	        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
	    }
	}
	function parseDefinedProperty(cxt, key, schemas = {}) {
	    const { gen } = cxt;
	    for (const prop in schemas) {
	        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);
	        parsePropertyValue(cxt, key, schemas[prop]);
	    }
	}
	function parsePropertyValue(cxt, key, schema) {
	    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data}[${key}]` });
	}
	function parseType(cxt) {
	    const { gen, schema, data, self } = cxt;
	    switch (schema.type) {
	        case "boolean":
	            parseBoolean(cxt);
	            break;
	        case "string":
	            parseString(cxt);
	            break;
	        case "timestamp": {
	            parseString(cxt);
	            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
	            const { allowDate, parseDate } = self.opts;
	            const notValid = allowDate ? (0, codegen_1._) `!${vts}(${data}, true)` : (0, codegen_1._) `!${vts}(${data})`;
	            const fail = parseDate
	                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data} = new Date(${data}), false)`, (0, codegen_1._) `isNaN(${data}.valueOf())`)
	                : notValid;
	            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));
	            break;
	        }
	        case "float32":
	        case "float64":
	            parseNumber(cxt);
	            break;
	        default: {
	            const t = schema.type;
	            if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
	                parseNumber(cxt, 16); // 2 ** 53 - max safe integer
	                if (t === "uint32") {
	                    gen.if((0, codegen_1._) `${data} < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
	                }
	            }
	            else {
	                const [min, max, maxDigits] = type_1.intRange[t];
	                parseNumber(cxt, maxDigits);
	                gen.if((0, codegen_1._) `${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
	            }
	        }
	    }
	}
	function parseString(cxt) {
	    parseToken(cxt, '"');
	    parseWith(cxt, parseJson_1.parseJsonString);
	}
	function parseEnum(cxt) {
	    const { gen, data, schema } = cxt;
	    const enumSch = schema.enum;
	    parseToken(cxt, '"');
	    // TODO loopEnum
	    gen.if(false);
	    for (const value of enumSch) {
	        const valueStr = JSON.stringify(value).slice(1); // remove starting quote
	        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)} === ${valueStr}`);
	        gen.assign(data, (0, codegen_1.str) `${value}`);
	        gen.add(names_1.default.jsonPos, valueStr.length);
	    }
	    gen.else();
	    jsonSyntaxError(cxt);
	    gen.endIf();
	}
	function parseNumber(cxt, maxDigits) {
	    const { gen } = cxt;
	    skipWhitespace(cxt);
	    gen.if((0, codegen_1._) `"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
	}
	function parseBooleanToken(bool, fail) {
	    return (cxt) => {
	        const { gen, data } = cxt;
	        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
	    };
	}
	function parseRef(cxt) {
	    const { gen, self, definitions, schema, schemaEnv } = cxt;
	    const { ref } = schema;
	    const refSchema = definitions[ref];
	    if (!refSchema)
	        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
	    if (!(0, ref_1.hasRef)(refSchema))
	        return parseCode({ ...cxt, schema: refSchema });
	    const { root } = schemaEnv;
	    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
	    partialParse(cxt, getParser(gen, sch), true);
	}
	function getParser(gen, sch) {
	    return sch.parse
	        ? gen.scopeValue("parse", { ref: sch.parse })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.parse`;
	}
	function parseEmpty(cxt) {
	    parseWith(cxt, parseJson_1.parseJson);
	}
	function parseWith(cxt, parseFunc, args) {
	    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
	}
	function partialParse(cxt, parseFunc, args) {
	    const { gen, data } = cxt;
	    gen.assign(data, (0, codegen_1._) `${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._) `, ${args}` : codegen_1.nil})`);
	    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc}.position`);
	    gen.if((0, codegen_1._) `${data} === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc}.message`));
	}
	function parseToken(cxt, tok) {
	    tryParseToken(cxt, tok, jsonSyntaxError);
	}
	function tryParseToken(cxt, tok, fail, success) {
	    const { gen } = cxt;
	    const n = tok.length;
	    skipWhitespace(cxt);
	    gen.if((0, codegen_1._) `${jsonSlice(n)} === ${tok}`, () => {
	        gen.add(names_1.default.jsonPos, n);
	        success === null || success === void 0 ? void 0 : success(cxt);
	    }, () => fail(cxt));
	}
	function skipWhitespace({ gen, char: c }) {
	    gen.code((0, codegen_1._) `while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
	}
	function jsonSlice(len) {
	    return len === 1
	        ? (0, codegen_1._) `${names_1.default.json}[${names_1.default.jsonPos}]`
	        : (0, codegen_1._) `${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
	}
	function jsonSyntaxError(cxt) {
	    parsingError(cxt, (0, codegen_1._) `"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
	}
	function parsingError({ gen, parseName }, msg) {
	    gen.assign((0, codegen_1._) `${parseName}.message`, msg);
	    gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
	    gen.return(undef);
	}
	
	return parse$1;
}

var hasRequiredJtd;

function requireJtd () {
	if (hasRequiredJtd) return jtd$1.exports;
	hasRequiredJtd = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const jtd_1 = requireJtd$1();
		const jtd_schema_1 = requireJtdSchema();
		const serialize_1 = requireSerialize$1();
		const parse_1 = requireParse$2();
		const META_SCHEMA_ID = "JTD-meta-schema";
		class Ajv extends core_1.default {
		    constructor(opts = {}) {
		        super({
		            ...opts,
		            jtd: true,
		        });
		    }
		    _addVocabularies() {
		        super._addVocabularies();
		        this.addVocabulary(jtd_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		    compileSerializer(schema) {
		        const sch = this._addSchema(schema);
		        return sch.serialize || this._compileSerializer(sch);
		    }
		    compileParser(schema) {
		        const sch = this._addSchema(schema);
		        return (sch.parse || this._compileParser(sch));
		    }
		    _compileSerializer(sch) {
		        serialize_1.default.call(this, sch, sch.schema.definitions || {});
		        /* istanbul ignore if */
		        if (!sch.serialize)
		            throw new Error("ajv implementation error");
		        return sch.serialize;
		    }
		    _compileParser(sch) {
		        parse_1.default.call(this, sch, sch.schema.definitions || {});
		        /* istanbul ignore if */
		        if (!sch.parse)
		            throw new Error("ajv implementation error");
		        return sch.parse;
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (jtd$1, jtd$1.exports));
	return jtd$1.exports;
}

var defaultAjvOptions;
var hasRequiredDefaultAjvOptions;

function requireDefaultAjvOptions () {
	if (hasRequiredDefaultAjvOptions) return defaultAjvOptions;
	hasRequiredDefaultAjvOptions = 1;

	const fastUri = requireFastUri();

	defaultAjvOptions = Object.freeze({
	  coerceTypes: 'array',
	  useDefaults: true,
	  removeAdditional: true,
	  uriResolver: fastUri,
	  addUsedSchema: false,
	  // Explicitly set allErrors to `false`.
	  // When set to `true`, a DoS attack is possible.
	  allErrors: false
	});
	return defaultAjvOptions;
}

var validatorCompiler;
var hasRequiredValidatorCompiler;

function requireValidatorCompiler () {
	if (hasRequiredValidatorCompiler) return validatorCompiler;
	hasRequiredValidatorCompiler = 1;

	const Ajv = requireAjv().default;
	const AjvJTD = requireJtd();

	const defaultAjvOptions = requireDefaultAjvOptions();

	class ValidatorCompiler {
	  constructor (externalSchemas, options) {
	    // This instance of Ajv is private
	    // it should not be customized or used
	    if (options.mode === 'JTD') {
	      this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
	    } else {
	      this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
	    }

	    let addFormatPlugin = true;
	    if (options.plugins && options.plugins.length > 0) {
	      for (const plugin of options.plugins) {
	        if (Array.isArray(plugin)) {
	          addFormatPlugin = addFormatPlugin && plugin[0].name !== 'formatsPlugin';
	          plugin[0](this.ajv, plugin[1]);
	        } else {
	          addFormatPlugin = addFormatPlugin && plugin.name !== 'formatsPlugin';
	          plugin(this.ajv);
	        }
	      }
	    }

	    if (addFormatPlugin) {
	      requireDist$3()(this.ajv);
	    }

	    options.onCreate?.(this.ajv);

	    const sourceSchemas = Object.values(externalSchemas);
	    for (const extSchema of sourceSchemas) {
	      this.ajv.addSchema(extSchema);
	    }
	  }

	  buildValidatorFunction ({ schema/*, method, url, httpPart */ }) {
	    // Ajv does not support compiling two schemas with the same
	    // id inside the same instance. Therefore if we have already
	    // compiled the schema with the given id, we just return it.
	    if (schema.$id) {
	      const stored = this.ajv.getSchema(schema.$id);
	      if (stored) {
	        return stored
	      }
	    }

	    return this.ajv.compile(schema)
	  }
	}

	validatorCompiler = ValidatorCompiler;
	return validatorCompiler;
}

var serializerCompiler;
var hasRequiredSerializerCompiler;

function requireSerializerCompiler () {
	if (hasRequiredSerializerCompiler) return serializerCompiler;
	hasRequiredSerializerCompiler = 1;

	const AjvJTD = requireJtd();

	const defaultAjvOptions = requireDefaultAjvOptions();

	class SerializerCompiler {
	  constructor (_externalSchemas, options) {
	    this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));

	    /**
	     * https://ajv.js.org/json-type-definition.html#ref-form
	     * Unlike JSON Schema, JTD does not allow to reference:
	     * - any schema fragment other than root level definitions member
	     * - root of the schema - there is another way to define a self-recursive schema (see Example 2)
	     * - another schema file (but you can still combine schemas from multiple files using JavaScript).
	     *
	     * So we ignore the externalSchemas parameter.
	     */
	  }

	  buildSerializerFunction ({ schema/*, method, url, httpStatus */ }) {
	    return this.ajv.compileSerializer(schema)
	  }
	}

	serializerCompiler = SerializerCompiler;
	return serializerCompiler;
}

var standalone$1 = {exports: {}};

var hasRequiredStandalone$1;

function requireStandalone$1 () {
	if (hasRequiredStandalone$1) return standalone$1.exports;
	hasRequiredStandalone$1 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const scope_1 = requireScope();
		const code_1 = requireCode$1();
		function standaloneCode(ajv, refsOrFunc) {
		    if (!ajv.opts.code.source) {
		        throw new Error("moduleCode: ajv instance must have code.source option");
		    }
		    const { _n } = ajv.scope.opts;
		    return typeof refsOrFunc == "function"
		        ? funcExportCode(refsOrFunc.source)
		        : refsOrFunc !== undefined
		            ? multiExportsCode(refsOrFunc, getValidate)
		            : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
		    function getValidate(id) {
		        const v = ajv.getSchema(id);
		        if (!v)
		            throw new Error(`moduleCode: no schema with id ${id}`);
		        return v;
		    }
		    function funcExportCode(source) {
		        const usedValues = {};
		        const n = source === null || source === void 0 ? void 0 : source.validateName;
		        const vCode = validateCode(usedValues, source);
		        if (ajv.opts.code.esm) {
		            // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value
		            return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
		        }
		        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
		    }
		    function multiExportsCode(schemas, getValidateFunc) {
		        var _a;
		        const usedValues = {};
		        let code = (0, code_1._) `"use strict";`;
		        for (const name in schemas) {
		            const v = getValidateFunc(schemas[name]);
		            if (v) {
		                const vCode = validateCode(usedValues, v.source);
		                const exportSyntax = ajv.opts.code.esm
		                    ? (0, code_1._) `export const ${(0, code_1.getEsmExportName)(name)}`
		                    : (0, code_1._) `exports${(0, code_1.getProperty)(name)}`;
		                code = (0, code_1._) `${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
		            }
		        }
		        return `${code}`;
		    }
		    function validateCode(usedValues, s) {
		        if (!s)
		            throw new Error('moduleCode: function does not have "source" property');
		        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
		            return code_1.nil;
		        setUsedState(s.validateName, scope_1.UsedValueState.Started);
		        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
		        const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
		        return s.evaluated ? (0, code_1._) `${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
		        function refValidateCode(n) {
		            var _a;
		            const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;
		            if (n.prefix === "validate" && typeof vRef == "function") {
		                const v = vRef;
		                return validateCode(usedValues, v.source);
		            }
		            else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
		                const { validate, validateName } = vRef;
		                if (!validateName)
		                    throw new Error("ajv internal error");
		                const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
		                const wrapper = (0, code_1._) `${def} ${n} = {validate: ${validateName}};`;
		                if (usedState(validateName) === scope_1.UsedValueState.Started)
		                    return wrapper;
		                const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
		                return (0, code_1._) `${wrapper}${_n}${vCode}`;
		            }
		            return undefined;
		        }
		        function usedState(name) {
		            var _a;
		            return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
		        }
		        function setUsedState(name, state) {
		            const { prefix } = name;
		            const names = (usedValues[prefix] = usedValues[prefix] || new Map());
		            names.set(name, state);
		        }
		    }
		}
		module.exports = exports = standaloneCode;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = standaloneCode;
		
	} (standalone$1, standalone$1.exports));
	return standalone$1.exports;
}

var standalone;
var hasRequiredStandalone;

function requireStandalone () {
	if (hasRequiredStandalone) return standalone;
	hasRequiredStandalone = 1;

	const ValidatorSelector = requireAjvCompiler();
	const standaloneCode = requireStandalone$1().default;

	function StandaloneValidator (options = { readMode: true }) {
	  if (options.readMode === true && !options.restoreFunction) {
	    throw new Error('You must provide a restoreFunction options when readMode ON')
	  }

	  if (options.readMode !== true && !options.storeFunction) {
	    throw new Error('You must provide a storeFunction options when readMode OFF')
	  }

	  if (options.readMode === true) {
	    // READ MODE: it behalf only in the restore function provided by the user
	    return function wrapper () {
	      return function (opts) {
	        return options.restoreFunction(opts)
	      }
	    }
	  }

	  // WRITE MODE: it behalf on the default ValidatorSelector, wrapping the API to run the Ajv Standalone code generation
	  const factory = ValidatorSelector();
	  return function wrapper (externalSchemas, ajvOptions = {}) {
	    if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
	      // to generate the validation source code, these options are mandatory
	      ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
	    }

	    const compiler = factory(externalSchemas, ajvOptions);
	    return function (opts) { // { schema/*, method, url, httpPart */ }
	      const validationFunc = compiler(opts);

	      const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
	      options.storeFunction(opts, schemaValidationCode);

	      return validationFunc
	    }
	  }
	}

	standalone = StandaloneValidator;
	return standalone;
}

var hasRequiredAjvCompiler;

function requireAjvCompiler () {
	if (hasRequiredAjvCompiler) return ajvCompiler.exports;
	hasRequiredAjvCompiler = 1;

	const AjvReference = Symbol.for('fastify.ajv-compiler.reference');
	const ValidatorCompiler = requireValidatorCompiler();
	const SerializerCompiler = requireSerializerCompiler();

	function AjvCompiler (opts) {
	  const validatorPool = new Map();
	  const serializerPool = new Map();

	  if (opts && opts.jtdSerializer === true) {
	    return function buildSerializerFromPool (externalSchemas, serializerOpts) {
	      const uniqueAjvKey = getPoolKey({}, serializerOpts);
	      if (serializerPool.has(uniqueAjvKey)) {
	        return serializerPool.get(uniqueAjvKey)
	      }

	      const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
	      const ret = compiler.buildSerializerFunction.bind(compiler);
	      serializerPool.set(uniqueAjvKey, ret);

	      return ret
	    }
	  }

	  return function buildCompilerFromPool (externalSchemas, options) {
	    const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
	    if (validatorPool.has(uniqueAjvKey)) {
	      return validatorPool.get(uniqueAjvKey)
	    }

	    const compiler = new ValidatorCompiler(externalSchemas, options);
	    const ret = compiler.buildValidatorFunction.bind(compiler);
	    validatorPool.set(uniqueAjvKey, ret);

	    if (options.customOptions.code !== undefined) {
	      ret[AjvReference] = compiler;
	    }

	    return ret
	  }
	}

	function getPoolKey (externalSchemas, options) {
	  const externals = JSON.stringify(externalSchemas);
	  const ajvConfig = JSON.stringify(options);
	  return `${externals}${ajvConfig}`
	}
	ajvCompiler.exports = AjvCompiler;
	ajvCompiler.exports.default = AjvCompiler;
	ajvCompiler.exports.AjvCompiler = AjvCompiler;
	ajvCompiler.exports.AjvReference = AjvReference;
	ajvCompiler.exports.StandaloneValidator = requireStandalone();
	return ajvCompiler.exports;
}

var schemaController;
var hasRequiredSchemaController;

function requireSchemaController () {
	if (hasRequiredSchemaController) return schemaController;
	hasRequiredSchemaController = 1;

	const { buildSchemas } = requireSchemas();
	const SerializerSelector = requireFastJsonStringifyCompiler();
	const ValidatorSelector = requireAjvCompiler();

	/**
	 * Called at every fastify context that is being created.
	 * @param {object} parentSchemaCtrl: the SchemaController instance of the Fastify parent context
	 * @param {object} opts: the `schemaController` server option. It can be undefined when a parentSchemaCtrl is set
	 * @return {object}:a new SchemaController
	 */
	function buildSchemaController (parentSchemaCtrl, opts) {
	  if (parentSchemaCtrl) {
	    return new SchemaController(parentSchemaCtrl, opts)
	  }

	  const compilersFactory = Object.assign({
	    buildValidator: null,
	    buildSerializer: null
	  }, opts?.compilersFactory);

	  if (!compilersFactory.buildValidator) {
	    compilersFactory.buildValidator = ValidatorSelector();
	  }
	  if (!compilersFactory.buildSerializer) {
	    compilersFactory.buildSerializer = SerializerSelector();
	  }

	  const option = {
	    bucket: (opts && opts.bucket) || buildSchemas,
	    compilersFactory,
	    isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === 'function',
	    isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === 'function'
	  };

	  return new SchemaController(undefined, option)
	}

	class SchemaController {
	  constructor (parent, options) {
	    this.opts = options || parent?.opts;
	    this.addedSchemas = false;

	    this.compilersFactory = this.opts.compilersFactory;

	    if (parent) {
	      this.schemaBucket = this.opts.bucket(parent.getSchemas());
	      this.validatorCompiler = parent.getValidatorCompiler();
	      this.serializerCompiler = parent.getSerializerCompiler();
	      this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
	      this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
	      this.parent = parent;
	    } else {
	      this.schemaBucket = this.opts.bucket();
	      this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
	      this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
	    }
	  }

	  // Bucket interface
	  add (schema) {
	    this.addedSchemas = true;
	    return this.schemaBucket.add(schema)
	  }

	  getSchema (schemaId) {
	    return this.schemaBucket.getSchema(schemaId)
	  }

	  getSchemas () {
	    return this.schemaBucket.getSchemas()
	  }

	  setValidatorCompiler (validatorCompiler) {
	    // Set up as if the fixed validator compiler had been provided
	    // by a custom 'options.compilersFactory.buildValidator' that
	    // always returns the same compiler object. This is required because:
	    //
	    // - setValidatorCompiler must immediately install a compiler to preserve
	    //   legacy behavior
	    // - setupValidator will recreate compilers from builders in some
	    //   circumstances, so we have to install this adapter to make it
	    //   behave the same if the legacy API is used
	    //
	    // The cloning of the compilersFactory object is necessary because
	    // we are aliasing the parent compilersFactory if none was provided
	    // to us (see constructor.)
	    this.compilersFactory = Object.assign(
	      {},
	      this.compilersFactory,
	      { buildValidator: () => validatorCompiler });
	    this.validatorCompiler = validatorCompiler;
	    this.isCustomValidatorCompiler = true;
	  }

	  setSerializerCompiler (serializerCompiler) {
	    // Set up as if the fixed serializer compiler had been provided
	    // by a custom 'options.compilersFactory.buildSerializer' that
	    // always returns the same compiler object. This is required because:
	    //
	    // - setSerializerCompiler must immediately install a compiler to preserve
	    //   legacy behavior
	    // - setupSerializer will recreate compilers from builders in some
	    //   circumstances, so we have to install this adapter to make it
	    //   behave the same if the legacy API is used
	    //
	    // The cloning of the compilersFactory object is necessary because
	    // we are aliasing the parent compilersFactory if none was provided
	    // to us (see constructor.)
	    this.compilersFactory = Object.assign(
	      {},
	      this.compilersFactory,
	      { buildSerializer: () => serializerCompiler });
	    this.serializerCompiler = serializerCompiler;
	    this.isCustomSerializerCompiler = true;
	  }

	  getValidatorCompiler () {
	    return this.validatorCompiler || (this.parent && this.parent.getValidatorCompiler())
	  }

	  getSerializerCompiler () {
	    return this.serializerCompiler || (this.parent && this.parent.getSerializerCompiler())
	  }

	  getSerializerBuilder () {
	    return this.compilersFactory.buildSerializer || (this.parent && this.parent.getSerializerBuilder())
	  }

	  getValidatorBuilder () {
	    return this.compilersFactory.buildValidator || (this.parent && this.parent.getValidatorBuilder())
	  }

	  /**
	   * This method will be called when a validator must be setup.
	   * Do not setup the compiler more than once
	   * @param {object} serverOptions the fastify server options
	   */
	  setupValidator (serverOptions) {
	    const isReady = this.validatorCompiler !== undefined && !this.addedSchemas;
	    if (isReady) {
	      return
	    }
	    this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
	  }

	  /**
	   * This method will be called when a serializer must be setup.
	   * Do not setup the compiler more than once
	   * @param {object} serverOptions the fastify server options
	   */
	  setupSerializer (serverOptions) {
	    const isReady = this.serializerCompiler !== undefined && !this.addedSchemas;
	    if (isReady) {
	      return
	    }

	    this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
	  }
	}

	SchemaController.buildSchemaController = buildSchemaController;
	schemaController = SchemaController;
	return schemaController;
}

var pluginUtils = {exports: {}};

var re = {exports: {}};

var constants$3;
var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	const SEMVER_SPEC_VERSION = '2.0.0';

	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	/* istanbul ignore next */ 9007199254740991;

	// Max safe segment length for coercion.
	const MAX_SAFE_COMPONENT_LENGTH = 16;

	// Max safe length for a build identifier. The max length minus 6 characters for
	// the shortest version with a build 0.0.0+BUILD.
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];

	constants$3 = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants$3;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;

	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};

	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports) {

		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants$3();
		const debug = requireDebug();
		exports = module.exports = {};

		// The actual regexps go on exports.re
		const re = exports.re = [];
		const safeRe = exports.safeRe = [];
		const src = exports.src = [];
		const safeSrc = exports.safeSrc = [];
		const t = exports.t = {};
		let R = 0;

		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
		// used internally via the safeRe object since all inputs in this library get
		// normalized first to trim and collapse all extra whitespace. The original
		// regexes are exported for userland consumption and lower level usage. A
		// future breaking change could export the safer regex only with a note that
		// all input should have extra whitespace removed.
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];

		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};

		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};

		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.

		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.

		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.

		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

		// ## Main Version
		// Three dot-separated numeric identifiers.

		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);

		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		// Non-numberic identifiers include numberic identifiers but can be longer.
		// Therefore non-numberic identifiers must go first.

		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);

		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.

		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.

		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.

		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.

		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.

		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

		createToken('GTLT', '((?:<|>)?=?)');

		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);

		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);

		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

		// Coercion.
		// Extract anything that could conceivably be a part of a valid semver
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		createToken('LONETILDE', '(?:~>?)');

		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports.tildeTrimReplace = '$1~';

		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		createToken('LONECARET', '(?:\\^)');

		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports.caretTrimReplace = '$1^';

		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports.comparatorTrimReplace = '$1$2$3';

		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);

		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);

		// Star ranges basically just allow anything at all.
		createToken('STAR', '(<|>)?=?\\s*\\*');
		// >=0.0.0 is like a star
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;

	// parse out just the options we care about
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }

	  if (typeof options !== 'object') {
	    return looseOption
	  }

	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;

	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};

	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$1;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$1;
	hasRequiredSemver$1 = 1;

	const debug = requireDebug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants$3();
	const { safeRe: re, t } = requireRe();

	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    // this isn't actually relevant for versions, but keep it so that we
	    // don't run into trouble passing this.options around.
	    this.includePrerelease = !!options.includePrerelease;

	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }

	    // numberify any prerelease numeric ids
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }

	  toString () {
	    return this.version
	  }

	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0
	    }

	    return this.compareMain(other) || this.comparePre(other)
	  }

	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return (
	      compareIdentifiers(this.major, other.major) ||
	      compareIdentifiers(this.minor, other.minor) ||
	      compareIdentifiers(this.patch, other.patch)
	    )
	  }

	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }

	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      // Avoid an invalid semver results
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }

	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      // This probably shouldn't be used publicly.
	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;

	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            // didn't increment anything
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}

	semver$1 = SemVer;
	return semver$1;
}

var parse_1$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1$1;
	hasRequiredParse$1 = 1;

	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};

	parse_1$1 = parse;
	return parse_1$1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;

	const parse = requireParse$1();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;

	const parse = requireParse$1();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;

	const SemVer = requireSemver$1();

	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	const parse = requireParse$1();

	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);

	  if (comparison === 0) {
	    return null
	  }

	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;

	  if (lowHasPre && !highHasPre) {
	    // Going from prerelease -> no prerelease requires some special casing

	    // If the low version has only a major, then it will always be a major
	    // Some examples:
	    // 1.0.0-1 -> 1.0.0
	    // 1.0.0-1 -> 1.1.1
	    // 1.0.0-1 -> 2.0.0
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }

	    // If the main part has no difference
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }

	  // add the `pre` prefix if we are going to a prerelease version
	  const prefix = highHasPre ? 'pre' : '';

	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }

	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }

	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }

	  // high and low are preleases
	  return 'prerelease'
	};

	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;

	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;

	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;

	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;

	const parse = requireParse$1();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;

	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));

	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;

	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;

	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;

	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;

	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;

	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;

	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;

	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;

	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;

	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;

	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;

	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;

	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();

	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b

	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b

	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)

	    case '!=':
	      return neq(a, b, loose)

	    case '>':
	      return gt(a, b, loose)

	    case '>=':
	      return gte(a, b, loose)

	    case '<':
	      return lt(a, b, loose)

	    case '<=':
	      return lte(a, b, loose)

	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;

	const SemVer = requireSemver$1();
	const parse = requireParse$1();
	const { safeRe: re, t } = requireRe();

	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null
	  }

	  options = options || {};

	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    // Find the right-most coercible string that does not share
	    // a terminus with a more left-ward coercible string.
	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
	    //
	    // Walk through the string checking with a /g regexp
	    // Manually set the index so as to pick up overlapping matches.
	    // Stop when we get a match that ends at the string end, since no
	    // coercible string can be more right-ward without the same terminus.
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    // leave it in a clean state
	    coerceRtlRegex.lastIndex = -1;
	  }

	  if (match === null) {
	    return null
	  }

	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLrucache();
	const cache = new LRU();

	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants$3();

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;

	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;

	const Range = requireRange();

	// Mostly just for testing and legacy API reasons
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();

	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!max || maxSV.compare(v) === -1) {
	        // compare(max, v, true)
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!min || minSV.compare(v) === 1) {
	        // compare(min, v, true)
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();

	const minVersion = (range, loose) => {
	  range = new Range(range, loose);

	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let setMin = null;
	    comparators.forEach((comparator) => {
	      // Clone to avoid manipulating the comparator's semver object.
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	          /* fallthrough */
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          /* Ignore maximum versions */
	          break
	        /* istanbul ignore next */
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }

	  if (minver && range.test(minver)) {
	    return minver
	  }

	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;

	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;

	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();

	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);

	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }

	  // If it satisfies the range it is not outside
	  if (satisfies(version, range, options)) {
	    return false
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let high = null;
	    let low = null;

	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};

	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;

	// Determine if version is greater than all the versions possible in the range.
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;

	const outside = requireOutside();
	// Determine if version is less than all the versions possible in the range
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;

	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;

	// given a set of versions and a range, create a "simplified" range
	// that includes the same versions that the original range does
	// If the original range is shorter than the simplified one, return that.
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }

	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;

	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();

	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
	// - Every simple range `r1, r2, ...` is a null set, OR
	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
	//   some `R1, R2, ...`
	//
	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
	// - If c is only the ANY comparator
	//   - If C is only the ANY comparator, return true
	//   - Else if in prerelease mode, return false
	//   - else replace c with `[>=0.0.0]`
	// - If C is only the ANY comparator
	//   - if in prerelease mode, return true
	//   - else replace C with `[>=0.0.0]`
	// - Let EQ be the set of = comparators in c
	// - If EQ is more than one, return true (null set)
	// - Let GT be the highest > or >= comparator in c
	// - Let LT be the lowest < or <= comparator in c
	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
	// - If any C is a = range, and GT or LT are set, return false
	// - If EQ
	//   - If GT, and EQ does not satisfy GT, return true (null set)
	//   - If LT, and EQ does not satisfy LT, return true (null set)
	//   - If EQ satisfies every C, return true
	//   - Else return false
	// - If GT
	//   - If GT.semver is lower than any > or >= comp in C, return false
	//   - If GT is >=, and GT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the GT.semver tuple, return false
	// - If LT
	//   - If LT.semver is greater than any < or <= comp in C, return false
	//   - If LT is <=, and LT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the LT.semver tuple, return false
	// - Else return true

	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }

	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;

	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    // the null set is a subset of everything, but null simple ranges in
	    // a complex range should be ignored.  so if we saw a non-null range,
	    // then we know this isn't a subset, but if EVERY simple range was null,
	    // then it is a subset.
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};

	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];

	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }

	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }

	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }

	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }

	  if (eqSet.size > 1) {
	    return null
	  }

	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }

	  // will iterate one or zero times
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }

	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }

	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }

	    return true
	  }

	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  // if the subset has a prerelease, we need a comparator in the superset
	  // with the same tuple and a prerelease, or it's not a subset
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  // exception: <1.2.3-0 is the same as <1.2.3
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }

	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }

	  // if there was a < or >, and nothing in the dom, then must be false
	  // UNLESS it was limited by another range in the other direction.
	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }

	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }

	  // we needed a prerelease range in a specific tuple, but didn't get one
	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
	  // because it includes prereleases in the 1.2.3 tuple
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }

	  return true
	};

	// >=1.2.3 is lower than >1.2.3
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};

	// <=1.2.3 is higher than <1.2.3
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};

	subset_1 = subset;
	return subset_1;
}

var semver;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;

	// just pre-load all the stuff that index.js lazily exports
	const internalRe = requireRe();
	const constants = requireConstants$3();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse$1();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver;
}

var hasRequiredPluginUtils;

function requirePluginUtils () {
	if (hasRequiredPluginUtils) return pluginUtils.exports;
	hasRequiredPluginUtils = 1;
	(function (module) {

		const semver = requireSemver();
		const assert = require$$0$b;
		const kRegisteredPlugins = Symbol.for('registered-plugin');
		const {
		  kTestInternals
		} = requireSymbols$2();
		const { exist, existReply, existRequest } = requireDecorate();
		const {
		  FST_ERR_PLUGIN_VERSION_MISMATCH,
		  FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
		  FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
		} = requireErrors$2();

		const rcRegex = /-(?:rc|pre|alpha).+$/u;

		function getMeta (fn) {
		  return fn[Symbol.for('plugin-meta')]
		}

		function getPluginName (func) {
		  const display = getDisplayName(func);
		  if (display) {
		    return display
		  }

		  // let's see if this is a file, and in that case use that
		  // this is common for plugins
		  const cache = {};
		  // cache is undefined inside SEA
		  if (cache) {
		    const keys = Object.keys(cache);

		    for (let i = 0; i < keys.length; i++) {
		      const key = keys[i];
		      if (cache[key].exports === func) {
		        return key
		      }
		    }
		  }

		  // if not maybe it's a named function, so use that
		  if (func.name) {
		    return func.name
		  }

		  return null
		}

		function getFuncPreview (func) {
		  // takes the first two lines of the function if nothing else works
		  return func.toString().split('\n', 2).map(s => s.trim()).join(' -- ')
		}

		function getDisplayName (fn) {
		  return fn[Symbol.for('fastify.display-name')]
		}

		function shouldSkipOverride (fn) {
		  return !!fn[Symbol.for('skip-override')]
		}

		function checkDependencies (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const dependencies = meta.dependencies;
		  if (!dependencies) return
		  assert(Array.isArray(dependencies), 'The dependencies should be an array of strings');

		  dependencies.forEach(dependency => {
		    assert(
		      this[kRegisteredPlugins].indexOf(dependency) > -1,
		      `The dependency '${dependency}' of plugin '${meta.name}' is not registered`
		    );
		  });
		}

		function checkDecorators (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const { decorators, name } = meta;
		  if (!decorators) return

		  if (decorators.fastify) _checkDecorators(this, 'Fastify', decorators.fastify, name);
		  if (decorators.reply) _checkDecorators(this, 'Reply', decorators.reply, name);
		  if (decorators.request) _checkDecorators(this, 'Request', decorators.request, name);
		}

		const checks = {
		  Fastify: exist,
		  Request: existRequest,
		  Reply: existReply
		};

		function _checkDecorators (that, instance, decorators, name) {
		  assert(Array.isArray(decorators), 'The decorators should be an array of strings');

		  decorators.forEach(decorator => {
		    const withPluginName = typeof name === 'string' ? ` required by '${name}'` : '';
		    if (!checks[instance].call(that, decorator)) {
		      throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance)
		    }
		  });
		}

		function checkVersion (fn) {
		  const meta = getMeta(fn);
		  if (meta?.fastify == null) return

		  const requiredVersion = meta.fastify;

		  const fastifyRc = rcRegex.test(this.version);
		  if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
		    // A Fastify release candidate phase is taking place. In order to reduce
		    // the effort needed to test plugins with the RC, we allow plugins targeting
		    // the prior Fastify release to be loaded.
		    return
		  }
		  if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
		    // We are not in a release candidate phase. Thus, we must honor the semver
		    // ranges defined by the plugin's metadata. Which is to say, if the plugin
		    // expects an older version of Fastify than the _current_ version, we will
		    // throw an error.
		    throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version)
		  }
		}

		function registerPluginName (fn) {
		  const meta = getMeta(fn);
		  if (!meta) return

		  const name = meta.name;
		  if (!name) return
		  this[kRegisteredPlugins].push(name);
		  return name
		}

		function checkPluginHealthiness (fn, pluginName) {
		  if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
		    throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName)
		  }
		}

		function registerPlugin (fn) {
		  const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
		  checkPluginHealthiness.call(this, fn, pluginName);
		  checkVersion.call(this, fn);
		  checkDecorators.call(this, fn);
		  checkDependencies.call(this, fn);
		  return shouldSkipOverride(fn)
		}

		module.exports = {
		  getPluginName,
		  getFuncPreview,
		  kRegisteredPlugins,
		  getDisplayName,
		  registerPlugin
		};

		module.exports[kTestInternals] = {
		  shouldSkipOverride,
		  getMeta,
		  checkDecorators,
		  checkDependencies
		}; 
	} (pluginUtils));
	return pluginUtils.exports;
}

var reqIdGenFactory_1;
var hasRequiredReqIdGenFactory;

function requireReqIdGenFactory () {
	if (hasRequiredReqIdGenFactory) return reqIdGenFactory_1;
	hasRequiredReqIdGenFactory = 1;

	/**
	 * @callback GenerateRequestId
	 * @param {Object} req
	 * @returns {string}
	 */

	/**
	 * @param {string} [requestIdHeader]
	 * @param {GenerateRequestId} [optGenReqId]
	 * @returns {GenerateRequestId}
	 */
	function reqIdGenFactory (requestIdHeader, optGenReqId) {
	  const genReqId = optGenReqId || buildDefaultGenReqId();

	  if (requestIdHeader) {
	    return buildOptionalHeaderReqId(requestIdHeader, genReqId)
	  }

	  return genReqId
	}

	function getGenReqId (contextServer, req) {
	  return contextServer.genReqId(req)
	}

	function buildDefaultGenReqId () {
	  // 2,147,483,647 (2^31  1) stands for max SMI value (an internal optimization of V8).
	  // With this upper bound, if you'll be generating 1k ids/sec, you're going to hit it in ~25 days.
	  // This is very likely to happen in real-world applications, hence the limit is enforced.
	  // Growing beyond this value will make the id generation slower and cause a deopt.
	  // In the worst cases, it will become a float, losing accuracy.
	  const maxInt = 2147483647;

	  let nextReqId = 0;
	  return function defaultGenReqId () {
	    nextReqId = (nextReqId + 1) & maxInt;
	    return `req-${nextReqId.toString(36)}`
	  }
	}

	function buildOptionalHeaderReqId (requestIdHeader, genReqId) {
	  return function (req) {
	    return req.headers[requestIdHeader] || genReqId(req)
	  }
	}

	reqIdGenFactory_1 = {
	  getGenReqId,
	  reqIdGenFactory
	};
	return reqIdGenFactory_1;
}

var lib = {exports: {}};

var fastDecodeUriComponent;
var hasRequiredFastDecodeUriComponent;

function requireFastDecodeUriComponent () {
	if (hasRequiredFastDecodeUriComponent) return fastDecodeUriComponent;
	hasRequiredFastDecodeUriComponent = 1;

	var UTF8_ACCEPT = 12;
	var UTF8_REJECT = 0;
	var UTF8_DATA = [
	  // The first part of the table maps bytes to character to a transition.
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
	  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,

	  // The second part of the table maps a state to a new state when adding a
	  // transition.
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,
	  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

	  // The third part maps the current transition to a mask that needs to apply
	  // to the byte.
	  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07
	];

	function decodeURIComponent (uri) {
	  var percentPosition = uri.indexOf('%');
	  if (percentPosition === -1) return uri

	  var length = uri.length;
	  var decoded = '';
	  var last = 0;
	  var codepoint = 0;
	  var startOfOctets = percentPosition;
	  var state = UTF8_ACCEPT;

	  while (percentPosition > -1 && percentPosition < length) {
	    var high = hexCodeToInt(uri[percentPosition + 1], 4);
	    var low = hexCodeToInt(uri[percentPosition + 2], 0);
	    var byte = high | low;
	    var type = UTF8_DATA[byte];
	    state = UTF8_DATA[256 + state + type];
	    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type]);

	    if (state === UTF8_ACCEPT) {
	      decoded += uri.slice(last, startOfOctets);

	      decoded += (codepoint <= 0xFFFF)
	        ? String.fromCharCode(codepoint)
	        : String.fromCharCode(
	          (0xD7C0 + (codepoint >> 10)),
	          (0xDC00 + (codepoint & 0x3FF))
	        );

	      codepoint = 0;
	      last = percentPosition + 3;
	      percentPosition = startOfOctets = uri.indexOf('%', last);
	    } else if (state === UTF8_REJECT) {
	      return null
	    } else {
	      percentPosition += 3;
	      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue
	      return null
	    }
	  }

	  return decoded + uri.slice(last)
	}

	var HEX = {
	  '0': 0,
	  '1': 1,
	  '2': 2,
	  '3': 3,
	  '4': 4,
	  '5': 5,
	  '6': 6,
	  '7': 7,
	  '8': 8,
	  '9': 9,
	  'a': 10,
	  'A': 10,
	  'b': 11,
	  'B': 11,
	  'c': 12,
	  'C': 12,
	  'd': 13,
	  'D': 13,
	  'e': 14,
	  'E': 14,
	  'f': 15,
	  'F': 15
	};

	function hexCodeToInt (c, shift) {
	  var i = HEX[c];
	  return i === undefined ? 255 : i << shift
	}

	fastDecodeUriComponent = decodeURIComponent;
	return fastDecodeUriComponent;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const fastDecode = requireFastDecodeUriComponent();

	const plusRegex = /\+/g;
	const Empty = function () {};
	Empty.prototype = Object.create(null);

	/**
	 * @callback parse
	 * @param {string} input
	 */
	function parse(input) {
	  // Optimization: Use new Empty() instead of Object.create(null) for performance
	  // v8 has a better optimization for initializing functions compared to Object
	  const result = new Empty();

	  if (typeof input !== "string") {
	    return result;
	  }

	  let inputLength = input.length;
	  let key = "";
	  let value = "";
	  let startingIndex = -1;
	  let equalityIndex = -1;
	  let shouldDecodeKey = false;
	  let shouldDecodeValue = false;
	  let keyHasPlus = false;
	  let valueHasPlus = false;
	  let hasBothKeyValuePair = false;
	  let c = 0;

	  // Have a boundary of input.length + 1 to access last pair inside the loop.
	  for (let i = 0; i < inputLength + 1; i++) {
	    c = i !== inputLength ? input.charCodeAt(i) : 38;

	    // Handle '&' and end of line to pass the current values to result
	    if (c === 38) {
	      hasBothKeyValuePair = equalityIndex > startingIndex;

	      // Optimization: Reuse equality index to store the end of key
	      if (!hasBothKeyValuePair) {
	        equalityIndex = i;
	      }

	      key = input.slice(startingIndex + 1, equalityIndex);

	      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least "="
	      if (hasBothKeyValuePair || key.length > 0) {
	        // Optimization: Replace '+' with space
	        if (keyHasPlus) {
	          key = key.replace(plusRegex, " ");
	        }

	        // Optimization: Do not decode if it's not necessary.
	        if (shouldDecodeKey) {
	          key = fastDecode(key) || key;
	        }

	        if (hasBothKeyValuePair) {
	          value = input.slice(equalityIndex + 1, i);

	          if (valueHasPlus) {
	            value = value.replace(plusRegex, " ");
	          }

	          if (shouldDecodeValue) {
	            value = fastDecode(value) || value;
	          }
	        }
	        const currentValue = result[key];

	        if (currentValue === undefined) {
	          result[key] = value;
	        } else {
	          // Optimization: value.pop is faster than Array.isArray(value)
	          if (currentValue.pop) {
	            currentValue.push(value);
	          } else {
	            result[key] = [currentValue, value];
	          }
	        }
	      }

	      // Reset reading key value pairs
	      value = "";
	      startingIndex = i;
	      equalityIndex = i;
	      shouldDecodeKey = false;
	      shouldDecodeValue = false;
	      keyHasPlus = false;
	      valueHasPlus = false;
	    }
	    // Check '='
	    else if (c === 61) {
	      if (equalityIndex <= startingIndex) {
	        equalityIndex = i;
	      }
	      // If '=' character occurs again, we should decode the input.
	      else {
	        shouldDecodeValue = true;
	      }
	    }
	    // Check '+', and remember to replace it with empty space.
	    else if (c === 43) {
	      if (equalityIndex > startingIndex) {
	        valueHasPlus = true;
	      } else {
	        keyHasPlus = true;
	      }
	    }
	    // Check '%' character for encoding
	    else if (c === 37) {
	      if (equalityIndex > startingIndex) {
	        shouldDecodeValue = true;
	      } else {
	        shouldDecodeKey = true;
	      }
	    }
	  }

	  return result;
	}

	parse_1 = parse;
	return parse_1;
}

var querystring;
var hasRequiredQuerystring;

function requireQuerystring () {
	if (hasRequiredQuerystring) return querystring;
	hasRequiredQuerystring = 1;
	// This file is taken from Node.js project.
	// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js

	const hexTable = Array.from(
	  { length: 256 },
	  (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase(),
	);

	// These characters do not need escaping when generating query strings:
	// ! - . _ ~
	// ' ( ) *
	// digits
	// alpha (uppercase)
	// alpha (lowercase)
	// rome-ignore format: the array should not be formatted
	const noEscape = new Int8Array([
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127
	]);

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function encodeString(str) {
	  const len = str.length;
	  if (len === 0) return "";

	  let out = "";
	  let lastPos = 0;
	  let i = 0;

	  outer: for (; i < len; i++) {
	    let c = str.charCodeAt(i);

	    // ASCII
	    while (c < 0x80) {
	      if (noEscape[c] !== 1) {
	        if (lastPos < i) out += str.slice(lastPos, i);
	        lastPos = i + 1;
	        out += hexTable[c];
	      }

	      if (++i === len) break outer;

	      c = str.charCodeAt(i);
	    }

	    if (lastPos < i) out += str.slice(lastPos, i);

	    // Multi-byte characters ...
	    if (c < 0x800) {
	      lastPos = i + 1;
	      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];
	      continue;
	    }
	    if (c < 0xd800 || c >= 0xe000) {
	      lastPos = i + 1;
	      out +=
	        hexTable[0xe0 | (c >> 12)] +
	        hexTable[0x80 | ((c >> 6) & 0x3f)] +
	        hexTable[0x80 | (c & 0x3f)];
	      continue;
	    }
	    // Surrogate pair
	    ++i;

	    // This branch should never happen because all URLSearchParams entries
	    // should already be converted to USVString. But, included for
	    // completion's sake anyway.
	    if (i >= len) {
	      throw new Error("URI malformed");
	    }

	    const c2 = str.charCodeAt(i) & 0x3ff;

	    lastPos = i + 1;
	    c = 0x10000 + (((c & 0x3ff) << 10) | c2);
	    out +=
	      hexTable[0xf0 | (c >> 18)] +
	      hexTable[0x80 | ((c >> 12) & 0x3f)] +
	      hexTable[0x80 | ((c >> 6) & 0x3f)] +
	      hexTable[0x80 | (c & 0x3f)];
	  }
	  if (lastPos === 0) return str;
	  if (lastPos < len) return out + str.slice(lastPos);
	  return out;
	}

	querystring = { encodeString };
	return querystring;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	const { encodeString } = requireQuerystring();

	function getAsPrimitive(value) {
	  const type = typeof value;

	  if (type === "string") {
	    // Length check is handled inside encodeString function
	    return encodeString(value);
	  } else if (type === "bigint") {
	    return value.toString();
	  } else if (type === "boolean") {
	    return value ? "true" : "false";
	  } else if (type === "number" && Number.isFinite(value)) {
	    return value < 1e21 ? "" + value : encodeString("" + value);
	  }

	  return "";
	}

	/**
	 * @param {Record<string, string | number | boolean
	 * | ReadonlyArray<string | number | boolean> | null>} input
	 * @returns {string}
	 */
	function stringify(input) {
	  let result = "";

	  if (input === null || typeof input !== "object") {
	    return result;
	  }

	  const separator = "&";
	  const keys = Object.keys(input);
	  const keyLength = keys.length;
	  let valueLength = 0;

	  for (let i = 0; i < keyLength; i++) {
	    const key = keys[i];
	    const value = input[key];
	    const encodedKey = encodeString(key) + "=";

	    if (i) {
	      result += separator;
	    }

	    if (Array.isArray(value)) {
	      valueLength = value.length;
	      for (let j = 0; j < valueLength; j++) {
	        if (j) {
	          result += separator;
	        }

	        // Optimization: Dividing into multiple lines improves the performance.
	        // Since v8 does not need to care about the '+' character if it was one-liner.
	        result += encodedKey;
	        result += getAsPrimitive(value[j]);
	      }
	    } else {
	      result += encodedKey;
	      result += getAsPrimitive(value);
	    }
	  }

	  return result;
	}

	stringify_1 = stringify;
	return stringify_1;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib.exports;
	hasRequiredLib = 1;

	const parse = requireParse();
	const stringify = requireStringify();

	const fastQuerystring = {
	  parse,
	  stringify,
	};

	/**
	 * Enable TS and JS support
	 *
	 * - `const qs = require('fast-querystring')`
	 * - `import qs from 'fast-querystring'`
	 */
	lib.exports = fastQuerystring;
	lib.exports.default = fastQuerystring;
	lib.exports.parse = parse;
	lib.exports.stringify = stringify;
	return lib.exports;
}

var safeRegex2 = {exports: {}};

var dist$3 = {exports: {}};

var types$1 = {};

var tokens = {};

var hasRequiredTokens;

function requireTokens () {
	if (hasRequiredTokens) return tokens;
	hasRequiredTokens = 1;
	Object.defineProperty(tokens, "__esModule", { value: true });
	
	return tokens;
}

var types = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types;
	hasRequiredTypes$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.types = void 0;
		(function (types) {
		    types[types["ROOT"] = 0] = "ROOT";
		    types[types["GROUP"] = 1] = "GROUP";
		    types[types["POSITION"] = 2] = "POSITION";
		    types[types["SET"] = 3] = "SET";
		    types[types["RANGE"] = 4] = "RANGE";
		    types[types["REPETITION"] = 5] = "REPETITION";
		    types[types["REFERENCE"] = 6] = "REFERENCE";
		    types[types["CHAR"] = 7] = "CHAR";
		})(exports.types || (exports.types = {}));
		
	} (types));
	return types;
}

var setLookup = {};

var hasRequiredSetLookup;

function requireSetLookup () {
	if (hasRequiredSetLookup) return setLookup;
	hasRequiredSetLookup = 1;
	Object.defineProperty(setLookup, "__esModule", { value: true });
	
	return setLookup;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types$1;
	hasRequiredTypes = 1;
	(function (exports) {
		var __createBinding = (types$1 && types$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (types$1 && types$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireTokens(), exports);
		__exportStar(requireTypes$1(), exports);
		__exportStar(requireSetLookup(), exports);
		
	} (types$1));
	return types$1;
}

var tokenizer = {};

var util = {};

var sets = {};

var hasRequiredSets;

function requireSets () {
	if (hasRequiredSets) return sets;
	hasRequiredSets = 1;
	Object.defineProperty(sets, "__esModule", { value: true });
	sets.anyChar = sets.notWhitespace = sets.whitespace = sets.notInts = sets.ints = sets.notWords = sets.words = void 0;
	const types_1 = requireTypes();
	const INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
	const WORDS = () => [
	    { type: types_1.types.CHAR, value: 95 },
	    { type: types_1.types.RANGE, from: 97, to: 122 },
	    { type: types_1.types.RANGE, from: 65, to: 90 },
	    { type: types_1.types.RANGE, from: 48, to: 57 },
	];
	const WHITESPACE = () => [
	    { type: types_1.types.CHAR, value: 9 },
	    { type: types_1.types.CHAR, value: 10 },
	    { type: types_1.types.CHAR, value: 11 },
	    { type: types_1.types.CHAR, value: 12 },
	    { type: types_1.types.CHAR, value: 13 },
	    { type: types_1.types.CHAR, value: 32 },
	    { type: types_1.types.CHAR, value: 160 },
	    { type: types_1.types.CHAR, value: 5760 },
	    { type: types_1.types.RANGE, from: 8192, to: 8202 },
	    { type: types_1.types.CHAR, value: 8232 },
	    { type: types_1.types.CHAR, value: 8233 },
	    { type: types_1.types.CHAR, value: 8239 },
	    { type: types_1.types.CHAR, value: 8287 },
	    { type: types_1.types.CHAR, value: 12288 },
	    { type: types_1.types.CHAR, value: 65279 },
	];
	const NOTANYCHAR = () => [
	    { type: types_1.types.CHAR, value: 10 },
	    { type: types_1.types.CHAR, value: 13 },
	    { type: types_1.types.CHAR, value: 8232 },
	    { type: types_1.types.CHAR, value: 8233 },
	];
	// Predefined class objects.
	sets.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
	sets.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
	sets.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
	sets.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
	sets.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
	sets.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
	sets.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
	
	return sets;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	var __createBinding = (util && util.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (util && util.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (util && util.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(util, "__esModule", { value: true });
	util.tokenizeClass = util.strToChars = void 0;
	const types_1 = requireTypes();
	const sets = __importStar(requireSets());
	const CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
	/**
	 * Finds character representations in str and convert all to
	 * their respective characters.
	 *
	 * @param {string} str
	 * @returns {string}
	 */
	util.strToChars = (str) => {
	    const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
	    return str.replace(charsRegex, (s, b, lbs, a16, b16, dctrl, eslsh) => {
	        if (lbs) {
	            return s;
	        }
	        let code = b ? 8 :
	            a16 ? parseInt(a16, 16) :
	                b16 ? parseInt(b16, 16) :
	                    dctrl ? CTRL.indexOf(dctrl) : {
	                        0: 0,
	                        t: 9,
	                        n: 10,
	                        v: 11,
	                        f: 12,
	                        r: 13,
	                    }[eslsh];
	        let c = String.fromCharCode(code);
	        // Escape special regex characters.
	        return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
	    });
	};
	/**
	 * Turns class into tokens
	 * reads str until it encounters a ] not preceeded by a \
	 *
	 * @param {string} str
	 * @param {string} regexpStr
	 * @returns {Array.<Array.<Object>, number>}
	 */
	util.tokenizeClass = (str, regexpStr) => {
	    var _a, _b, _c, _d, _e, _f, _g;
	    let tokens = [], rs, c;
	    const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
	    while ((rs = regexp.exec(str)) !== null) {
	        const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a = (rs[1] && sets.words())) !== null && _a !== void 0 ? _a : (rs[2] && sets.ints())) !== null && _b !== void 0 ? _b : (rs[3] && sets.whitespace())) !== null && _c !== void 0 ? _c : (rs[4] && sets.notWords())) !== null && _d !== void 0 ? _d : (rs[5] && sets.notInts())) !== null && _e !== void 0 ? _e : (rs[6] && sets.notWhitespace())) !== null && _f !== void 0 ? _f : (rs[7] && {
	            type: types_1.types.RANGE,
	            from: (rs[8] || rs[9]).charCodeAt(0),
	            to: (c = rs[10]).charCodeAt(c.length - 1),
	        })) !== null && _g !== void 0 ? _g : ((c = rs[16]) && { type: types_1.types.CHAR, value: c.charCodeAt(0) });
	        if (p) {
	            tokens.push(p);
	        }
	        else {
	            return [tokens, regexp.lastIndex];
	        }
	    }
	    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
	};
	
	return util;
}

var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return tokenizer;
	hasRequiredTokenizer = 1;
	var __createBinding = (tokenizer && tokenizer.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (tokenizer && tokenizer.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (tokenizer && tokenizer.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(tokenizer, "__esModule", { value: true });
	tokenizer.tokenizer = void 0;
	const util = __importStar(requireUtil());
	const types_1 = requireTypes();
	const sets = __importStar(requireSets());
	/**
	 * Valid opening characters for capture group names.
	 */
	const captureGroupFirstChar = /^[a-zA-Z_$]$/i;
	/**
	 * Valid characters for capture group names.
	 */
	const captureGroupChars = /^[a-zA-Z0-9_$]$/i;
	const digit = /\d/;
	/**
	 * Tokenizes a regular expression (that is currently a string)
	 * @param {string} regexpStr String of regular expression to be tokenized
	 *
	 * @returns {Root}
	 */
	tokenizer.tokenizer = (regexpStr) => {
	    let i = 0, c;
	    let start = { type: types_1.types.ROOT, stack: [] };
	    // Keep track of last clause/group and stack.
	    let lastGroup = start;
	    let last = start.stack;
	    let groupStack = [];
	    let referenceQueue = [];
	    let groupCount = 0;
	    const repeatErr = (col) => {
	        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
	    };
	    // Decode a few escaped characters.
	    let str = util.strToChars(regexpStr);
	    // Iterate through each character in string.
	    while (i < str.length) {
	        switch (c = str[i++]) {
	            // Handle escaped characters, inclues a few sets.
	            case '\\':
	                if (i === str.length) {
	                    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
	                }
	                switch (c = str[i++]) {
	                    case 'b':
	                        last.push({ type: types_1.types.POSITION, value: 'b' });
	                        break;
	                    case 'B':
	                        last.push({ type: types_1.types.POSITION, value: 'B' });
	                        break;
	                    case 'w':
	                        last.push(sets.words());
	                        break;
	                    case 'W':
	                        last.push(sets.notWords());
	                        break;
	                    case 'd':
	                        last.push(sets.ints());
	                        break;
	                    case 'D':
	                        last.push(sets.notInts());
	                        break;
	                    case 's':
	                        last.push(sets.whitespace());
	                        break;
	                    case 'S':
	                        last.push(sets.notWhitespace());
	                        break;
	                    default:
	                        // Check if c is integer.
	                        // In which case it's a reference.
	                        if (digit.test(c)) {
	                            let digits = c;
	                            while (i < str.length && digit.test(str[i])) {
	                                digits += str[i++];
	                            }
	                            let value = parseInt(digits, 10);
	                            const reference = { type: types_1.types.REFERENCE, value };
	                            last.push(reference);
	                            referenceQueue.push({ reference, stack: last, index: last.length - 1 });
	                            // Escaped character.
	                        }
	                        else {
	                            last.push({ type: types_1.types.CHAR, value: c.charCodeAt(0) });
	                        }
	                }
	                break;
	            // Positionals.
	            case '^':
	                last.push({ type: types_1.types.POSITION, value: '^' });
	                break;
	            case '$':
	                last.push({ type: types_1.types.POSITION, value: '$' });
	                break;
	            // Handle custom sets.
	            case '[': {
	                // Check if this class is 'anti' i.e. [^abc].
	                let not;
	                if (str[i] === '^') {
	                    not = true;
	                    i++;
	                }
	                else {
	                    not = false;
	                }
	                // Get all the characters in class.
	                let classTokens = util.tokenizeClass(str.slice(i), regexpStr);
	                // Increase index by length of class.
	                i += classTokens[1];
	                last.push({
	                    type: types_1.types.SET,
	                    set: classTokens[0],
	                    not,
	                });
	                break;
	            }
	            // Class of any character except \n.
	            case '.':
	                last.push(sets.anyChar());
	                break;
	            // Push group onto stack.
	            case '(': {
	                // Create group.
	                let group = {
	                    type: types_1.types.GROUP,
	                    stack: [],
	                    remember: true,
	                };
	                // If this is a special kind of group.
	                if (str[i] === '?') {
	                    c = str[i + 1];
	                    i += 2;
	                    // Match if followed by.
	                    if (c === '=') {
	                        group.followedBy = true;
	                        group.remember = false;
	                        // Match if not followed by.
	                    }
	                    else if (c === '!') {
	                        group.notFollowedBy = true;
	                        group.remember = false;
	                    }
	                    else if (c === '<') {
	                        let name = '';
	                        if (captureGroupFirstChar.test(str[i])) {
	                            name += str[i];
	                            i++;
	                        }
	                        else {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` +
	                                ` after '<' at column ${i + 1}`);
	                        }
	                        while (i < str.length && captureGroupChars.test(str[i])) {
	                            name += str[i];
	                            i++;
	                        }
	                        if (!name) {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` +
	                                ` after '<' at column ${i + 1}`);
	                        }
	                        if (str[i] !== '>') {
	                            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found` +
	                                ` '${str[i]}' at column ${i + 1}`);
	                        }
	                        group.name = name;
	                        i++;
	                    }
	                    else if (c === ':') {
	                        group.remember = false;
	                    }
	                    else {
	                        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}'` +
	                            ` after '?' at column ${i - 1}`);
	                    }
	                }
	                else {
	                    groupCount += 1;
	                }
	                // Insert subgroup into current group stack.
	                last.push(group);
	                // Remember the current group for when the group closes.
	                groupStack.push(lastGroup);
	                // Make this new group the current group.
	                lastGroup = group;
	                last = group.stack;
	                break;
	            }
	            // Pop group out of stack.
	            case ')':
	                if (groupStack.length === 0) {
	                    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
	                }
	                lastGroup = groupStack.pop();
	                // Check if this group has a PIPE.
	                // To get back the correct last stack.
	                last = lastGroup.options ?
	                    lastGroup.options[lastGroup.options.length - 1] :
	                    lastGroup.stack;
	                break;
	            // Use pipe character to give more choices.
	            case '|': {
	                // Create array where options are if this is the first PIPE
	                // in this clause.
	                if (!lastGroup.options) {
	                    lastGroup.options = [lastGroup.stack];
	                    delete lastGroup.stack;
	                }
	                // Create a new stack and add to options for rest of clause.
	                let stack = [];
	                lastGroup.options.push(stack);
	                last = stack;
	                break;
	            }
	            // Repetition.
	            // For every repetition, remove last element from last stack
	            // then insert back a RANGE object.
	            // This design is chosen because there could be more than
	            // one repetition symbols in a regex i.e. `a?+{2,3}`.
	            case '{': {
	                let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
	                if (rs !== null) {
	                    if (last.length === 0) {
	                        repeatErr(i);
	                    }
	                    min = parseInt(rs[1], 10);
	                    max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
	                    i += rs[0].length;
	                    last.push({
	                        type: types_1.types.REPETITION,
	                        min,
	                        max,
	                        value: last.pop(),
	                    });
	                }
	                else {
	                    last.push({
	                        type: types_1.types.CHAR,
	                        value: 123,
	                    });
	                }
	                break;
	            }
	            case '?':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 0,
	                    max: 1,
	                    value: last.pop(),
	                });
	                break;
	            case '+':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 1,
	                    max: Infinity,
	                    value: last.pop(),
	                });
	                break;
	            case '*':
	                if (last.length === 0) {
	                    repeatErr(i);
	                }
	                last.push({
	                    type: types_1.types.REPETITION,
	                    min: 0,
	                    max: Infinity,
	                    value: last.pop(),
	                });
	                break;
	            // Default is a character that is not `\[](){}?+*^$`.
	            default:
	                last.push({
	                    type: types_1.types.CHAR,
	                    value: c.charCodeAt(0),
	                });
	        }
	    }
	    // Check if any groups have not been closed.
	    if (groupStack.length !== 0) {
	        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
	    }
	    updateReferences(referenceQueue, groupCount);
	    return start;
	};
	/**
	 * This is a side effecting function that changes references to chars
	 * if there are not enough capturing groups to reference
	 * See: https://github.com/fent/ret.js/pull/39#issuecomment-1006475703
	 * See: https://github.com/fent/ret.js/issues/38
	 * @param {(Reference | Char)[]} referenceQueue
	 * @param {number} groupCount
	 * @returns {void}
	 */
	function updateReferences(referenceQueue, groupCount) {
	    // Note: We go through the queue in reverse order so
	    // that index we use is correct even if we have to add
	    // multiple tokens to one stack
	    for (const elem of referenceQueue.reverse()) {
	        if (groupCount < elem.reference.value) {
	            // If there is nothing to reference then turn this into a char token
	            elem.reference.type = types_1.types.CHAR;
	            const valueString = elem.reference.value.toString();
	            elem.reference.value = parseInt(valueString, 8);
	            // If the number is not octal then we need to create multiple tokens
	            // https://github.com/fent/ret.js/pull/39#issuecomment-1008229226
	            if (!/^[0-7]+$/.test(valueString)) {
	                let i = 0;
	                while (valueString[i] !== '8' && valueString[i] !== '9') {
	                    i += 1;
	                }
	                if (i === 0) {
	                    // Handling case when escaped number starts with 8 or 9
	                    elem.reference.value = valueString.charCodeAt(0);
	                    i += 1;
	                }
	                else {
	                    // If the escaped number does not start with 8 or 9, then all
	                    // 0-7 digits before the first 8/9 form the first character code
	                    // see: https://github.com/fent/ret.js/pull/39#discussion_r780747085
	                    elem.reference.value = parseInt(valueString.slice(0, i), 8);
	                }
	                if (valueString.length > i) {
	                    const tail = elem.stack.splice(elem.index + 1);
	                    for (const char of valueString.slice(i)) {
	                        elem.stack.push({
	                            type: types_1.types.CHAR,
	                            value: char.charCodeAt(0),
	                        });
	                    }
	                    elem.stack.push(...tail);
	                }
	            }
	        }
	    }
	}
	
	return tokenizer;
}

var reconstruct = {};

var writeSetTokens = {};

var setsLookup = {};

var hasRequiredSetsLookup;

function requireSetsLookup () {
	if (hasRequiredSetsLookup) return setsLookup;
	hasRequiredSetsLookup = 1;
	var __createBinding = (setsLookup && setsLookup.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (setsLookup && setsLookup.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (setsLookup && setsLookup.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(setsLookup, "__esModule", { value: true });
	setsLookup.NOTANYCHAR = setsLookup.WHITESPACE = setsLookup.WORDS = setsLookup.INTS = void 0;
	const Sets = __importStar(requireSets());
	const types_1 = requireTypes();
	function setToLookup(tokens) {
	    let lookup = {};
	    let len = 0;
	    for (const token of tokens) {
	        if (token.type === types_1.types.CHAR) {
	            lookup[token.value] = true;
	        }
	        // Note this is in an if statement because
	        // the SetTokens type is (Char | Range | Set)[]
	        // so a type error is thrown if it is not.
	        // If the SetTokens type is modified the if statement
	        // can be removed
	        if (token.type === types_1.types.RANGE) {
	            lookup[`${token.from}-${token.to}`] = true;
	        }
	        len += 1;
	    }
	    return {
	        lookup: () => (Object.assign({}, lookup)),
	        len,
	    };
	}
	setsLookup.INTS = setToLookup(Sets.ints().set);
	setsLookup.WORDS = setToLookup(Sets.words().set);
	setsLookup.WHITESPACE = setToLookup(Sets.whitespace().set);
	setsLookup.NOTANYCHAR = setToLookup(Sets.anyChar().set);
	
	return setsLookup;
}

var hasRequiredWriteSetTokens;

function requireWriteSetTokens () {
	if (hasRequiredWriteSetTokens) return writeSetTokens;
	hasRequiredWriteSetTokens = 1;
	var __createBinding = (writeSetTokens && writeSetTokens.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (writeSetTokens && writeSetTokens.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (writeSetTokens && writeSetTokens.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(writeSetTokens, "__esModule", { value: true });
	writeSetTokens.writeSetTokens = writeSetTokens.setChar = void 0;
	const types_1 = requireTypes();
	const sets = __importStar(requireSetsLookup());
	/**
	 * Takes character code and returns character to be displayed in a set
	 * @param {number} charCode Character code of set element
	 * @returns {string} The string for the sets character
	 */
	function setChar(charCode) {
	    return charCode === 94 ? '\\^' :
	        charCode === 92 ? '\\\\' :
	            charCode === 93 ? '\\]' :
	                charCode === 45 ? '\\-' :
	                    String.fromCharCode(charCode);
	}
	writeSetTokens.setChar = setChar;
	/**
	 * Test if a character set matches a 'set-lookup'
	 * @param {SetTokens} set The set to be tested
	 * @param {SetLookup} param The predefined 'set-lookup' & the number of elements in the lookup
	 * @returns {boolean} True if the character set corresponds to the 'set-lookup'
	 */
	function isSameSet(set, { lookup, len }) {
	    // If the set and the lookup are not of the same length
	    // then we immediately know that the lookup will be false
	    if (len !== set.length) {
	        return false;
	    }
	    const map = lookup();
	    for (const elem of set) {
	        if (elem.type === types_1.types.SET) {
	            return false;
	        }
	        const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
	        if (map[key]) {
	            map[key] = false;
	        }
	        else {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Writes the tokens for a set
	 * @param {Set} set The set to display
	 * @param {boolean} isNested Whether the token is nested inside another set token
	 * @returns {string} The tokens for the set
	 */
	function writeSetTokens$1(set, isNested = false) {
	    if (isSameSet(set.set, sets.INTS)) {
	        return set.not ? '\\D' : '\\d';
	    }
	    if (isSameSet(set.set, sets.WORDS)) {
	        return set.not ? '\\W' : '\\w';
	    }
	    // Notanychar is only relevant when not nested inside another set token
	    if (set.not && isSameSet(set.set, sets.NOTANYCHAR)) {
	        return '.';
	    }
	    if (isSameSet(set.set, sets.WHITESPACE)) {
	        return set.not ? '\\S' : '\\s';
	    }
	    let tokenString = '';
	    for (let i = 0; i < set.set.length; i++) {
	        const subset = set.set[i];
	        tokenString += writeSetToken(subset);
	    }
	    const contents = `${set.not ? '^' : ''}${tokenString}`;
	    return isNested ? contents : `[${contents}]`;
	}
	writeSetTokens.writeSetTokens = writeSetTokens$1;
	/**
	 * Writes a token within a set
	 * @param {Range | Char | Set} set The set token to display
	 * @returns {string} The token as a string
	 */
	function writeSetToken(set) {
	    if (set.type === types_1.types.CHAR) {
	        return setChar(set.value);
	    }
	    else if (set.type === types_1.types.RANGE) {
	        return `${setChar(set.from)}-${setChar(set.to)}`;
	    }
	    return writeSetTokens$1(set, true);
	}
	
	return writeSetTokens;
}

var hasRequiredReconstruct;

function requireReconstruct () {
	if (hasRequiredReconstruct) return reconstruct;
	hasRequiredReconstruct = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.reconstruct = void 0;
		const types_1 = requireTypes();
		const write_set_tokens_1 = requireWriteSetTokens();
		const reduceStack = (stack) => stack.map(exports.reconstruct).join('');
		const createAlternate = (token) => {
		    if ('options' in token) {
		        return token.options.map(reduceStack).join('|');
		    }
		    else if ('stack' in token) {
		        return reduceStack(token.stack);
		    }
		    else {
		        throw new Error(`options or stack must be Root or Group token`);
		    }
		};
		exports.reconstruct = (token) => {
		    switch (token.type) {
		        case types_1.types.ROOT:
		            return createAlternate(token);
		        case types_1.types.CHAR: {
		            const c = String.fromCharCode(token.value);
		            // Note that the escaping for characters inside classes is handled
		            // in the write-set-tokens module so '-' and ']' are not escaped here
		            return (/[[\\{}$^.|?*+()]/.test(c) ? '\\' : '') + c;
		        }
		        case types_1.types.POSITION:
		            if (token.value === '^' || token.value === '$') {
		                return token.value;
		            }
		            else {
		                return `\\${token.value}`;
		            }
		        case types_1.types.REFERENCE:
		            return `\\${token.value}`;
		        case types_1.types.SET:
		            return write_set_tokens_1.writeSetTokens(token);
		        case types_1.types.GROUP: {
		            // Check token.remember
		            const prefix = token.name ? `?<${token.name}>` :
		                token.remember ? '' :
		                    token.followedBy ? '?=' :
		                        token.notFollowedBy ? '?!' :
		                            '?:';
		            return `(${prefix}${createAlternate(token)})`;
		        }
		        case types_1.types.REPETITION: {
		            const { min, max } = token;
		            let endWith;
		            if (min === 0 && max === 1) {
		                endWith = '?';
		            }
		            else if (min === 1 && max === Infinity) {
		                endWith = '+';
		            }
		            else if (min === 0 && max === Infinity) {
		                endWith = '*';
		            }
		            else if (max === Infinity) {
		                endWith = `{${min},}`;
		            }
		            else if (min === max) {
		                endWith = `{${min}}`;
		            }
		            else {
		                endWith = `{${min},${max}}`;
		            }
		            return `${exports.reconstruct(token.value)}${endWith}`;
		        }
		        case types_1.types.RANGE:
		            return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
		        default:
		            throw new Error(`Invalid token type ${token}`);
		    }
		};
		
	} (reconstruct));
	return reconstruct;
}

var dist$2 = dist$3.exports;

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$3.exports;
	hasRequiredDist$2 = 1;
	(function (module, exports) {
		var __createBinding = (dist$2 && dist$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$2 && dist$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.types = void 0;
		/* istanbul ignore file */
		const types_1 = requireTypes();
		Object.defineProperty(exports, "types", { enumerable: true, get: function () { return types_1.types; } });
		__exportStar(requireTokenizer(), exports);
		__exportStar(requireReconstruct(), exports);
		const tokenizer_1 = requireTokenizer();
		const reconstruct_1 = requireReconstruct();
		__exportStar(requireTypes(), exports);
		exports.default = tokenizer_1.tokenizer;
		module.exports = tokenizer_1.tokenizer;
		module.exports.types = types_1.types;
		module.exports.reconstruct = reconstruct_1.reconstruct;
		
	} (dist$3, dist$3.exports));
	return dist$3.exports;
}

var hasRequiredSafeRegex2;

function requireSafeRegex2 () {
	if (hasRequiredSafeRegex2) return safeRegex2.exports;
	hasRequiredSafeRegex2 = 1;

	const parse = requireDist$2();
	const types = parse.types;

	function safeRegex (re, opts) {
	  if (!opts) opts = {};
	  /* c8 ignore next */
	  const replimit = opts.limit === undefined ? 25 : opts.limit;

	  /* c8 ignore next 2 */
	  if (isRegExp(re)) re = re.source;
	  else if (typeof re !== 'string') re = String(re);

	  try { re = parse(re); } catch { return false }

	  let reps = 0;
	  return (function walk (node, starHeight) {
	    let i;
	    let ok;
	    let len;

	    if (node.type === types.REPETITION) {
	      starHeight++;
	      reps++;
	      if (starHeight > 1) return false
	      if (reps > replimit) return false
	    }

	    if (node.options) {
	      for (i = 0, len = node.options.length; i < len; i++) {
	        ok = walk({ stack: node.options[i] }, starHeight);
	        if (!ok) return false
	      }
	    }
	    const stack = node.stack || node.value?.stack;
	    if (!stack) return true

	    for (i = 0; i < stack.length; i++) {
	      ok = walk(stack[i], starHeight);
	      if (!ok) return false
	    }

	    return true
	  })(re, 0)
	}

	function isRegExp (x) {
	  return {}.toString.call(x) === '[object RegExp]'
	}

	safeRegex2.exports = safeRegex;
	safeRegex2.exports.default = safeRegex;
	safeRegex2.exports.safeRegex = safeRegex;
	return safeRegex2.exports;
}

var httpMethod;
var hasRequiredHttpMethod;

function requireHttpMethod () {
	if (hasRequiredHttpMethod) return httpMethod;
	hasRequiredHttpMethod = 1;

	httpMethod = {
	  name: '__fmw_internal_strategy_merged_tree_http_method__',
	  storage: function () {
	    const handlers = new Map();
	    return {
	      get: (type) => { return handlers.get(type) || null },
	      set: (type, store) => { handlers.set(type, store); }
	    }
	  },
	  /* c8 ignore next 1 */
	  deriveConstraint: (req) => req.method,
	  mustMatchWhenDerived: true
	};
	return httpMethod;
}

var prettyPrint;
var hasRequiredPrettyPrint;

function requirePrettyPrint () {
	if (hasRequiredPrettyPrint) return prettyPrint;
	hasRequiredPrettyPrint = 1;

	const deepEqual = requireFastDeepEqual();

	const httpMethodStrategy = requireHttpMethod();
	const treeDataSymbol = Symbol('treeData');

	function printObjectTree (obj, parentPrefix = '') {
	  let tree = '';
	  const keys = Object.keys(obj);
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i];
	    const value = obj[key];
	    const isLast = i === keys.length - 1;

	    const nodePrefix = isLast ? ' ' : ' ';
	    const childPrefix = isLast ? '    ' : '   ';

	    const nodeData = value[treeDataSymbol] || '';
	    const prefixedNodeData = nodeData.replaceAll('\n', '\n' + parentPrefix + childPrefix);

	    tree += parentPrefix + nodePrefix + key + prefixedNodeData + '\n';
	    tree += printObjectTree(value, parentPrefix + childPrefix);
	  }
	  return tree
	}

	function parseFunctionName (fn) {
	  let fName = fn.name || '';

	  fName = fName.replace('bound', '').trim();
	  fName = (fName || 'anonymous') + '()';
	  return fName
	}

	function parseMeta (meta) {
	  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))
	  if (typeof meta === 'symbol') return meta.toString()
	  if (typeof meta === 'function') return parseFunctionName(meta)
	  return meta
	}

	function getRouteMetaData (route, options) {
	  if (!options.includeMeta) return {}

	  const metaDataObject = options.buildPrettyMeta(route);
	  const filteredMetaData = {};

	  let includeMetaKeys = options.includeMeta;
	  if (!Array.isArray(includeMetaKeys)) {
	    includeMetaKeys = Reflect.ownKeys(metaDataObject);
	  }

	  for (const metaKey of includeMetaKeys) {
	    if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue

	    const serializedKey = metaKey.toString();
	    const metaValue = metaDataObject[metaKey];

	    if (metaValue !== undefined && metaValue !== null) {
	      const serializedValue = JSON.stringify(parseMeta(metaValue));
	      filteredMetaData[serializedKey] = serializedValue;
	    }
	  }

	  return filteredMetaData
	}

	function serializeMetaData (metaData) {
	  let serializedMetaData = '';
	  for (const [key, value] of Object.entries(metaData)) {
	    serializedMetaData += `\n (${key}) ${value}`;
	  }
	  return serializedMetaData
	}

	// get original merged tree node route
	function normalizeRoute (route) {
	  const constraints = { ...route.opts.constraints };
	  const method = constraints[httpMethodStrategy.name];
	  delete constraints[httpMethodStrategy.name];
	  return { ...route, method, opts: { constraints } }
	}

	function serializeRoute (route) {
	  let serializedRoute = ` (${route.method})`;

	  const constraints = route.opts.constraints || {};
	  if (Object.keys(constraints).length !== 0) {
	    serializedRoute += ' ' + JSON.stringify(constraints);
	  }

	  serializedRoute += serializeMetaData(route.metaData);
	  return serializedRoute
	}

	function mergeSimilarRoutes (routes) {
	  return routes.reduce((mergedRoutes, route) => {
	    for (const nodeRoute of mergedRoutes) {
	      if (
	        deepEqual(route.opts.constraints, nodeRoute.opts.constraints) &&
	        deepEqual(route.metaData, nodeRoute.metaData)
	      ) {
	        nodeRoute.method += ', ' + route.method;
	        return mergedRoutes
	      }
	    }
	    mergedRoutes.push(route);
	    return mergedRoutes
	  }, [])
	}

	function serializeNode (node, prefix, options) {
	  let routes = node.routes;

	  if (options.method === undefined) {
	    routes = routes.map(normalizeRoute);
	  }

	  routes = routes.map(route => {
	    route.metaData = getRouteMetaData(route, options);
	    return route
	  });

	  if (options.method === undefined) {
	    routes = mergeSimilarRoutes(routes);
	  }

	  return routes.map(serializeRoute).join(`\n${prefix}`)
	}

	function buildObjectTree (node, tree, prefix, options) {
	  if (node.isLeafNode || options.commonPrefix !== false) {
	    prefix = prefix || '(empty root node)';
	    tree = tree[prefix] = {};

	    if (node.isLeafNode) {
	      tree[treeDataSymbol] = serializeNode(node, prefix, options);
	    }

	    prefix = '';
	  }

	  if (node.staticChildren) {
	    for (const child of Object.values(node.staticChildren)) {
	      buildObjectTree(child, tree, prefix + child.prefix, options);
	    }
	  }

	  if (node.parametricChildren) {
	    for (const child of Object.values(node.parametricChildren)) {
	      const childPrefix = Array.from(child.nodePaths).join('|');
	      buildObjectTree(child, tree, prefix + childPrefix, options);
	    }
	  }

	  if (node.wildcardChild) {
	    buildObjectTree(node.wildcardChild, tree, '*', options);
	  }
	}

	function prettyPrintTree (root, options) {
	  const objectTree = {};
	  buildObjectTree(root, objectTree, root.prefix, options);
	  return printObjectTree(objectTree)
	}

	prettyPrint = { prettyPrintTree };
	return prettyPrint;
}

var nullObject;
var hasRequiredNullObject;

function requireNullObject () {
	if (hasRequiredNullObject) return nullObject;
	hasRequiredNullObject = 1;

	const NullObject = function () {};
	NullObject.prototype = Object.create(null);

	nullObject = {
	  NullObject
	};
	return nullObject;
}

var handlerStorage;
var hasRequiredHandlerStorage;

function requireHandlerStorage () {
	if (hasRequiredHandlerStorage) return handlerStorage;
	hasRequiredHandlerStorage = 1;

	const { NullObject } = requireNullObject();
	const httpMethodStrategy = requireHttpMethod();

	class HandlerStorage {
	  constructor () {
	    this.unconstrainedHandler = null; // optimized reference to the handler that will match most of the time
	    this.constraints = [];
	    this.handlers = []; // unoptimized list of handler objects for which the fast matcher function will be compiled
	    this.constrainedHandlerStores = null;
	  }

	  // This is the hot path for node handler finding -- change with care!
	  getMatchingHandler (derivedConstraints) {
	    if (derivedConstraints === undefined) {
	      return this.unconstrainedHandler
	    }
	    return this._getHandlerMatchingConstraints(derivedConstraints)
	  }

	  addHandler (constrainer, route) {
	    const params = route.params;
	    const constraints = route.opts.constraints || {};

	    const handlerObject = {
	      params,
	      constraints,
	      handler: route.handler,
	      store: route.store || null,
	      _createParamsObject: this._compileCreateParamsObject(params)
	    };

	    const constraintsNames = Object.keys(constraints);
	    if (constraintsNames.length === 0) {
	      this.unconstrainedHandler = handlerObject;
	    }

	    for (const constraint of constraintsNames) {
	      if (!this.constraints.includes(constraint)) {
	        if (constraint === 'version') {
	          // always check the version constraint first as it is the most selective
	          this.constraints.unshift(constraint);
	        } else {
	          this.constraints.push(constraint);
	        }
	      }
	    }

	    const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
	    if (!isMergedTree && this.handlers.length >= 31) {
	      throw new Error('find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached')
	    }

	    this.handlers.push(handlerObject);
	    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.
	    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);

	    if (!isMergedTree) {
	      this._compileGetHandlerMatchingConstraints(constrainer, constraints);
	    }
	  }

	  _compileCreateParamsObject (params) {
	    const fnBody = [];

	    fnBody.push('const fn = function _createParamsObject (paramsArray) {');

	    fnBody.push('const params = new NullObject()');
	    for (let i = 0; i < params.length; i++) {
	      fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
	    }
	    fnBody.push('return params');
	    fnBody.push('}');

	    fnBody.push('return fn');

	    return new Function('NullObject', fnBody.join('\n'))(NullObject)  // eslint-disable-line
	  }

	  _getHandlerMatchingConstraints () {
	    return null
	  }

	  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
	  // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
	  // The store's implementation comes from the strategies provided to the Router.
	  _buildConstraintStore (store, constraint) {
	    for (let i = 0; i < this.handlers.length; i++) {
	      const handler = this.handlers[i];
	      const constraintValue = handler.constraints[constraint];
	      if (constraintValue !== undefined) {
	        let indexes = store.get(constraintValue) || 0;
	        indexes |= 1 << i; // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip
	        store.set(constraintValue, indexes);
	      }
	    }
	  }

	  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
	  _constrainedIndexBitmask (constraint) {
	    let mask = 0;
	    for (let i = 0; i < this.handlers.length; i++) {
	      const handler = this.handlers[i];
	      const constraintValue = handler.constraints[constraint];
	      if (constraintValue !== undefined) {
	        mask |= 1 << i;
	      }
	    }
	    return ~mask
	  }

	  // Compile a fast function to match the handlers for this node
	  // The function implements a general case multi-constraint matching algorithm.
	  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
	  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
	  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
	  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
	  _compileGetHandlerMatchingConstraints (constrainer) {
	    this.constrainedHandlerStores = {};

	    for (const constraint of this.constraints) {
	      const store = constrainer.newStoreForConstraint(constraint);
	      this.constrainedHandlerStores[constraint] = store;

	      this._buildConstraintStore(store, constraint);
	    }

	    const lines = [];
	    lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
	    for (const constraint of this.constraints) {
	      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.
	      lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);

	      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.
	      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.
	      const strategy = constrainer.strategies[constraint];
	      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)';

	      lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
	    }

	    // There are some constraints that can be derived and marked as "must match", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.
	    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.
	    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.
	    for (const constraint in constrainer.strategies) {
	      const strategy = constrainer.strategies[constraint];
	      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
	        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
	      }
	    }

	    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit
	    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]');

	    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\n')); // eslint-disable-line
	  }
	}

	handlerStorage = HandlerStorage;
	return handlerStorage;
}

var node$2;
var hasRequiredNode$2;

function requireNode$2 () {
	if (hasRequiredNode$2) return node$2;
	hasRequiredNode$2 = 1;

	const HandlerStorage = requireHandlerStorage();

	const NODE_TYPES = {
	  STATIC: 0,
	  PARAMETRIC: 1,
	  WILDCARD: 2
	};

	class Node {
	  constructor () {
	    this.isLeafNode = false;
	    this.routes = null;
	    this.handlerStorage = null;
	  }

	  addRoute (route, constrainer) {
	    if (this.routes === null) {
	      this.routes = [];
	    }
	    if (this.handlerStorage === null) {
	      this.handlerStorage = new HandlerStorage();
	    }
	    this.isLeafNode = true;
	    this.routes.push(route);
	    this.handlerStorage.addHandler(constrainer, route);
	  }
	}

	class ParentNode extends Node {
	  constructor () {
	    super();
	    this.staticChildren = {};
	  }

	  findStaticMatchingChild (path, pathIndex) {
	    const staticChild = this.staticChildren[path.charAt(pathIndex)];
	    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {
	      return null
	    }
	    return staticChild
	  }

	  getStaticChild (path, pathIndex = 0) {
	    if (path.length === pathIndex) {
	      return this
	    }

	    const staticChild = this.findStaticMatchingChild(path, pathIndex);
	    if (staticChild) {
	      return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length)
	    }

	    return null
	  }

	  createStaticChild (path) {
	    if (path.length === 0) {
	      return this
	    }

	    let staticChild = this.staticChildren[path.charAt(0)];
	    if (staticChild) {
	      let i = 1;
	      for (; i < staticChild.prefix.length; i++) {
	        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
	          staticChild = staticChild.split(this, i);
	          break
	        }
	      }
	      return staticChild.createStaticChild(path.slice(i))
	    }

	    const label = path.charAt(0);
	    this.staticChildren[label] = new StaticNode(path);
	    return this.staticChildren[label]
	  }
	}

	class StaticNode extends ParentNode {
	  constructor (prefix) {
	    super();
	    this.prefix = prefix;
	    this.wildcardChild = null;
	    this.parametricChildren = [];
	    this.kind = NODE_TYPES.STATIC;
	    this._compilePrefixMatch();
	  }

	  getParametricChild (regex) {
	    const regexpSource = regex && regex.source;

	    const parametricChild = this.parametricChildren.find(child => {
	      const childRegexSource = child.regex && child.regex.source;
	      return childRegexSource === regexpSource
	    });

	    if (parametricChild) {
	      return parametricChild
	    }

	    return null
	  }

	  createParametricChild (regex, staticSuffix, nodePath) {
	    let parametricChild = this.getParametricChild(regex);
	    if (parametricChild) {
	      parametricChild.nodePaths.add(nodePath);
	      return parametricChild
	    }

	    parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
	    this.parametricChildren.push(parametricChild);
	    this.parametricChildren.sort((child1, child2) => {
	      if (!child1.isRegex) return 1
	      if (!child2.isRegex) return -1

	      if (child1.staticSuffix === null) return 1
	      if (child2.staticSuffix === null) return -1

	      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1
	      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1

	      return 0
	    });

	    return parametricChild
	  }

	  getWildcardChild () {
	    return this.wildcardChild
	  }

	  createWildcardChild () {
	    this.wildcardChild = this.getWildcardChild() || new WildcardNode();
	    return this.wildcardChild
	  }

	  split (parentNode, length) {
	    const parentPrefix = this.prefix.slice(0, length);
	    const childPrefix = this.prefix.slice(length);

	    this.prefix = childPrefix;
	    this._compilePrefixMatch();

	    const staticNode = new StaticNode(parentPrefix);
	    staticNode.staticChildren[childPrefix.charAt(0)] = this;
	    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;

	    return staticNode
	  }

	  getNextNode (path, pathIndex, nodeStack, paramsCount) {
	    let node = this.findStaticMatchingChild(path, pathIndex);
	    let parametricBrotherNodeIndex = 0;

	    if (node === null) {
	      if (this.parametricChildren.length === 0) {
	        return this.wildcardChild
	      }

	      node = this.parametricChildren[0];
	      parametricBrotherNodeIndex = 1;
	    }

	    if (this.wildcardChild !== null) {
	      nodeStack.push({
	        paramsCount,
	        brotherPathIndex: pathIndex,
	        brotherNode: this.wildcardChild
	      });
	    }

	    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
	      nodeStack.push({
	        paramsCount,
	        brotherPathIndex: pathIndex,
	        brotherNode: this.parametricChildren[i]
	      });
	    }

	    return node
	  }

	  _compilePrefixMatch () {
	    if (this.prefix.length === 1) {
	      this.matchPrefix = () => true;
	      return
	    }

	    const lines = [];
	    for (let i = 1; i < this.prefix.length; i++) {
	      const charCode = this.prefix.charCodeAt(i);
	      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
	    }
	    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`); // eslint-disable-line
	  }
	}

	class ParametricNode extends ParentNode {
	  constructor (regex, staticSuffix, nodePath) {
	    super();
	    this.isRegex = !!regex;
	    this.regex = regex || null;
	    this.staticSuffix = staticSuffix || null;
	    this.kind = NODE_TYPES.PARAMETRIC;

	    this.nodePaths = new Set([nodePath]);
	  }

	  getNextNode (path, pathIndex) {
	    return this.findStaticMatchingChild(path, pathIndex)
	  }
	}

	class WildcardNode extends Node {
	  constructor () {
	    super();
	    this.kind = NODE_TYPES.WILDCARD;
	  }

	  getNextNode () {
	    return null
	  }
	}

	node$2 = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
	return node$2;
}

var acceptVersion;
var hasRequiredAcceptVersion;

function requireAcceptVersion () {
	if (hasRequiredAcceptVersion) return acceptVersion;
	hasRequiredAcceptVersion = 1;

	const assert = require$$0$b;

	function SemVerStore () {
	  if (!(this instanceof SemVerStore)) {
	    return new SemVerStore()
	  }

	  this.store = new Map();
	  this.maxMajor = 0;
	  this.maxMinors = {};
	  this.maxPatches = {};
	}

	SemVerStore.prototype.set = function (version, store) {
	  if (typeof version !== 'string') {
	    throw new TypeError('Version should be a string')
	  }
	  let [major, minor, patch] = version.split('.', 3);

	  if (isNaN(major)) {
	    throw new TypeError('Major version must be a numeric value')
	  }

	  major = Number(major);
	  minor = Number(minor) || 0;
	  patch = Number(patch) || 0;

	  if (major >= this.maxMajor) {
	    this.maxMajor = major;
	    this.store.set('x', store);
	    this.store.set('*', store);
	    this.store.set('x.x', store);
	    this.store.set('x.x.x', store);
	  }

	  if (minor >= (this.maxMinors[major] || 0)) {
	    this.maxMinors[major] = minor;
	    this.store.set(`${major}.x`, store);
	    this.store.set(`${major}.x.x`, store);
	  }

	  if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
	    this.maxPatches[`${major}.${minor}`] = patch;
	    this.store.set(`${major}.${minor}.x`, store);
	  }

	  this.store.set(`${major}.${minor}.${patch}`, store);
	  return this
	};

	SemVerStore.prototype.get = function (version) {
	  return this.store.get(version)
	};

	acceptVersion = {
	  name: 'version',
	  mustMatchWhenDerived: true,
	  storage: SemVerStore,
	  validate (value) {
	    assert(typeof value === 'string', 'Version should be a string');
	  }
	};
	return acceptVersion;
}

var acceptHost;
var hasRequiredAcceptHost;

function requireAcceptHost () {
	if (hasRequiredAcceptHost) return acceptHost;
	hasRequiredAcceptHost = 1;
	const assert = require$$0$b;

	function HostStorage () {
	  const hosts = new Map();
	  const regexHosts = [];
	  return {
	    get: (host) => {
	      const exact = hosts.get(host);
	      if (exact) {
	        return exact
	      }
	      for (const regex of regexHosts) {
	        if (regex.host.test(host)) {
	          return regex.value
	        }
	      }
	    },
	    set: (host, value) => {
	      if (host instanceof RegExp) {
	        regexHosts.push({ host, value });
	      } else {
	        hosts.set(host, value);
	      }
	    }
	  }
	}

	acceptHost = {
	  name: 'host',
	  mustMatchWhenDerived: false,
	  storage: HostStorage,
	  validate (value) {
	    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp');
	  }
	};
	return acceptHost;
}

var constrainer;
var hasRequiredConstrainer;

function requireConstrainer () {
	if (hasRequiredConstrainer) return constrainer;
	hasRequiredConstrainer = 1;

	const acceptVersionStrategy = requireAcceptVersion();
	const acceptHostStrategy = requireAcceptHost();
	const assert = require$$0$b;

	class Constrainer {
	  constructor (customStrategies) {
	    this.strategies = {
	      version: acceptVersionStrategy,
	      host: acceptHostStrategy
	    };

	    this.strategiesInUse = new Set();
	    this.asyncStrategiesInUse = new Set();

	    // validate and optimize prototypes of given custom strategies
	    if (customStrategies) {
	      for (const strategy of Object.values(customStrategies)) {
	        this.addConstraintStrategy(strategy);
	      }
	    }
	  }

	  isStrategyUsed (strategyName) {
	    return this.strategiesInUse.has(strategyName) ||
	      this.asyncStrategiesInUse.has(strategyName)
	  }

	  hasConstraintStrategy (strategyName) {
	    const customConstraintStrategy = this.strategies[strategyName];
	    if (customConstraintStrategy !== undefined) {
	      return customConstraintStrategy.isCustom ||
	        this.isStrategyUsed(strategyName)
	    }
	    return false
	  }

	  addConstraintStrategy (strategy) {
	    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.');
	    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.');
	    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.');

	    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
	      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)
	    }

	    if (this.isStrategyUsed(strategy.name)) {
	      throw new Error(`There already exists a route with ${strategy.name} constraint.`)
	    }

	    strategy.isCustom = true;
	    strategy.isAsync = strategy.deriveConstraint.length === 3;
	    this.strategies[strategy.name] = strategy;

	    if (strategy.mustMatchWhenDerived) {
	      this.noteUsage({ [strategy.name]: strategy });
	    }
	  }

	  deriveConstraints (req, ctx, done) {
	    const constraints = this.deriveSyncConstraints(req, ctx);

	    if (done === undefined) {
	      return constraints
	    }

	    this.deriveAsyncConstraints(constraints, req, ctx, done);
	  }

	  deriveSyncConstraints (req, ctx) {
	    return undefined
	  }

	  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
	  noteUsage (constraints) {
	    if (constraints) {
	      const beforeSize = this.strategiesInUse.size;
	      for (const key in constraints) {
	        const strategy = this.strategies[key];
	        if (strategy.isAsync) {
	          this.asyncStrategiesInUse.add(key);
	        } else {
	          this.strategiesInUse.add(key);
	        }
	      }
	      if (beforeSize !== this.strategiesInUse.size) {
	        this._buildDeriveConstraints();
	      }
	    }
	  }

	  newStoreForConstraint (constraint) {
	    if (!this.strategies[constraint]) {
	      throw new Error(`No strategy registered for constraint key ${constraint}`)
	    }
	    return this.strategies[constraint].storage()
	  }

	  validateConstraints (constraints) {
	    for (const key in constraints) {
	      const value = constraints[key];
	      if (typeof value === 'undefined') {
	        throw new Error('Can\'t pass an undefined constraint value, must pass null or no key at all')
	      }
	      const strategy = this.strategies[key];
	      if (!strategy) {
	        throw new Error(`No strategy registered for constraint key ${key}`)
	      }
	      if (strategy.validate) {
	        strategy.validate(value);
	      }
	    }
	  }

	  deriveAsyncConstraints (constraints, req, ctx, done) {
	    let asyncConstraintsCount = this.asyncStrategiesInUse.size;

	    if (asyncConstraintsCount === 0) {
	      done(null, constraints);
	      return
	    }

	    constraints = constraints || {};
	    for (const key of this.asyncStrategiesInUse) {
	      const strategy = this.strategies[key];
	      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
	        if (err !== null) {
	          done(err);
	          return
	        }

	        constraints[key] = constraintValue;

	        if (--asyncConstraintsCount === 0) {
	          done(null, constraints);
	        }
	      });
	    }
	  }

	  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
	  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
	  // This allows us to not allocate an object to hold constraint values if no constraints are defined.
	  _buildDeriveConstraints () {
	    if (this.strategiesInUse.size === 0) return

	    const lines = ['return {'];

	    for (const key of this.strategiesInUse) {
	      const strategy = this.strategies[key];
	      // Optimization: inline the derivation for the common built in constraints
	      if (!strategy.isCustom) {
	        if (key === 'version') {
	          lines.push('   version: req.headers[\'accept-version\'],');
	        } else {
	          lines.push('   host: req.headers.host || req.headers[\':authority\'],');
	        }
	      } else {
	        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
	      }
	    }

	    lines.push('}');

	    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\n')).bind(this); // eslint-disable-line
	  }
	}

	constrainer = Constrainer;
	return constrainer;
}

var httpMethods_1;
var hasRequiredHttpMethods;

function requireHttpMethods () {
	if (hasRequiredHttpMethods) return httpMethods_1;
	hasRequiredHttpMethods = 1;

	// defined by Node.js http module, a snapshot from Node.js 22.9.0
	const httpMethods = [
	  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',
	  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',
	  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',
	  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'QUERY',
	  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',
	  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'
	];

	httpMethods_1 = httpMethods;
	return httpMethods_1;
}

var urlSanitizer;
var hasRequiredUrlSanitizer;

function requireUrlSanitizer () {
	if (hasRequiredUrlSanitizer) return urlSanitizer;
	hasRequiredUrlSanitizer = 1;

	// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)
	// The chars are: # $ & + , / : ; = ? @
	function decodeComponentChar (highCharCode, lowCharCode) {
	  if (highCharCode === 50) {
	    if (lowCharCode === 53) return '%'

	    if (lowCharCode === 51) return '#'
	    if (lowCharCode === 52) return '$'
	    if (lowCharCode === 54) return '&'
	    if (lowCharCode === 66) return '+'
	    if (lowCharCode === 98) return '+'
	    if (lowCharCode === 67) return ','
	    if (lowCharCode === 99) return ','
	    if (lowCharCode === 70) return '/'
	    if (lowCharCode === 102) return '/'
	    return null
	  }
	  if (highCharCode === 51) {
	    if (lowCharCode === 65) return ':'
	    if (lowCharCode === 97) return ':'
	    if (lowCharCode === 66) return ';'
	    if (lowCharCode === 98) return ';'
	    if (lowCharCode === 68) return '='
	    if (lowCharCode === 100) return '='
	    if (lowCharCode === 70) return '?'
	    if (lowCharCode === 102) return '?'
	    return null
	  }
	  if (highCharCode === 52 && lowCharCode === 48) {
	    return '@'
	  }
	  return null
	}

	function safeDecodeURI (path, useSemicolonDelimiter) {
	  let shouldDecode = false;
	  let shouldDecodeParam = false;

	  let querystring = '';

	  for (let i = 1; i < path.length; i++) {
	    const charCode = path.charCodeAt(i);

	    if (charCode === 37) {
	      const highCharCode = path.charCodeAt(i + 1);
	      const lowCharCode = path.charCodeAt(i + 2);

	      if (decodeComponentChar(highCharCode, lowCharCode) === null) {
	        shouldDecode = true;
	      } else {
	        shouldDecodeParam = true;
	        // %25 - encoded % char. We need to encode one more time to prevent double decoding
	        if (highCharCode === 50 && lowCharCode === 53) {
	          shouldDecode = true;
	          path = path.slice(0, i + 1) + '25' + path.slice(i + 1);
	          i += 2;
	        }
	        i += 2;
	      }
	    // Some systems do not follow RFC and separate the path and query
	    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.
	    // Thus, we need to split on `;` as well as `?` and `#` if the useSemicolonDelimiter option is enabled.
	    } else if (charCode === 63 || charCode === 35 || (charCode === 59 && useSemicolonDelimiter)) {
	      querystring = path.slice(i + 1);
	      path = path.slice(0, i);
	      break
	    }
	  }
	  const decodedPath = shouldDecode ? decodeURI(path) : path;
	  return { path: decodedPath, querystring, shouldDecodeParam }
	}

	function safeDecodeURIComponent (uriComponent) {
	  const startIndex = uriComponent.indexOf('%');
	  if (startIndex === -1) return uriComponent

	  let decoded = '';
	  let lastIndex = startIndex;

	  for (let i = startIndex; i < uriComponent.length; i++) {
	    if (uriComponent.charCodeAt(i) === 37) {
	      const highCharCode = uriComponent.charCodeAt(i + 1);
	      const lowCharCode = uriComponent.charCodeAt(i + 2);

	      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
	      decoded += uriComponent.slice(lastIndex, i) + decodedChar;

	      lastIndex = i + 3;
	    }
	  }
	  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)
	}

	urlSanitizer = { safeDecodeURI, safeDecodeURIComponent };
	return urlSanitizer;
}

var findMyWay;
var hasRequiredFindMyWay;

function requireFindMyWay () {
	if (hasRequiredFindMyWay) return findMyWay;
	hasRequiredFindMyWay = 1;

	/*
	  Char codes:
	    '!': 33 - !
	    '#': 35 - %23
	    '$': 36 - %24
	    '%': 37 - %25
	    '&': 38 - %26
	    ''': 39 - '
	    '(': 40 - (
	    ')': 41 - )
	    '*': 42 - *
	    '+': 43 - %2B
	    ',': 44 - %2C
	    '-': 45 - -
	    '.': 46 - .
	    '/': 47 - %2F
	    ':': 58 - %3A
	    ';': 59 - %3B
	    '=': 61 - %3D
	    '?': 63 - %3F
	    '@': 64 - %40
	    '_': 95 - _
	    '~': 126 - ~
	*/

	const assert = require$$0$b;
	const querystring = requireLib();
	const isRegexSafe = requireSafeRegex2();
	const deepEqual = requireFastDeepEqual();
	const { prettyPrintTree } = requirePrettyPrint();
	const { StaticNode, NODE_TYPES } = requireNode$2();
	const Constrainer = requireConstrainer();
	const httpMethods = requireHttpMethods();
	const httpMethodStrategy = requireHttpMethod();
	const { safeDecodeURI, safeDecodeURIComponent } = requireUrlSanitizer();

	const FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
	const OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
	const ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
	const REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;

	if (!isRegexSafe(FULL_PATH_REGEXP)) {
	  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
	  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(ESCAPE_REGEXP)) {
	  throw new Error('the ESCAPE_REGEXP is not safe, update this module')
	}

	if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
	  throw new Error('the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module')
	}

	function Router (opts) {
	  if (!(this instanceof Router)) {
	    return new Router(opts)
	  }
	  opts = opts || {};
	  this._opts = opts;

	  if (opts.defaultRoute) {
	    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function');
	    this.defaultRoute = opts.defaultRoute;
	  } else {
	    this.defaultRoute = null;
	  }

	  if (opts.onBadUrl) {
	    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function');
	    this.onBadUrl = opts.onBadUrl;
	  } else {
	    this.onBadUrl = null;
	  }

	  if (opts.buildPrettyMeta) {
	    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function');
	    this.buildPrettyMeta = opts.buildPrettyMeta;
	  } else {
	    this.buildPrettyMeta = defaultBuildPrettyMeta;
	  }

	  if (opts.querystringParser) {
	    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function');
	    this.querystringParser = opts.querystringParser;
	  } else {
	    this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
	  }

	  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;
	  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
	  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
	  this.maxParamLength = opts.maxParamLength || 100;
	  this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
	  this.constrainer = new Constrainer(opts.constraints);
	  this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;

	  this.routes = [];
	  this.trees = {};
	}

	Router.prototype.on = function on (method, path, opts, handler, store) {
	  if (typeof opts === 'function') {
	    if (handler !== undefined) {
	      store = handler;
	    }
	    handler = opts;
	    opts = {};
	  }
	  // path validation
	  assert(typeof path === 'string', 'Path should be a string');
	  assert(path.length > 0, 'The path could not be empty');
	  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`');
	  // handler validation
	  assert(typeof handler === 'function', 'Handler should be a function');

	  // path ends with optional parameter
	  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
	  if (optionalParamMatch) {
	    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path');

	    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2');
	    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2') || '/';

	    this.on(method, pathFull, opts, handler, store);
	    this.on(method, pathOptional, opts, handler, store);
	    return
	  }

	  const route = path;

	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const methods = Array.isArray(method) ? method : [method];
	  for (const method of methods) {
	    assert(typeof method === 'string', 'Method should be a string');
	    assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
	    this._on(method, path, opts, handler, store, route);
	  }
	};

	Router.prototype._on = function _on (method, path, opts, handler, store) {
	  let constraints = {};
	  if (opts.constraints !== undefined) {
	    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object');
	    if (Object.keys(opts.constraints).length !== 0) {
	      constraints = opts.constraints;
	    }
	  }

	  this.constrainer.validateConstraints(constraints);
	  // Let the constrainer know if any constraints are being used now
	  this.constrainer.noteUsage(constraints);

	  // Boot the tree for this method if it doesn't exist yet
	  if (this.trees[method] === undefined) {
	    this.trees[method] = new StaticNode('/');
	  }

	  let pattern = path;
	  if (pattern === '*' && this.trees[method].prefix.length !== 0) {
	    const currentRoot = this.trees[method];
	    this.trees[method] = new StaticNode('');
	    this.trees[method].staticChildren['/'] = currentRoot;
	  }

	  let currentNode = this.trees[method];
	  let parentNodePathIndex = currentNode.prefix.length;

	  const params = [];
	  for (let i = 0; i <= pattern.length; i++) {
	    if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
	      // It's a double colon
	      i++;
	      continue
	    }

	    const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
	    const isWildcardNode = pattern.charCodeAt(i) === 42;

	    if (isParametricNode || isWildcardNode || (i === pattern.length && i !== parentNodePathIndex)) {
	      let staticNodePath = pattern.slice(parentNodePathIndex, i);
	      if (!this.caseSensitive) {
	        staticNodePath = staticNodePath.toLowerCase();
	      }
	      staticNodePath = staticNodePath.replaceAll('::', ':');
	      staticNodePath = staticNodePath.replaceAll('%', '%25');
	      // add the static part of the route to the tree
	      currentNode = currentNode.createStaticChild(staticNodePath);
	    }

	    if (isParametricNode) {
	      let isRegexNode = false;
	      let isParamSafe = true;
	      let backtrack = '';
	      const regexps = [];

	      let lastParamStartIndex = i + 1;
	      for (let j = lastParamStartIndex; ; j++) {
	        const charCode = pattern.charCodeAt(j);

	        const isRegexParam = charCode === 40;
	        const isStaticPart = charCode === 45 || charCode === 46;
	        const isEndOfNode = charCode === 47 || j === pattern.length;

	        if (isRegexParam || isStaticPart || isEndOfNode) {
	          const paramName = pattern.slice(lastParamStartIndex, j);
	          params.push(paramName);

	          isRegexNode = isRegexNode || isRegexParam || isStaticPart;

	          if (isRegexParam) {
	            const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
	            const regexString = pattern.slice(j, endOfRegexIndex + 1);

	            if (!this.allowUnsafeRegex) {
	              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
	            }

	            regexps.push(trimRegExpStartAndEnd(regexString));

	            j = endOfRegexIndex + 1;
	            isParamSafe = true;
	          } else {
	            regexps.push(isParamSafe ? '(.*?)' : `(${backtrack}|(?:(?!${backtrack}).)*)`);
	            isParamSafe = false;
	          }

	          const staticPartStartIndex = j;
	          for (; j < pattern.length; j++) {
	            const charCode = pattern.charCodeAt(j);
	            if (charCode === 47) break
	            if (charCode === 58) {
	              const nextCharCode = pattern.charCodeAt(j + 1);
	              if (nextCharCode === 58) j++;
	              else break
	            }
	          }

	          let staticPart = pattern.slice(staticPartStartIndex, j);
	          if (staticPart) {
	            staticPart = staticPart.replaceAll('::', ':');
	            staticPart = staticPart.replaceAll('%', '%25');
	            regexps.push(backtrack = escapeRegExp(staticPart));
	          }

	          lastParamStartIndex = j + 1;

	          if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
	            const nodePattern = isRegexNode ? '()' + staticPart : staticPart;
	            const nodePath = pattern.slice(i, j);

	            pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
	            i += nodePattern.length;

	            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null;
	            currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
	            parentNodePathIndex = i + 1;
	            break
	          }
	        }
	      }
	    } else if (isWildcardNode) {
	      // add the wildcard parameter
	      params.push('*');
	      currentNode = currentNode.createWildcardChild();
	      parentNodePathIndex = i + 1;

	      if (i !== pattern.length - 1) {
	        throw new Error('Wildcard must be the last character in the route')
	      }
	    }
	  }

	  if (!this.caseSensitive) {
	    pattern = pattern.toLowerCase();
	  }

	  if (pattern === '*') {
	    pattern = '/*';
	  }

	  for (const existRoute of this.routes) {
	    const routeConstraints = existRoute.opts.constraints || {};
	    if (
	      existRoute.method === method &&
	      existRoute.pattern === pattern &&
	      deepEqual(routeConstraints, constraints)
	    ) {
	      throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`)
	    }
	  }

	  const route = { method, path, pattern, params, opts, handler, store };
	  this.routes.push(route);
	  currentNode.addRoute(route, this.constrainer);
	};

	Router.prototype.hasRoute = function hasRoute (method, path, constraints) {
	  const route = this.findRoute(method, path, constraints);
	  return route !== null
	};

	Router.prototype.findRoute = function findNode (method, path, constraints = {}) {
	  if (this.trees[method] === undefined) {
	    return null
	  }

	  let pattern = path;

	  let currentNode = this.trees[method];
	  let parentNodePathIndex = currentNode.prefix.length;
	  for (let i = 0; i <= pattern.length; i++) {
	    if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
	      // It's a double colon
	      i++;
	      continue
	    }

	    const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
	    const isWildcardNode = pattern.charCodeAt(i) === 42;

	    if (isParametricNode || isWildcardNode || (i === pattern.length && i !== parentNodePathIndex)) {
	      let staticNodePath = pattern.slice(parentNodePathIndex, i);
	      if (!this.caseSensitive) {
	        staticNodePath = staticNodePath.toLowerCase();
	      }
	      staticNodePath = staticNodePath.replaceAll('::', ':');
	      staticNodePath = staticNodePath.replaceAll('%', '%25');
	      // add the static part of the route to the tree
	      currentNode = currentNode.getStaticChild(staticNodePath);
	      if (currentNode === null) {
	        return null
	      }
	    }

	    if (isParametricNode) {
	      let isRegexNode = false;
	      let isParamSafe = true;
	      let backtrack = '';
	      const regexps = [];

	      let lastParamStartIndex = i + 1;
	      for (let j = lastParamStartIndex; ; j++) {
	        const charCode = pattern.charCodeAt(j);

	        const isRegexParam = charCode === 40;
	        const isStaticPart = charCode === 45 || charCode === 46;
	        const isEndOfNode = charCode === 47 || j === pattern.length;

	        if (isRegexParam || isStaticPart || isEndOfNode) {
	          pattern.slice(lastParamStartIndex, j);

	          isRegexNode = isRegexNode || isRegexParam || isStaticPart;

	          if (isRegexParam) {
	            const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
	            const regexString = pattern.slice(j, endOfRegexIndex + 1);

	            if (!this.allowUnsafeRegex) {
	              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
	            }

	            regexps.push(trimRegExpStartAndEnd(regexString));

	            j = endOfRegexIndex + 1;
	            isParamSafe = false;
	          } else {
	            regexps.push(isParamSafe ? '(.*?)' : `(${backtrack}|(?:(?!${backtrack}).)*)`);
	            isParamSafe = false;
	          }

	          const staticPartStartIndex = j;
	          for (; j < pattern.length; j++) {
	            const charCode = pattern.charCodeAt(j);
	            if (charCode === 47) break
	            if (charCode === 58) {
	              const nextCharCode = pattern.charCodeAt(j + 1);
	              if (nextCharCode === 58) j++;
	              else break
	            }
	          }

	          let staticPart = pattern.slice(staticPartStartIndex, j);
	          if (staticPart) {
	            staticPart = staticPart.replaceAll('::', ':');
	            staticPart = staticPart.replaceAll('%', '%25');
	            regexps.push(backtrack = escapeRegExp(staticPart));
	          }

	          lastParamStartIndex = j + 1;

	          if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
	            const nodePattern = isRegexNode ? '()' + staticPart : staticPart;
	            const nodePath = pattern.slice(i, j);

	            pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
	            i += nodePattern.length;

	            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null;
	            currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
	            if (currentNode === null) {
	              return null
	            }
	            parentNodePathIndex = i + 1;
	            break
	          }
	        }
	      }
	    } else if (isWildcardNode) {
	      currentNode = currentNode.getWildcardChild();

	      parentNodePathIndex = i + 1;

	      if (i !== pattern.length - 1) {
	        throw new Error('Wildcard must be the last character in the route')
	      }
	    }
	  }

	  if (!this.caseSensitive) {
	    pattern = pattern.toLowerCase();
	  }

	  for (const existRoute of this.routes) {
	    const routeConstraints = existRoute.opts.constraints || {};
	    if (
	      existRoute.method === method &&
	      existRoute.pattern === pattern &&
	      deepEqual(routeConstraints, constraints)
	    ) {
	      return {
	        handler: existRoute.handler,
	        store: existRoute.store,
	        params: existRoute.params
	      }
	    }
	  }

	  return null
	};

	Router.prototype.hasConstraintStrategy = function (strategyName) {
	  return this.constrainer.hasConstraintStrategy(strategyName)
	};

	Router.prototype.addConstraintStrategy = function (constraints) {
	  this.constrainer.addConstraintStrategy(constraints);
	  this._rebuild(this.routes);
	};

	Router.prototype.reset = function reset () {
	  this.trees = {};
	  this.routes = [];
	};

	Router.prototype.off = function off (method, path, constraints) {
	  // path validation
	  assert(typeof path === 'string', 'Path should be a string');
	  assert(path.length > 0, 'The path could not be empty');
	  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`');
	  // options validation
	  assert(
	    typeof constraints === 'undefined' ||
	    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),
	    'Constraints should be an object or undefined.');

	  // path ends with optional parameter
	  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
	  if (optionalParamMatch) {
	    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path');

	    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2');
	    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2');

	    this.off(method, pathFull, constraints);
	    this.off(method, pathOptional, constraints);
	    return
	  }

	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const methods = Array.isArray(method) ? method : [method];
	  for (const method of methods) {
	    this._off(method, path, constraints);
	  }
	};

	Router.prototype._off = function _off (method, path, constraints) {
	  // method validation
	  assert(typeof method === 'string', 'Method should be a string');
	  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);

	  function matcherWithoutConstraints (route) {
	    return method !== route.method || path !== route.path
	  }

	  function matcherWithConstraints (route) {
	    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})
	  }

	  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;

	  // Rebuild tree without the specific route
	  const newRoutes = this.routes.filter(predicate);
	  this._rebuild(newRoutes);
	};

	Router.prototype.lookup = function lookup (req, res, ctx, done) {
	  if (typeof ctx === 'function') {
	    done = ctx;
	    ctx = undefined;
	  }

	  if (done === undefined) {
	    const constraints = this.constrainer.deriveConstraints(req, ctx);
	    const handle = this.find(req.method, req.url, constraints);
	    return this.callHandler(handle, req, res, ctx)
	  }

	  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
	    if (err !== null) {
	      done(err);
	      return
	    }

	    try {
	      const handle = this.find(req.method, req.url, constraints);
	      const result = this.callHandler(handle, req, res, ctx);
	      done(null, result);
	    } catch (err) {
	      done(err);
	    }
	  });
	};

	Router.prototype.callHandler = function callHandler (handle, req, res, ctx) {
	  if (handle === null) return this._defaultRoute(req, res, ctx)
	  return ctx === undefined
	    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)
	    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)
	};

	Router.prototype.find = function find (method, path, derivedConstraints) {
	  let currentNode = this.trees[method];
	  if (currentNode === undefined) return null

	  if (path.charCodeAt(0) !== 47) { // 47 is '/'
	    path = path.replace(FULL_PATH_REGEXP, '/');
	  }

	  // This must be run before sanitizeUrl as the resulting function
	  // .sliceParameter must be constructed with same URL string used
	  // throughout the rest of this function.
	  if (this.ignoreDuplicateSlashes) {
	    path = removeDuplicateSlashes(path);
	  }

	  let sanitizedUrl;
	  let querystring;
	  let shouldDecodeParam;

	  try {
	    sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
	    path = sanitizedUrl.path;
	    querystring = sanitizedUrl.querystring;
	    shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
	  } catch (error) {
	    return this._onBadUrl(path)
	  }

	  if (this.ignoreTrailingSlash) {
	    path = trimLastSlash(path);
	  }

	  const originPath = path;

	  if (this.caseSensitive === false) {
	    path = path.toLowerCase();
	  }

	  const maxParamLength = this.maxParamLength;

	  let pathIndex = currentNode.prefix.length;
	  const params = [];
	  const pathLen = path.length;

	  const brothersNodesStack = [];

	  while (true) {
	    if (pathIndex === pathLen && currentNode.isLeafNode) {
	      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
	      if (handle !== null) {
	        return {
	          handler: handle.handler,
	          store: handle.store,
	          params: handle._createParamsObject(params),
	          searchParams: this.querystringParser(querystring)
	        }
	      }
	    }

	    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);

	    if (node === null) {
	      if (brothersNodesStack.length === 0) {
	        return null
	      }

	      const brotherNodeState = brothersNodesStack.pop();
	      pathIndex = brotherNodeState.brotherPathIndex;
	      params.splice(brotherNodeState.paramsCount);
	      node = brotherNodeState.brotherNode;
	    }

	    currentNode = node;

	    // static route
	    if (currentNode.kind === NODE_TYPES.STATIC) {
	      pathIndex += currentNode.prefix.length;
	      continue
	    }

	    if (currentNode.kind === NODE_TYPES.WILDCARD) {
	      let param = originPath.slice(pathIndex);
	      if (shouldDecodeParam) {
	        param = safeDecodeURIComponent(param);
	      }

	      params.push(param);
	      pathIndex = pathLen;
	      continue
	    }

	    // parametric node
	    let paramEndIndex = originPath.indexOf('/', pathIndex);
	    if (paramEndIndex === -1) {
	      paramEndIndex = pathLen;
	    }

	    let param = originPath.slice(pathIndex, paramEndIndex);
	    if (shouldDecodeParam) {
	      param = safeDecodeURIComponent(param);
	    }

	    if (currentNode.isRegex) {
	      const matchedParameters = currentNode.regex.exec(param);
	      if (matchedParameters === null) continue

	      for (let i = 1; i < matchedParameters.length; i++) {
	        const matchedParam = matchedParameters[i];
	        if (matchedParam.length > maxParamLength) {
	          return null
	        }
	        params.push(matchedParam);
	      }
	    } else {
	      if (param.length > maxParamLength) {
	        return null
	      }
	      params.push(param);
	    }

	    pathIndex = paramEndIndex;
	  }
	};

	Router.prototype._rebuild = function (routes) {
	  this.reset();

	  for (const route of routes) {
	    const { method, path, opts, handler, store } = route;
	    this._on(method, path, opts, handler, store);
	  }
	};

	Router.prototype._defaultRoute = function (req, res, ctx) {
	  if (this.defaultRoute !== null) {
	    return ctx === undefined
	      ? this.defaultRoute(req, res)
	      : this.defaultRoute.call(ctx, req, res)
	  } else {
	    res.statusCode = 404;
	    res.end();
	  }
	};

	Router.prototype._onBadUrl = function (path) {
	  if (this.onBadUrl === null) {
	    return null
	  }
	  const onBadUrl = this.onBadUrl;
	  return {
	    handler: (req, res, ctx) => onBadUrl(path, req, res),
	    params: {},
	    store: null
	  }
	};

	Router.prototype.prettyPrint = function (options = {}) {
	  const method = options.method;

	  options.buildPrettyMeta = this.buildPrettyMeta.bind(this);

	  let tree = null;
	  if (method === undefined) {
	    const { version, host, ...constraints } = this.constrainer.strategies;
	    constraints[httpMethodStrategy.name] = httpMethodStrategy;

	    const mergedRouter = new Router({ ...this._opts, constraints });
	    const mergedRoutes = this.routes.map(route => {
	      const constraints = {
	        ...route.opts.constraints,
	        [httpMethodStrategy.name]: route.method
	      };
	      return { ...route, method: 'MERGED', opts: { constraints } }
	    });
	    mergedRouter._rebuild(mergedRoutes);
	    tree = mergedRouter.trees.MERGED;
	  } else {
	    tree = this.trees[method];
	  }

	  if (tree == null) return '(empty tree)'
	  return prettyPrintTree(tree, options)
	};

	for (const i in httpMethods) {
	  /* eslint no-prototype-builtins: "off" */
	  if (!httpMethods.hasOwnProperty(i)) continue
	  const m = httpMethods[i];
	  const methodName = m.toLowerCase();

	  Router.prototype[methodName] = function (path, handler, store) {
	    return this.on(m, path, handler, store)
	  };
	}

	Router.prototype.all = function (path, handler, store) {
	  this.on(httpMethods, path, handler, store);
	};

	findMyWay = Router;

	function escapeRegExp (string) {
	  return string.replace(ESCAPE_REGEXP, '\\$&')
	}

	function removeDuplicateSlashes (path) {
	  return path.indexOf('//') !== -1 ? path.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, '/') : path
	}

	function trimLastSlash (path) {
	  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
	    return path.slice(0, -1)
	  }
	  return path
	}

	function trimRegExpStartAndEnd (regexString) {
	  // removes chars that marks start "^" and end "$" of regexp
	  if (regexString.charCodeAt(1) === 94) {
	    regexString = regexString.slice(0, 1) + regexString.slice(2);
	  }

	  if (regexString.charCodeAt(regexString.length - 2) === 36) {
	    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
	  }

	  return regexString
	}

	function getClosingParenthensePosition (path, idx) {
	  // `path.indexOf()` will always return the first position of the closing parenthese,
	  // but it's inefficient for grouped or wrong regexp expressions.
	  // see issues #62 and #63 for more info

	  let parentheses = 1;

	  while (idx < path.length) {
	    idx++;

	    // ignore skipped chars "\"
	    if (path.charCodeAt(idx) === 92) {
	      idx++;
	      continue
	    }

	    if (path.charCodeAt(idx) === 41) {
	      parentheses--;
	    } else if (path.charCodeAt(idx) === 40) {
	      parentheses++;
	    }

	    if (!parentheses) return idx
	  }

	  throw new TypeError('Invalid regexp expression in "' + path + '"')
	}

	function defaultBuildPrettyMeta (route) {
	  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display
	  if (!route) return {}
	  if (!route.store) return {}
	  return Object.assign({}, route.store)
	}
	return findMyWay;
}

var headRoute;
var hasRequiredHeadRoute;

function requireHeadRoute () {
	if (hasRequiredHeadRoute) return headRoute;
	hasRequiredHeadRoute = 1;
	function headRouteOnSendHandler (req, reply, payload, done) {
	  // If payload is undefined
	  if (payload === undefined) {
	    reply.header('content-length', '0');
	    done(null, null);
	    return
	  }

	  if (typeof payload.resume === 'function') {
	    payload.on('error', (err) => {
	      reply.log.error({ err }, 'Error on Stream found for HEAD route');
	    });
	    payload.resume();
	    done(null, null);
	    return
	  }

	  const size = '' + Buffer.byteLength(payload);

	  reply.header('content-length', size);

	  done(null, null);
	}

	function parseHeadOnSendHandlers (onSendHandlers) {
	  if (onSendHandlers == null) return headRouteOnSendHandler
	  return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler]
	}

	headRoute = {
	  parseHeadOnSendHandlers
	};
	return headRoute;
}

var route;
var hasRequiredRoute;

function requireRoute () {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;

	const FindMyWay = requireFindMyWay();
	const Context = requireContext();
	const handleRequest = requireHandleRequest();
	const { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = requireHooks();
	const { normalizeSchema } = requireSchemas();
	const { parseHeadOnSendHandlers } = requireHeadRoute();

	const {
	  compileSchemasForValidation,
	  compileSchemasForSerialization
	} = requireValidation$2();

	const {
	  FST_ERR_SCH_VALIDATION_BUILD,
	  FST_ERR_SCH_SERIALIZATION_BUILD,
	  FST_ERR_DUPLICATED_ROUTE,
	  FST_ERR_INVALID_URL,
	  FST_ERR_HOOK_INVALID_HANDLER,
	  FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
	  FST_ERR_ROUTE_DUPLICATED_HANDLER,
	  FST_ERR_ROUTE_HANDLER_NOT_FN,
	  FST_ERR_ROUTE_MISSING_HANDLER,
	  FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
	  FST_ERR_ROUTE_METHOD_INVALID,
	  FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
	  FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
	  FST_ERR_HOOK_INVALID_ASYNC_HANDLER
	} = requireErrors$2();

	const {
	  kRoutePrefix,
	  kSupportedHTTPMethods,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kOptions,
	  kReplySerializerDefault,
	  kReplyIsError,
	  kRequestPayloadStream,
	  kDisableRequestLogging,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kHasBeenDecorated,
	  kRequestAcceptVersion,
	  kRouteByFastify,
	  kRouteContext
	} = requireSymbols$2();
	const { buildErrorHandler } = requireErrorHandler();
	const { createChildLogger } = requireLoggerFactory();
	const { getGenReqId } = requireReqIdGenFactory();

	function buildRouting (options) {
	  const router = FindMyWay(options.config);

	  let avvio;
	  let fourOhFour;
	  let logger;
	  let hasLogger;
	  let setupResponseListeners;
	  let throwIfAlreadyStarted;
	  let disableRequestLogging;
	  let ignoreTrailingSlash;
	  let ignoreDuplicateSlashes;
	  let return503OnClosing;
	  let globalExposeHeadRoutes;
	  let keepAliveConnections;

	  let closing = false;

	  return {
	    /**
	     * @param {import('../fastify').FastifyServerOptions} options
	     * @param {*} fastifyArgs
	     */
	    setup (options, fastifyArgs) {
	      avvio = fastifyArgs.avvio;
	      fourOhFour = fastifyArgs.fourOhFour;
	      logger = fastifyArgs.logger;
	      hasLogger = fastifyArgs.hasLogger;
	      setupResponseListeners = fastifyArgs.setupResponseListeners;
	      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;

	      globalExposeHeadRoutes = options.exposeHeadRoutes;
	      disableRequestLogging = options.disableRequestLogging;
	      ignoreTrailingSlash = options.ignoreTrailingSlash;
	      ignoreDuplicateSlashes = options.ignoreDuplicateSlashes;
	      return503OnClosing = Object.hasOwn(options, 'return503OnClosing') ? options.return503OnClosing : true;
	      keepAliveConnections = fastifyArgs.keepAliveConnections;
	    },
	    routing: router.lookup.bind(router), // router func to find the right handler to call
	    route, // configure a route in the fastify instance
	    hasRoute,
	    prepareRoute,
	    routeHandler,
	    closeRoutes: () => { closing = true; },
	    printRoutes: router.prettyPrint.bind(router),
	    addConstraintStrategy,
	    hasConstraintStrategy,
	    isAsyncConstraint,
	    findRoute
	  }

	  function addConstraintStrategy (strategy) {
	    throwIfAlreadyStarted('Cannot add constraint strategy!');
	    return router.addConstraintStrategy(strategy)
	  }

	  function hasConstraintStrategy (strategyName) {
	    return router.hasConstraintStrategy(strategyName)
	  }

	  function isAsyncConstraint () {
	    return router.constrainer.asyncStrategiesInUse.size > 0
	  }

	  // Convert shorthand to extended route declaration
	  function prepareRoute ({ method, url, options, handler, isFastify }) {
	    if (typeof url !== 'string') {
	      throw new FST_ERR_INVALID_URL(typeof url)
	    }

	    if (!handler && typeof options === 'function') {
	      handler = options; // for support over direct function calls such as fastify.get() options are reused as the handler
	      options = {};
	    } else if (handler && typeof handler === 'function') {
	      if (Object.prototype.toString.call(options) !== '[object Object]') {
	        throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url)
	      } else if (options.handler) {
	        if (typeof options.handler === 'function') {
	          throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url)
	        } else {
	          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url)
	        }
	      }
	    }

	    options = Object.assign({}, options, {
	      method,
	      url,
	      path: url,
	      handler: handler || (options && options.handler)
	    });

	    return route.call(this, { options, isFastify })
	  }

	  function hasRoute ({ options }) {
	    const normalizedMethod = options.method?.toUpperCase() ?? '';
	    return router.hasRoute(
	      normalizedMethod,
	      options.url || '',
	      options.constraints
	    )
	  }

	  function findRoute (options) {
	    const route = router.find(
	      options.method,
	      options.url || '',
	      options.constraints
	    );
	    if (route) {
	      // we must reduce the expose surface, otherwise
	      // we provide the ability for the user to modify
	      // all the route and server information in runtime
	      return {
	        handler: route.handler,
	        params: route.params,
	        searchParams: route.searchParams
	      }
	    } else {
	      return null
	    }
	  }

	  /**
	   * Route management
	   * @param {{ options: import('../fastify').RouteOptions, isFastify: boolean }}
	   */
	  function route ({ options, isFastify }) {
	    throwIfAlreadyStarted('Cannot add route!');

	    // Since we are mutating/assigning only top level props, it is fine to have a shallow copy using the spread operator
	    const opts = { ...options };

	    const path = opts.url || opts.path || '';

	    if (!opts.handler) {
	      throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path)
	    }

	    if (opts.errorHandler !== undefined && typeof opts.errorHandler !== 'function') {
	      throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path)
	    }

	    validateBodyLimitOption(opts.bodyLimit);

	    const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;

	    let isGetRoute = false;
	    let isHeadRoute = false;

	    if (Array.isArray(opts.method)) {
	      for (let i = 0; i < opts.method.length; ++i) {
	        opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
	        validateSchemaBodyOption.call(this, opts.method[i], path, opts.schema);

	        isGetRoute = opts.method.includes('GET');
	        isHeadRoute = opts.method.includes('HEAD');
	      }
	    } else {
	      opts.method = normalizeAndValidateMethod.call(this, opts.method);
	      validateSchemaBodyOption.call(this, opts.method, path, opts.schema);

	      isGetRoute = opts.method === 'GET';
	      isHeadRoute = opts.method === 'HEAD';
	    }

	    // we need to clone a set of initial options for HEAD route
	    const headOpts = shouldExposeHead && isGetRoute ? { ...options } : null;

	    const prefix = this[kRoutePrefix];

	    if (path === '/' && prefix.length > 0 && opts.method !== 'HEAD') {
	      switch (opts.prefixTrailingSlash) {
	        case 'slash':
	          addNewRoute.call(this, { path, isFastify });
	          break
	        case 'no-slash':
	          addNewRoute.call(this, { path: '', isFastify });
	          break
	        case 'both':
	        default:
	          addNewRoute.call(this, { path: '', isFastify });
	          // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.
	          if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith('/'))) {
	            addNewRoute.call(this, { path, prefixing: true, isFastify });
	          }
	      }
	    } else if (path[0] === '/' && prefix.endsWith('/')) {
	      // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
	      addNewRoute.call(this, { path: path.slice(1), isFastify });
	    } else {
	      addNewRoute.call(this, { path, isFastify });
	    }

	    // chainable api
	    return this

	    function addNewRoute ({ path, prefixing = false, isFastify = false }) {
	      const url = prefix + path;

	      opts.url = url;
	      opts.path = url;
	      opts.routePath = path;
	      opts.prefix = prefix;
	      opts.logLevel = opts.logLevel || this[kLogLevel];

	      if (this[kLogSerializers] || opts.logSerializers) {
	        opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
	      }

	      if (opts.attachValidation == null) {
	        opts.attachValidation = false;
	      }

	      if (prefixing === false) {
	        // run 'onRoute' hooks
	        for (const hook of this[kHooks].onRoute) {
	          hook.call(this, opts);
	        }
	      }

	      for (const hook of lifecycleHooks) {
	        if (opts && hook in opts) {
	          if (Array.isArray(opts[hook])) {
	            for (const func of opts[hook]) {
	              if (typeof func !== 'function') {
	                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func))
	              }

	              if (hook === 'onSend' || hook === 'preSerialization' || hook === 'onError' || hook === 'preParsing') {
	                if (func.constructor.name === 'AsyncFunction' && func.length === 4) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              } else if (hook === 'onRequestAbort') {
	                if (func.constructor.name === 'AsyncFunction' && func.length !== 1) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              } else {
	                if (func.constructor.name === 'AsyncFunction' && func.length === 3) {
	                  throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	                }
	              }
	            }
	          } else if (opts[hook] !== undefined && typeof opts[hook] !== 'function') {
	            throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]))
	          }
	        }
	      }

	      const constraints = opts.constraints || {};
	      const config = {
	        ...opts.config,
	        url,
	        method: opts.method
	      };

	      const context = new Context({
	        schema: opts.schema,
	        handler: opts.handler.bind(this),
	        config,
	        errorHandler: opts.errorHandler,
	        childLoggerFactory: opts.childLoggerFactory,
	        bodyLimit: opts.bodyLimit,
	        logLevel: opts.logLevel,
	        logSerializers: opts.logSerializers,
	        attachValidation: opts.attachValidation,
	        schemaErrorFormatter: opts.schemaErrorFormatter,
	        replySerializer: this[kReplySerializerDefault],
	        validatorCompiler: opts.validatorCompiler,
	        serializerCompiler: opts.serializerCompiler,
	        exposeHeadRoute: shouldExposeHead,
	        prefixTrailingSlash: (opts.prefixTrailingSlash || 'both'),
	        server: this,
	        isFastify
	      });

	      const headHandler = router.findRoute('HEAD', opts.url, constraints);
	      const hasHEADHandler = headHandler !== null;

	      try {
	        router.on(opts.method, opts.url, { constraints }, routeHandler, context);
	      } catch (error) {
	        // any route insertion error created by fastify can be safely ignore
	        // because it only duplicate route for head
	        if (!context[kRouteByFastify]) {
	          const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route`);
	          if (isDuplicatedRoute) {
	            throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url)
	          }

	          throw error
	        }
	      }

	      this.after((notHandledErr, done) => {
	        // Send context async
	        context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
	        context._parserOptions.limit = opts.bodyLimit || null;
	        context.logLevel = opts.logLevel;
	        context.logSerializers = opts.logSerializers;
	        context.attachValidation = opts.attachValidation;
	        context[kReplySerializerDefault] = this[kReplySerializerDefault];
	        context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;

	        // Run hooks and more
	        avvio.once('preReady', () => {
	          for (const hook of lifecycleHooks) {
	            const toSet = this[kHooks][hook]
	              .concat(opts[hook] || [])
	              .map(h => h.bind(this));
	            context[hook] = toSet.length ? toSet : null;
	          }

	          // Optimization: avoid encapsulation if no decoration has been done.
	          while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
	            context.Request = context.Request.parent;
	          }
	          while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
	            context.Reply = context.Reply.parent;
	          }

	          // Must store the 404 Context in 'preReady' because it is only guaranteed to
	          // be available after all of the plugins and routes have been loaded.
	          fourOhFour.setContext(this, context);

	          if (opts.schema) {
	            context.schema = normalizeSchema(context.schema, this.initialConfig);

	            const schemaController = this[kSchemaController];
	            if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
	              schemaController.setupValidator(this[kOptions]);
	            }
	            try {
	              const isCustom = typeof opts?.validatorCompiler === 'function' || schemaController.isCustomValidatorCompiler;
	              compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
	            } catch (error) {
	              throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message)
	            }

	            if (opts.schema.response && !opts.serializerCompiler) {
	              schemaController.setupSerializer(this[kOptions]);
	            }
	            try {
	              compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
	            } catch (error) {
	              throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message)
	            }
	          }
	        });

	        done(notHandledErr);
	      });

	      // register head route in sync
	      // we must place it after the `this.after`

	      if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
	        const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
	        prepareRoute.call(this, { method: 'HEAD', url: path, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
	      }
	    }
	  }

	  // HTTP request entry point, the routing has already been executed
	  function routeHandler (req, res, params, context, query) {
	    const id = getGenReqId(context.server, req);

	    const loggerOpts = {
	      level: context.logLevel
	    };

	    if (context.logSerializers) {
	      loggerOpts.serializers = context.logSerializers;
	    }
	    const childLogger = createChildLogger(context, logger, req, id, loggerOpts);
	    childLogger[kDisableRequestLogging] = disableRequestLogging;

	    if (closing === true) {
	      /* istanbul ignore next mac, windows */
	      if (req.httpVersionMajor !== 2) {
	        res.setHeader('Connection', 'close');
	      }

	      // TODO remove return503OnClosing after Node v18 goes EOL
	      /* istanbul ignore else */
	      if (return503OnClosing) {
	        // On Node v19 we cannot test this behavior as it won't be necessary
	        // anymore. It will close all the idle connections before they reach this
	        // stage.
	        const headers = {
	          'Content-Type': 'application/json',
	          'Content-Length': '80'
	        };
	        res.writeHead(503, headers);
	        res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
	        childLogger.info({ res: { statusCode: 503 } }, 'request aborted - refusing to accept new requests as server is closing');
	        return
	      }
	    }

	    // When server.forceCloseConnections is true, we will collect any requests
	    // that have indicated they want persistence so that they can be reaped
	    // on server close. Otherwise, the container is a noop container.
	    const connHeader = String.prototype.toLowerCase.call(req.headers.connection || '');
	    if (connHeader === 'keep-alive') {
	      if (keepAliveConnections.has(req.socket) === false) {
	        keepAliveConnections.add(req.socket);
	        req.socket.on('close', removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
	      }
	    }

	    // we revert the changes in defaultRoute
	    if (req.headers[kRequestAcceptVersion] !== undefined) {
	      req.headers['accept-version'] = req.headers[kRequestAcceptVersion];
	      req.headers[kRequestAcceptVersion] = undefined;
	    }

	    const request = new context.Request(id, params, req, query, childLogger, context);
	    const reply = new context.Reply(res, request, childLogger);
	    if (disableRequestLogging === false) {
	      childLogger.info({ req: request }, 'incoming request');
	    }

	    if (hasLogger === true || context.onResponse !== null) {
	      setupResponseListeners(reply);
	    }

	    if (context.onRequest !== null) {
	      onRequestHookRunner(
	        context.onRequest,
	        request,
	        reply,
	        runPreParsing
	      );
	    } else {
	      runPreParsing(null, request, reply);
	    }

	    if (context.onRequestAbort !== null) {
	      req.on('close', () => {
	        /* istanbul ignore else */
	        if (req.aborted) {
	          onRequestAbortHookRunner(
	            context.onRequestAbort,
	            request,
	            handleOnRequestAbortHooksErrors.bind(null, reply)
	          );
	        }
	      });
	    }

	    if (context.onTimeout !== null) {
	      if (!request.raw.socket._meta) {
	        request.raw.socket.on('timeout', handleTimeout);
	      }
	      request.raw.socket._meta = { context, request, reply };
	    }
	  }
	}

	function handleOnRequestAbortHooksErrors (reply, err) {
	  if (err) {
	    reply.log.error({ err }, 'onRequestAborted hook failed');
	  }
	}

	function handleTimeout () {
	  const { context, request, reply } = this._meta;
	  onTimeoutHookRunner(
	    context.onTimeout,
	    request,
	    reply,
	    noop
	  );
	}

	function normalizeAndValidateMethod (method) {
	  if (typeof method !== 'string') {
	    throw new FST_ERR_ROUTE_METHOD_INVALID()
	  }
	  method = method.toUpperCase();
	  if (!this[kSupportedHTTPMethods].bodyless.has(method) &&
	    !this[kSupportedHTTPMethods].bodywith.has(method)) {
	    throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method)
	  }

	  return method
	}

	function validateSchemaBodyOption (method, path, schema) {
	  if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
	    throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path)
	  }
	}

	function validateBodyLimitOption (bodyLimit) {
	  if (bodyLimit === undefined) return
	  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
	    throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit)
	  }
	}

	function runPreParsing (err, request, reply) {
	  if (reply.sent === true) return
	  if (err != null) {
	    reply[kReplyIsError] = true;
	    reply.send(err);
	    return
	  }

	  request[kRequestPayloadStream] = request.raw;

	  if (request[kRouteContext].preParsing !== null) {
	    preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
	  } else {
	    handleRequest.call(request.server, null, request, reply);
	  }
	}

	/**
	 * Used within the route handler as a `net.Socket.close` event handler.
	 * The purpose is to remove a socket from the tracked sockets collection when
	 * the socket has naturally timed out.
	 */
	function removeTrackedSocket () {
	  this.keepAliveConnections.delete(this.socket);
	}

	function noop () { }

	route = { buildRouting, validateBodyLimitOption };
	return route;
}

var fourOhFour_1;
var hasRequiredFourOhFour;

function requireFourOhFour () {
	if (hasRequiredFourOhFour) return fourOhFour_1;
	hasRequiredFourOhFour = 1;

	const FindMyWay = requireFindMyWay();

	const Reply = requireReply();
	const Request = requireRequest$1();
	const Context = requireContext();
	const {
	  kRoutePrefix,
	  kCanSetNotFoundHandler,
	  kFourOhFourLevelInstance,
	  kFourOhFourContext,
	  kHooks,
	  kErrorHandler
	} = requireSymbols$2();
	const { lifecycleHooks } = requireHooks();
	const { buildErrorHandler } = requireErrorHandler();
	const {
	  FST_ERR_NOT_FOUND
	} = requireErrors$2();
	const { createChildLogger } = requireLoggerFactory();
	const { getGenReqId } = requireReqIdGenFactory();

	/**
	 * Each fastify instance have a:
	 * kFourOhFourLevelInstance: point to a fastify instance that has the 404 handler set
	 * kCanSetNotFoundHandler: bool to track if the 404 handler has already been set
	 * kFourOhFour: the singleton instance of this 404 module
	 * kFourOhFourContext: the context in the reply object where the handler will be executed
	 */
	function fourOhFour (options) {
	  const { logger, disableRequestLogging } = options;

	  // 404 router, used for handling encapsulated 404 handlers
	  const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
	  let _onBadUrlHandler = null;

	  return { router, setNotFoundHandler, setContext, arrange404 }

	  function arrange404 (instance) {
	    // Change the pointer of the fastify instance to itself, so register + prefix can add new 404 handler
	    instance[kFourOhFourLevelInstance] = instance;
	    instance[kCanSetNotFoundHandler] = true;
	    // we need to bind instance for the context
	    router.onBadUrl = router.onBadUrl.bind(instance);
	    router.defaultRoute = router.defaultRoute.bind(instance);
	  }

	  function basic404 (request, reply) {
	    const { url, method } = request.raw;
	    const message = `Route ${method}:${url} not found`;
	    if (!disableRequestLogging) {
	      request.log.info(message);
	    }
	    reply.code(404).send({
	      message,
	      error: 'Not Found',
	      statusCode: 404
	    });
	  }

	  function createOnBadUrl () {
	    return function onBadUrl (path, req, res) {
	      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
	      const id = getGenReqId(fourOhFourContext.server, req);
	      const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
	      const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
	      const reply = new Reply(res, request, childLogger);

	      _onBadUrlHandler(request, reply);
	    }
	  }

	  function setContext (instance, context) {
	    const _404Context = Object.assign({}, instance[kFourOhFourContext]);
	    _404Context.onSend = context.onSend;
	    context[kFourOhFourContext] = _404Context;
	  }

	  function setNotFoundHandler (opts, handler, avvio, routeHandler) {
	    // First initialization of the fastify root instance
	    if (this[kCanSetNotFoundHandler] === undefined) {
	      this[kCanSetNotFoundHandler] = true;
	    }
	    if (this[kFourOhFourContext] === undefined) {
	      this[kFourOhFourContext] = null;
	    }

	    const _fastify = this;
	    const prefix = this[kRoutePrefix] || '/';

	    if (this[kCanSetNotFoundHandler] === false) {
	      throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`)
	    }

	    if (typeof opts === 'object') {
	      if (opts.preHandler) {
	        if (Array.isArray(opts.preHandler)) {
	          opts.preHandler = opts.preHandler.map(hook => hook.bind(_fastify));
	        } else {
	          opts.preHandler = opts.preHandler.bind(_fastify);
	        }
	      }

	      if (opts.preValidation) {
	        if (Array.isArray(opts.preValidation)) {
	          opts.preValidation = opts.preValidation.map(hook => hook.bind(_fastify));
	        } else {
	          opts.preValidation = opts.preValidation.bind(_fastify);
	        }
	      }
	    }

	    if (typeof opts === 'function') {
	      handler = opts;
	      opts = undefined;
	    }
	    opts = opts || {};

	    if (handler) {
	      this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
	      handler = handler.bind(this);
	      // update onBadUrl handler
	      _onBadUrlHandler = handler;
	    } else {
	      handler = basic404;
	      // update onBadUrl handler
	      _onBadUrlHandler = basic404;
	    }

	    this.after((notHandledErr, done) => {
	      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
	      done(notHandledErr);
	    });
	  }

	  function _setNotFoundHandler (prefix, opts, handler, avvio, routeHandler) {
	    const context = new Context({
	      schema: opts.schema,
	      handler,
	      config: opts.config || {},
	      server: this
	    });

	    avvio.once('preReady', () => {
	      const context = this[kFourOhFourContext];
	      for (const hook of lifecycleHooks) {
	        const toSet = this[kHooks][hook]
	          .concat(opts[hook] || [])
	          .map(h => h.bind(this));
	        context[hook] = toSet.length ? toSet : null;
	      }
	      context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
	    });

	    if (this[kFourOhFourContext] !== null && prefix === '/') {
	      Object.assign(this[kFourOhFourContext], context); // Replace the default 404 handler
	      return
	    }

	    this[kFourOhFourLevelInstance][kFourOhFourContext] = context;

	    router.all(prefix + (prefix.endsWith('/') ? '*' : '/*'), routeHandler, context);
	    router.all(prefix, routeHandler, context);
	  }

	  function fourOhFourFallBack (req, res) {
	    // if this happen, we have a very bad bug
	    // we might want to do some hard debugging
	    // here, let's print out as much info as
	    // we can
	    const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
	    const id = getGenReqId(fourOhFourContext.server, req);
	    const childLogger = createChildLogger(fourOhFourContext, logger, req, id);

	    childLogger.info({ req }, 'incoming request');

	    const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
	    const reply = new Reply(res, request, childLogger);

	    request.log.warn('the default handler for 404 did not catch this, this is likely a fastify bug, please report it');
	    request.log.warn(router.prettyPrint());
	    reply.code(404).send(new FST_ERR_NOT_FOUND());
	  }
	}

	fourOhFour_1 = fourOhFour;
	return fourOhFour_1;
}

var initialConfigValidation = {exports: {}};

var configValidator$1 = {exports: {}};

var hasRequiredConfigValidator$1;

function requireConfigValidator$1 () {
	if (hasRequiredConfigValidator$1) return configValidator$1.exports;
	hasRequiredConfigValidator$1 = 1;
	configValidator$1.exports = validate10;
	configValidator$1.exports.default = validate10;
	const schema11 = {"properties":{"connectionTimeout":{"type":"integer","default":0},"keepAliveTimeout":{"type":"integer","default":72000},"forceCloseConnections":{"oneOf":[{"type":"string","pattern":"idle"},{"type":"boolean"}]},"maxRequestsPerSocket":{"type":"integer","default":0,"nullable":true},"requestTimeout":{"type":"integer","default":0},"bodyLimit":{"type":"integer","default":1048576},"caseSensitive":{"type":"boolean","default":true},"allowUnsafeRegex":{"type":"boolean","default":false},"http2":{"type":"boolean"},"https":{"if":{"not":{"oneOf":[{"type":"boolean"},{"type":"null"},{"type":"object","additionalProperties":false,"required":["allowHTTP1"],"properties":{"allowHTTP1":{"type":"boolean"}}}]}},"then":{"setDefaultValue":true}},"ignoreTrailingSlash":{"type":"boolean","default":false},"ignoreDuplicateSlashes":{"type":"boolean","default":false},"disableRequestLogging":{"type":"boolean","default":false},"maxParamLength":{"type":"integer","default":100},"onProtoPoisoning":{"type":"string","default":"error"},"onConstructorPoisoning":{"type":"string","default":"error"},"pluginTimeout":{"type":"integer","default":10000},"requestIdHeader":{"anyOf":[{"type":"boolean"},{"type":"string"}],"default":false},"requestIdLogLabel":{"type":"string","default":"reqId"},"http2SessionTimeout":{"type":"integer","default":72000},"exposeHeadRoutes":{"type":"boolean","default":true},"useSemicolonDelimiter":{"type":"boolean","default":false},"constraints":{"type":"object","additionalProperties":{"type":"object","required":["name","storage","validate","deriveConstraint"],"additionalProperties":true,"properties":{"name":{"type":"string"},"storage":{},"validate":{},"deriveConstraint":{}}}}}};
	const func2 = Object.prototype.hasOwnProperty;
	const pattern0 = new RegExp("idle", "u");

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.connectionTimeout === undefined){
	data.connectionTimeout = 0;
	}
	if(data.keepAliveTimeout === undefined){
	data.keepAliveTimeout = 72000;
	}
	if(data.maxRequestsPerSocket === undefined){
	data.maxRequestsPerSocket = 0;
	}
	if(data.requestTimeout === undefined){
	data.requestTimeout = 0;
	}
	if(data.bodyLimit === undefined){
	data.bodyLimit = 1048576;
	}
	if(data.caseSensitive === undefined){
	data.caseSensitive = true;
	}
	if(data.allowUnsafeRegex === undefined){
	data.allowUnsafeRegex = false;
	}
	if(data.ignoreTrailingSlash === undefined){
	data.ignoreTrailingSlash = false;
	}
	if(data.ignoreDuplicateSlashes === undefined){
	data.ignoreDuplicateSlashes = false;
	}
	if(data.disableRequestLogging === undefined){
	data.disableRequestLogging = false;
	}
	if(data.maxParamLength === undefined){
	data.maxParamLength = 100;
	}
	if(data.onProtoPoisoning === undefined){
	data.onProtoPoisoning = "error";
	}
	if(data.onConstructorPoisoning === undefined){
	data.onConstructorPoisoning = "error";
	}
	if(data.pluginTimeout === undefined){
	data.pluginTimeout = 10000;
	}
	if(data.requestIdHeader === undefined){
	data.requestIdHeader = false;
	}
	if(data.requestIdLogLabel === undefined){
	data.requestIdLogLabel = "reqId";
	}
	if(data.http2SessionTimeout === undefined){
	data.http2SessionTimeout = 72000;
	}
	if(data.exposeHeadRoutes === undefined){
	data.exposeHeadRoutes = true;
	}
	if(data.useSemicolonDelimiter === undefined){
	data.useSemicolonDelimiter = false;
	}
	const _errs1 = errors;
	for(const key0 in data){
	if(!(func2.call(schema11.properties, key0))){
	delete data[key0];
	}
	}
	if(_errs1 === errors){
	let data0 = data.connectionTimeout;
	const _errs2 = errors;
	if(!(((typeof data0 == "number") && (!(data0 % 1) && !isNaN(data0))) && (isFinite(data0)))){
	let dataType0 = typeof data0;
	let coerced0 = undefined;
	if(!(coerced0 !== undefined)){
	if(dataType0 === "boolean" || data0 === null
	              || (dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1))){
	coerced0 = +data0;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/connectionTimeout",schemaPath:"#/properties/connectionTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced0 !== undefined){
	data0 = coerced0;
	if(data !== undefined){
	data["connectionTimeout"] = coerced0;
	}
	}
	}
	var valid0 = _errs2 === errors;
	if(valid0){
	let data1 = data.keepAliveTimeout;
	const _errs4 = errors;
	if(!(((typeof data1 == "number") && (!(data1 % 1) && !isNaN(data1))) && (isFinite(data1)))){
	let dataType1 = typeof data1;
	let coerced1 = undefined;
	if(!(coerced1 !== undefined)){
	if(dataType1 === "boolean" || data1 === null
	              || (dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1))){
	coerced1 = +data1;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/keepAliveTimeout",schemaPath:"#/properties/keepAliveTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced1 !== undefined){
	data1 = coerced1;
	if(data !== undefined){
	data["keepAliveTimeout"] = coerced1;
	}
	}
	}
	var valid0 = _errs4 === errors;
	if(valid0){
	if(data.forceCloseConnections !== undefined){
	let data2 = data.forceCloseConnections;
	const _errs6 = errors;
	const _errs7 = errors;
	let valid1 = false;
	let passing0 = null;
	const _errs8 = errors;
	if(typeof data2 !== "string"){
	let dataType2 = typeof data2;
	let coerced2 = undefined;
	if(!(coerced2 !== undefined)){
	if(dataType2 == "number" || dataType2 == "boolean"){
	coerced2 = "" + data2;
	}
	else if(data2 === null){
	coerced2 = "";
	}
	else {
	const err0 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	}
	}
	if(coerced2 !== undefined){
	data2 = coerced2;
	if(data !== undefined){
	data["forceCloseConnections"] = coerced2;
	}
	}
	}
	if(errors === _errs8){
	if(typeof data2 === "string"){
	if(!pattern0.test(data2)){
	const err1 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/0/pattern",keyword:"pattern",params:{pattern: "idle"},message:"must match pattern \""+"idle"+"\""};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	}
	var _valid0 = _errs8 === errors;
	if(_valid0){
	valid1 = true;
	passing0 = 0;
	}
	const _errs10 = errors;
	if(typeof data2 !== "boolean"){
	let coerced3 = undefined;
	if(!(coerced3 !== undefined)){
	if(data2 === "false" || data2 === 0 || data2 === null){
	coerced3 = false;
	}
	else if(data2 === "true" || data2 === 1){
	coerced3 = true;
	}
	else {
	const err2 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf/1/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	}
	}
	if(coerced3 !== undefined){
	data2 = coerced3;
	if(data !== undefined){
	data["forceCloseConnections"] = coerced3;
	}
	}
	}
	var _valid0 = _errs10 === errors;
	if(_valid0 && valid1){
	valid1 = false;
	passing0 = [passing0, 1];
	}
	else {
	if(_valid0){
	valid1 = true;
	passing0 = 1;
	}
	}
	if(!valid1){
	const err3 = {instancePath:instancePath+"/forceCloseConnections",schemaPath:"#/properties/forceCloseConnections/oneOf",keyword:"oneOf",params:{passingSchemas: passing0},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs7;
	if(vErrors !== null){
	if(_errs7){
	vErrors.length = _errs7;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs6 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	let data3 = data.maxRequestsPerSocket;
	const _errs12 = errors;
	if((!(((typeof data3 == "number") && (!(data3 % 1) && !isNaN(data3))) && (isFinite(data3)))) && (data3 !== null)){
	let dataType4 = typeof data3;
	let coerced4 = undefined;
	if(!(coerced4 !== undefined)){
	if(dataType4 === "boolean" || data3 === null
	              || (dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1))){
	coerced4 = +data3;
	}
	else if(data3 === "" || data3 === 0 || data3 === false){
	coerced4 = null;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/maxRequestsPerSocket",schemaPath:"#/properties/maxRequestsPerSocket/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced4 !== undefined){
	data3 = coerced4;
	if(data !== undefined){
	data["maxRequestsPerSocket"] = coerced4;
	}
	}
	}
	var valid0 = _errs12 === errors;
	if(valid0){
	let data4 = data.requestTimeout;
	const _errs15 = errors;
	if(!(((typeof data4 == "number") && (!(data4 % 1) && !isNaN(data4))) && (isFinite(data4)))){
	let dataType5 = typeof data4;
	let coerced5 = undefined;
	if(!(coerced5 !== undefined)){
	if(dataType5 === "boolean" || data4 === null
	              || (dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1))){
	coerced5 = +data4;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/requestTimeout",schemaPath:"#/properties/requestTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced5 !== undefined){
	data4 = coerced5;
	if(data !== undefined){
	data["requestTimeout"] = coerced5;
	}
	}
	}
	var valid0 = _errs15 === errors;
	if(valid0){
	let data5 = data.bodyLimit;
	const _errs17 = errors;
	if(!(((typeof data5 == "number") && (!(data5 % 1) && !isNaN(data5))) && (isFinite(data5)))){
	let dataType6 = typeof data5;
	let coerced6 = undefined;
	if(!(coerced6 !== undefined)){
	if(dataType6 === "boolean" || data5 === null
	              || (dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1))){
	coerced6 = +data5;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/bodyLimit",schemaPath:"#/properties/bodyLimit/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced6 !== undefined){
	data5 = coerced6;
	if(data !== undefined){
	data["bodyLimit"] = coerced6;
	}
	}
	}
	var valid0 = _errs17 === errors;
	if(valid0){
	let data6 = data.caseSensitive;
	const _errs19 = errors;
	if(typeof data6 !== "boolean"){
	let coerced7 = undefined;
	if(!(coerced7 !== undefined)){
	if(data6 === "false" || data6 === 0 || data6 === null){
	coerced7 = false;
	}
	else if(data6 === "true" || data6 === 1){
	coerced7 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/caseSensitive",schemaPath:"#/properties/caseSensitive/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced7 !== undefined){
	data6 = coerced7;
	if(data !== undefined){
	data["caseSensitive"] = coerced7;
	}
	}
	}
	var valid0 = _errs19 === errors;
	if(valid0){
	let data7 = data.allowUnsafeRegex;
	const _errs21 = errors;
	if(typeof data7 !== "boolean"){
	let coerced8 = undefined;
	if(!(coerced8 !== undefined)){
	if(data7 === "false" || data7 === 0 || data7 === null){
	coerced8 = false;
	}
	else if(data7 === "true" || data7 === 1){
	coerced8 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/allowUnsafeRegex",schemaPath:"#/properties/allowUnsafeRegex/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced8 !== undefined){
	data7 = coerced8;
	if(data !== undefined){
	data["allowUnsafeRegex"] = coerced8;
	}
	}
	}
	var valid0 = _errs21 === errors;
	if(valid0){
	if(data.http2 !== undefined){
	let data8 = data.http2;
	const _errs23 = errors;
	if(typeof data8 !== "boolean"){
	let coerced9 = undefined;
	if(!(coerced9 !== undefined)){
	if(data8 === "false" || data8 === 0 || data8 === null){
	coerced9 = false;
	}
	else if(data8 === "true" || data8 === 1){
	coerced9 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/http2",schemaPath:"#/properties/http2/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced9 !== undefined){
	data8 = coerced9;
	if(data !== undefined){
	data["http2"] = coerced9;
	}
	}
	}
	var valid0 = _errs23 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	if(data.https !== undefined){
	let data9 = data.https;
	const _errs25 = errors;
	const _errs26 = errors;
	let valid2 = true;
	const _errs27 = errors;
	const _errs28 = errors;
	const _errs29 = errors;
	const _errs30 = errors;
	let valid4 = false;
	const _errs31 = errors;
	if(typeof data9 !== "boolean"){
	let coerced10 = undefined;
	if(!(coerced10 !== undefined)){
	if(data9 === "false" || data9 === 0 || data9 === null){
	coerced10 = false;
	}
	else if(data9 === "true" || data9 === 1){
	coerced10 = true;
	}
	else {
	const err4 = {};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	}
	}
	if(coerced10 !== undefined){
	data9 = coerced10;
	if(data !== undefined){
	data["https"] = coerced10;
	}
	}
	}
	var _valid2 = _errs31 === errors;
	if(_valid2){
	valid4 = true;
	}
	const _errs33 = errors;
	if(data9 !== null){
	let coerced11 = undefined;
	if(!(coerced11 !== undefined)){
	if(data9 === "" || data9 === 0 || data9 === false){
	coerced11 = null;
	}
	else {
	const err5 = {};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	if(coerced11 !== undefined){
	data9 = coerced11;
	if(data !== undefined){
	data["https"] = coerced11;
	}
	}
	}
	var _valid2 = _errs33 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	}
	else {
	if(_valid2){
	valid4 = true;
	}
	const _errs35 = errors;
	if(errors === _errs35){
	if(data9 && typeof data9 == "object" && !Array.isArray(data9)){
	if((data9.allowHTTP1 === undefined) && ("allowHTTP1")){
	const err6 = {};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	}
	else {
	const _errs37 = errors;
	for(const key1 in data9){
	if(!(key1 === "allowHTTP1")){
	delete data9[key1];
	}
	}
	if(_errs37 === errors){
	if(data9.allowHTTP1 !== undefined){
	let data10 = data9.allowHTTP1;
	if(typeof data10 !== "boolean"){
	let coerced12 = undefined;
	if(!(coerced12 !== undefined)){
	if(data10 === "false" || data10 === 0 || data10 === null){
	coerced12 = false;
	}
	else if(data10 === "true" || data10 === 1){
	coerced12 = true;
	}
	else {
	const err7 = {};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	}
	if(coerced12 !== undefined){
	data10 = coerced12;
	if(data9 !== undefined){
	data9["allowHTTP1"] = coerced12;
	}
	}
	}
	}
	}
	}
	}
	else {
	const err8 = {};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	}
	var _valid2 = _errs35 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	}
	else {
	if(_valid2){
	valid4 = true;
	}
	}
	}
	if(!valid4){
	const err9 = {};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	}
	else {
	errors = _errs30;
	if(vErrors !== null){
	if(_errs30){
	vErrors.length = _errs30;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid3 = _errs29 === errors;
	if(valid3){
	const err10 = {};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	}
	else {
	errors = _errs28;
	if(vErrors !== null){
	if(_errs28){
	vErrors.length = _errs28;
	}
	else {
	vErrors = null;
	}
	}
	}
	var _valid1 = _errs27 === errors;
	errors = _errs26;
	if(vErrors !== null){
	if(_errs26){
	vErrors.length = _errs26;
	}
	else {
	vErrors = null;
	}
	}
	if(_valid1){
	const _errs40 = errors;
	data["https"] = true;
	var _valid1 = _errs40 === errors;
	valid2 = _valid1;
	}
	if(!valid2){
	const err11 = {instancePath:instancePath+"/https",schemaPath:"#/properties/https/if",keyword:"if",params:{failingKeyword: "then"},message:"must match \"then\" schema"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	var valid0 = _errs25 === errors;
	}
	else {
	var valid0 = true;
	}
	if(valid0){
	let data11 = data.ignoreTrailingSlash;
	const _errs41 = errors;
	if(typeof data11 !== "boolean"){
	let coerced13 = undefined;
	if(!(coerced13 !== undefined)){
	if(data11 === "false" || data11 === 0 || data11 === null){
	coerced13 = false;
	}
	else if(data11 === "true" || data11 === 1){
	coerced13 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/ignoreTrailingSlash",schemaPath:"#/properties/ignoreTrailingSlash/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced13 !== undefined){
	data11 = coerced13;
	if(data !== undefined){
	data["ignoreTrailingSlash"] = coerced13;
	}
	}
	}
	var valid0 = _errs41 === errors;
	if(valid0){
	let data12 = data.ignoreDuplicateSlashes;
	const _errs43 = errors;
	if(typeof data12 !== "boolean"){
	let coerced14 = undefined;
	if(!(coerced14 !== undefined)){
	if(data12 === "false" || data12 === 0 || data12 === null){
	coerced14 = false;
	}
	else if(data12 === "true" || data12 === 1){
	coerced14 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/ignoreDuplicateSlashes",schemaPath:"#/properties/ignoreDuplicateSlashes/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced14 !== undefined){
	data12 = coerced14;
	if(data !== undefined){
	data["ignoreDuplicateSlashes"] = coerced14;
	}
	}
	}
	var valid0 = _errs43 === errors;
	if(valid0){
	let data13 = data.disableRequestLogging;
	const _errs45 = errors;
	if(typeof data13 !== "boolean"){
	let coerced15 = undefined;
	if(!(coerced15 !== undefined)){
	if(data13 === "false" || data13 === 0 || data13 === null){
	coerced15 = false;
	}
	else if(data13 === "true" || data13 === 1){
	coerced15 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/disableRequestLogging",schemaPath:"#/properties/disableRequestLogging/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced15 !== undefined){
	data13 = coerced15;
	if(data !== undefined){
	data["disableRequestLogging"] = coerced15;
	}
	}
	}
	var valid0 = _errs45 === errors;
	if(valid0){
	let data14 = data.maxParamLength;
	const _errs47 = errors;
	if(!(((typeof data14 == "number") && (!(data14 % 1) && !isNaN(data14))) && (isFinite(data14)))){
	let dataType16 = typeof data14;
	let coerced16 = undefined;
	if(!(coerced16 !== undefined)){
	if(dataType16 === "boolean" || data14 === null
	              || (dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1))){
	coerced16 = +data14;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/maxParamLength",schemaPath:"#/properties/maxParamLength/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced16 !== undefined){
	data14 = coerced16;
	if(data !== undefined){
	data["maxParamLength"] = coerced16;
	}
	}
	}
	var valid0 = _errs47 === errors;
	if(valid0){
	let data15 = data.onProtoPoisoning;
	const _errs49 = errors;
	if(typeof data15 !== "string"){
	let dataType17 = typeof data15;
	let coerced17 = undefined;
	if(!(coerced17 !== undefined)){
	if(dataType17 == "number" || dataType17 == "boolean"){
	coerced17 = "" + data15;
	}
	else if(data15 === null){
	coerced17 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/onProtoPoisoning",schemaPath:"#/properties/onProtoPoisoning/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced17 !== undefined){
	data15 = coerced17;
	if(data !== undefined){
	data["onProtoPoisoning"] = coerced17;
	}
	}
	}
	var valid0 = _errs49 === errors;
	if(valid0){
	let data16 = data.onConstructorPoisoning;
	const _errs51 = errors;
	if(typeof data16 !== "string"){
	let dataType18 = typeof data16;
	let coerced18 = undefined;
	if(!(coerced18 !== undefined)){
	if(dataType18 == "number" || dataType18 == "boolean"){
	coerced18 = "" + data16;
	}
	else if(data16 === null){
	coerced18 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/onConstructorPoisoning",schemaPath:"#/properties/onConstructorPoisoning/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced18 !== undefined){
	data16 = coerced18;
	if(data !== undefined){
	data["onConstructorPoisoning"] = coerced18;
	}
	}
	}
	var valid0 = _errs51 === errors;
	if(valid0){
	let data17 = data.pluginTimeout;
	const _errs53 = errors;
	if(!(((typeof data17 == "number") && (!(data17 % 1) && !isNaN(data17))) && (isFinite(data17)))){
	let dataType19 = typeof data17;
	let coerced19 = undefined;
	if(!(coerced19 !== undefined)){
	if(dataType19 === "boolean" || data17 === null
	              || (dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1))){
	coerced19 = +data17;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/pluginTimeout",schemaPath:"#/properties/pluginTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced19 !== undefined){
	data17 = coerced19;
	if(data !== undefined){
	data["pluginTimeout"] = coerced19;
	}
	}
	}
	var valid0 = _errs53 === errors;
	if(valid0){
	let data18 = data.requestIdHeader;
	const _errs55 = errors;
	const _errs56 = errors;
	let valid6 = false;
	const _errs57 = errors;
	if(typeof data18 !== "boolean"){
	let coerced20 = undefined;
	if(!(coerced20 !== undefined)){
	if(data18 === "false" || data18 === 0 || data18 === null){
	coerced20 = false;
	}
	else if(data18 === "true" || data18 === 1){
	coerced20 = true;
	}
	else {
	const err12 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf/0/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	}
	}
	if(coerced20 !== undefined){
	data18 = coerced20;
	if(data !== undefined){
	data["requestIdHeader"] = coerced20;
	}
	}
	}
	var _valid3 = _errs57 === errors;
	valid6 = valid6 || _valid3;
	if(!valid6){
	const _errs59 = errors;
	if(typeof data18 !== "string"){
	let dataType21 = typeof data18;
	let coerced21 = undefined;
	if(!(coerced21 !== undefined)){
	if(dataType21 == "number" || dataType21 == "boolean"){
	coerced21 = "" + data18;
	}
	else if(data18 === null){
	coerced21 = "";
	}
	else {
	const err13 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf/1/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err13];
	}
	else {
	vErrors.push(err13);
	}
	errors++;
	}
	}
	if(coerced21 !== undefined){
	data18 = coerced21;
	if(data !== undefined){
	data["requestIdHeader"] = coerced21;
	}
	}
	}
	var _valid3 = _errs59 === errors;
	valid6 = valid6 || _valid3;
	}
	if(!valid6){
	const err14 = {instancePath:instancePath+"/requestIdHeader",schemaPath:"#/properties/requestIdHeader/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err14];
	}
	else {
	vErrors.push(err14);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs56;
	if(vErrors !== null){
	if(_errs56){
	vErrors.length = _errs56;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid0 = _errs55 === errors;
	if(valid0){
	let data19 = data.requestIdLogLabel;
	const _errs61 = errors;
	if(typeof data19 !== "string"){
	let dataType22 = typeof data19;
	let coerced22 = undefined;
	if(!(coerced22 !== undefined)){
	if(dataType22 == "number" || dataType22 == "boolean"){
	coerced22 = "" + data19;
	}
	else if(data19 === null){
	coerced22 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/requestIdLogLabel",schemaPath:"#/properties/requestIdLogLabel/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced22 !== undefined){
	data19 = coerced22;
	if(data !== undefined){
	data["requestIdLogLabel"] = coerced22;
	}
	}
	}
	var valid0 = _errs61 === errors;
	if(valid0){
	let data20 = data.http2SessionTimeout;
	const _errs63 = errors;
	if(!(((typeof data20 == "number") && (!(data20 % 1) && !isNaN(data20))) && (isFinite(data20)))){
	let dataType23 = typeof data20;
	let coerced23 = undefined;
	if(!(coerced23 !== undefined)){
	if(dataType23 === "boolean" || data20 === null
	              || (dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1))){
	coerced23 = +data20;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/http2SessionTimeout",schemaPath:"#/properties/http2SessionTimeout/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];
	return false;
	}
	}
	if(coerced23 !== undefined){
	data20 = coerced23;
	if(data !== undefined){
	data["http2SessionTimeout"] = coerced23;
	}
	}
	}
	var valid0 = _errs63 === errors;
	if(valid0){
	let data21 = data.exposeHeadRoutes;
	const _errs65 = errors;
	if(typeof data21 !== "boolean"){
	let coerced24 = undefined;
	if(!(coerced24 !== undefined)){
	if(data21 === "false" || data21 === 0 || data21 === null){
	coerced24 = false;
	}
	else if(data21 === "true" || data21 === 1){
	coerced24 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/exposeHeadRoutes",schemaPath:"#/properties/exposeHeadRoutes/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced24 !== undefined){
	data21 = coerced24;
	if(data !== undefined){
	data["exposeHeadRoutes"] = coerced24;
	}
	}
	}
	var valid0 = _errs65 === errors;
	if(valid0){
	let data22 = data.useSemicolonDelimiter;
	const _errs67 = errors;
	if(typeof data22 !== "boolean"){
	let coerced25 = undefined;
	if(!(coerced25 !== undefined)){
	if(data22 === "false" || data22 === 0 || data22 === null){
	coerced25 = false;
	}
	else if(data22 === "true" || data22 === 1){
	coerced25 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/useSemicolonDelimiter",schemaPath:"#/properties/useSemicolonDelimiter/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced25 !== undefined){
	data22 = coerced25;
	if(data !== undefined){
	data["useSemicolonDelimiter"] = coerced25;
	}
	}
	}
	var valid0 = _errs67 === errors;
	if(valid0){
	if(data.constraints !== undefined){
	let data23 = data.constraints;
	const _errs69 = errors;
	if(errors === _errs69){
	if(data23 && typeof data23 == "object" && !Array.isArray(data23)){
	for(const key2 in data23){
	let data24 = data23[key2];
	const _errs72 = errors;
	if(errors === _errs72){
	if(data24 && typeof data24 == "object" && !Array.isArray(data24)){
	let missing1;
	if(((((data24.name === undefined) && (missing1 = "name")) || ((data24.storage === undefined) && (missing1 = "storage"))) || ((data24.validate === undefined) && (missing1 = "validate"))) || ((data24.deriveConstraint === undefined) && (missing1 = "deriveConstraint"))){
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/constraints/additionalProperties/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property '"+missing1+"'"}];
	return false;
	}
	else {
	if(data24.name !== undefined){
	let data25 = data24.name;
	if(typeof data25 !== "string"){
	let dataType26 = typeof data25;
	let coerced26 = undefined;
	if(!(coerced26 !== undefined)){
	if(dataType26 == "number" || dataType26 == "boolean"){
	coerced26 = "" + data25;
	}
	else if(data25 === null){
	coerced26 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1")+"/name",schemaPath:"#/properties/constraints/additionalProperties/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced26 !== undefined){
	data25 = coerced26;
	if(data24 !== undefined){
	data24["name"] = coerced26;
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/constraints/additionalProperties/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid7 = _errs72 === errors;
	if(!valid7){
	break;
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/constraints",schemaPath:"#/properties/constraints/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid0 = _errs69 === errors;
	}
	else {
	var valid0 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}


	configValidator$1.exports.defaultInitOptions = {"connectionTimeout":0,"keepAliveTimeout":72000,"maxRequestsPerSocket":0,"requestTimeout":0,"bodyLimit":1048576,"caseSensitive":true,"allowUnsafeRegex":false,"disableRequestLogging":false,"ignoreTrailingSlash":false,"ignoreDuplicateSlashes":false,"maxParamLength":100,"onProtoPoisoning":"error","onConstructorPoisoning":"error","pluginTimeout":10000,"requestIdHeader":false,"requestIdLogLabel":"reqId","http2SessionTimeout":72000,"exposeHeadRoutes":true,"useSemicolonDelimiter":false,"allowErrorHandlerOverride":true};
	/* c8 ignore stop */
	return configValidator$1.exports;
}

var hasRequiredInitialConfigValidation;

function requireInitialConfigValidation () {
	if (hasRequiredInitialConfigValidation) return initialConfigValidation.exports;
	hasRequiredInitialConfigValidation = 1;

	const validate = requireConfigValidator$1();
	const deepClone = requireRfdc()({ circles: true, proto: false });
	const { FST_ERR_INIT_OPTS_INVALID } = requireErrors$2();

	function validateInitialConfig (options) {
	  const opts = deepClone(options);

	  if (!validate(opts)) {
	    const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map(e => e.message)));
	    error.errors = validate.errors;
	    throw error
	  }

	  return deepFreezeObject(opts)
	}

	function deepFreezeObject (object) {
	  const properties = Object.getOwnPropertyNames(object);

	  for (const name of properties) {
	    const value = object[name];

	    if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
	      continue
	    }

	    object[name] = value && typeof value === 'object' ? deepFreezeObject(value) : value;
	  }

	  return Object.freeze(object)
	}

	initialConfigValidation.exports = validateInitialConfig;
	initialConfigValidation.exports.defaultInitOptions = validate.defaultInitOptions;
	initialConfigValidation.exports.utils = { deepFreezeObject };
	return initialConfigValidation.exports;
}

var pluginOverride;
var hasRequiredPluginOverride;

function requirePluginOverride () {
	if (hasRequiredPluginOverride) return pluginOverride;
	hasRequiredPluginOverride = 1;

	const {
	  kAvvioBoot,
	  kChildren,
	  kRoutePrefix,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kContentTypeParser,
	  kReply,
	  kRequest,
	  kFourOhFour,
	  kPluginNameChain,
	  kErrorHandlerAlreadySet
	} = requireSymbols$2();

	const Reply = requireReply();
	const Request = requireRequest$1();
	const SchemaController = requireSchemaController();
	const ContentTypeParser = requireContentTypeParser();
	const { buildHooks } = requireHooks();
	const pluginUtils = requirePluginUtils();

	// Function that runs the encapsulation magic.
	// Everything that need to be encapsulated must be handled in this function.
	pluginOverride = function override (old, fn, opts) {
	  const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);

	  const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
	  if (shouldSkipOverride) {
	    // after every plugin registration we will enter a new name
	    old[kPluginNameChain].push(fnName);
	    return old
	  }

	  const instance = Object.create(old);
	  old[kChildren].push(instance);
	  instance.ready = old[kAvvioBoot].bind(instance);
	  instance[kChildren] = [];

	  instance[kReply] = Reply.buildReply(instance[kReply]);
	  instance[kRequest] = Request.buildRequest(instance[kRequest]);

	  instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
	  instance[kHooks] = buildHooks(instance[kHooks]);
	  instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
	  instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
	  instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
	  instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
	  instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);

	  // Track the registered and loaded plugins since the root instance.
	  // It does not track the current encapsulated plugin.
	  instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);

	  // Track the plugin chain since the root instance.
	  // When an non-encapsulated plugin is added, the chain will be updated.
	  instance[kPluginNameChain] = [fnName];
	  instance[kErrorHandlerAlreadySet] = false;

	  if (instance[kLogSerializers] || opts.logSerializers) {
	    instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
	  }

	  if (opts.prefix) {
	    instance[kFourOhFour].arrange404(instance);
	  }

	  for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);

	  return instance
	};

	function buildRoutePrefix (instancePrefix, pluginPrefix) {
	  if (!pluginPrefix) {
	    return instancePrefix
	  }

	  // Ensure that there is a '/' between the prefixes
	  if (instancePrefix.endsWith('/') && pluginPrefix[0] === '/') {
	    // Remove the extra '/' to avoid: '/first//second'
	    pluginPrefix = pluginPrefix.slice(1);
	  } else if (pluginPrefix[0] !== '/') {
	    pluginPrefix = '/' + pluginPrefix;
	  }

	  return instancePrefix + pluginPrefix
	}
	return pluginOverride;
}

var noopSet;
var hasRequiredNoopSet;

function requireNoopSet () {
	if (hasRequiredNoopSet) return noopSet;
	hasRequiredNoopSet = 1;

	noopSet = function noopSet () {
	  return {
	    [Symbol.iterator]: function * () {},
	    add () {},
	    delete () {},
	    has () { return true }
	  }
	};
	return noopSet;
}

var lightMyRequest = {exports: {}};

var request = {exports: {}};

var dist$1 = {};

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;
	Object.defineProperty(dist$1, "__esModule", { value: true });
	dist$1.parse = parse;
	dist$1.serialize = serialize;
	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 *
	 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
	 * Allow same range as cookie value, except `=`, which delimits end of name.
	 */
	const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 *
	 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
	 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
	 */
	const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */
	const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */
	const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	const __toString = Object.prototype.toString;
	const NullObject = /* @__PURE__ */ (() => {
	    const C = function () { };
	    C.prototype = Object.create(null);
	    return C;
	})();
	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 */
	function parse(str, options) {
	    const obj = new NullObject();
	    const len = str.length;
	    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	    if (len < 2)
	        return obj;
	    const dec = options?.decode || decode;
	    let index = 0;
	    do {
	        const eqIdx = str.indexOf("=", index);
	        if (eqIdx === -1)
	            break; // No more cookie pairs.
	        const colonIdx = str.indexOf(";", index);
	        const endIdx = colonIdx === -1 ? len : colonIdx;
	        if (eqIdx > endIdx) {
	            // backtrack on prior semicolon
	            index = str.lastIndexOf(";", eqIdx - 1) + 1;
	            continue;
	        }
	        const keyStartIdx = startIndex(str, index, eqIdx);
	        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	        const key = str.slice(keyStartIdx, keyEndIdx);
	        // only assign once
	        if (obj[key] === undefined) {
	            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	            let valEndIdx = endIndex(str, endIdx, valStartIdx);
	            const value = dec(str.slice(valStartIdx, valEndIdx));
	            obj[key] = value;
	        }
	        index = endIdx + 1;
	    } while (index < len);
	    return obj;
	}
	function startIndex(str, index, max) {
	    do {
	        const code = str.charCodeAt(index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index;
	    } while (++index < max);
	    return max;
	}
	function endIndex(str, index, min) {
	    while (index > min) {
	        const code = str.charCodeAt(--index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index + 1;
	    }
	    return min;
	}
	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 */
	function serialize(name, val, options) {
	    const enc = options?.encode || encodeURIComponent;
	    if (!cookieNameRegExp.test(name)) {
	        throw new TypeError(`argument name is invalid: ${name}`);
	    }
	    const value = enc(val);
	    if (!cookieValueRegExp.test(value)) {
	        throw new TypeError(`argument val is invalid: ${val}`);
	    }
	    let str = name + "=" + value;
	    if (!options)
	        return str;
	    if (options.maxAge !== undefined) {
	        if (!Number.isInteger(options.maxAge)) {
	            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
	        }
	        str += "; Max-Age=" + options.maxAge;
	    }
	    if (options.domain) {
	        if (!domainValueRegExp.test(options.domain)) {
	            throw new TypeError(`option domain is invalid: ${options.domain}`);
	        }
	        str += "; Domain=" + options.domain;
	    }
	    if (options.path) {
	        if (!pathValueRegExp.test(options.path)) {
	            throw new TypeError(`option path is invalid: ${options.path}`);
	        }
	        str += "; Path=" + options.path;
	    }
	    if (options.expires) {
	        if (!isDate(options.expires) ||
	            !Number.isFinite(options.expires.valueOf())) {
	            throw new TypeError(`option expires is invalid: ${options.expires}`);
	        }
	        str += "; Expires=" + options.expires.toUTCString();
	    }
	    if (options.httpOnly) {
	        str += "; HttpOnly";
	    }
	    if (options.secure) {
	        str += "; Secure";
	    }
	    if (options.partitioned) {
	        str += "; Partitioned";
	    }
	    if (options.priority) {
	        const priority = typeof options.priority === "string"
	            ? options.priority.toLowerCase()
	            : undefined;
	        switch (priority) {
	            case "low":
	                str += "; Priority=Low";
	                break;
	            case "medium":
	                str += "; Priority=Medium";
	                break;
	            case "high":
	                str += "; Priority=High";
	                break;
	            default:
	                throw new TypeError(`option priority is invalid: ${options.priority}`);
	        }
	    }
	    if (options.sameSite) {
	        const sameSite = typeof options.sameSite === "string"
	            ? options.sameSite.toLowerCase()
	            : options.sameSite;
	        switch (sameSite) {
	            case true:
	            case "strict":
	                str += "; SameSite=Strict";
	                break;
	            case "lax":
	                str += "; SameSite=Lax";
	                break;
	            case "none":
	                str += "; SameSite=None";
	                break;
	            default:
	                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
	        }
	    }
	    return str;
	}
	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 */
	function decode(str) {
	    if (str.indexOf("%") === -1)
	        return str;
	    try {
	        return decodeURIComponent(str);
	    }
	    catch (e) {
	        return str;
	    }
	}
	/**
	 * Determine if value is a Date.
	 */
	function isDate(val) {
	    return __toString.call(val) === "[object Date]";
	}
	
	return dist$1;
}

var processWarning = {exports: {}};

var hasRequiredProcessWarning;

function requireProcessWarning () {
	if (hasRequiredProcessWarning) return processWarning.exports;
	hasRequiredProcessWarning = 1;

	const { format } = require$$0$3;

	/**
	 * @namespace processWarning
	 */

	/**
	 * Represents a warning item with details.
	 * @typedef {Function} WarningItem
	 * @param {*} [a] Possible message interpolation value.
	 * @param {*} [b] Possible message interpolation value.
	 * @param {*} [c] Possible message interpolation value.
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} emitted - Indicates if the warning has been emitted.
	 * @property {function} format - Formats the warning message.
	 */

	/**
	 * Options for creating a process warning.
	 * @typedef {Object} ProcessWarningOptions
	 * @property {string} name - The name of the warning.
	 * @property {string} code - The code associated with the warning.
	 * @property {string} message - The warning message.
	 * @property {boolean} [unlimited=false] - If true, allows unlimited emissions of the warning.
	 */

	/**
	 * Represents the process warning functionality.
	 * @typedef {Object} ProcessWarning
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 */

	/**
	 * Creates a deprecation warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created deprecation warning item.
	 */
	function createDeprecation (params) {
	  return createWarning({ ...params, name: 'DeprecationWarning' })
	}

	/**
	 * Creates a warning item.
	 * @function
	 * @memberof processWarning
	 * @param {ProcessWarningOptions} params - Options for creating the warning.
	 * @returns {WarningItem} The created warning item.
	 * @throws {Error} Throws an error if name, code, or message is empty, or if opts.unlimited is not a boolean.
	 */
	function createWarning ({ name, code, message, unlimited = false } = {}) {
	  if (!name) throw new Error('Warning name must not be empty')
	  if (!code) throw new Error('Warning code must not be empty')
	  if (!message) throw new Error('Warning message must not be empty')
	  if (typeof unlimited !== 'boolean') throw new Error('Warning opts.unlimited must be a boolean')

	  code = code.toUpperCase();

	  let warningContainer = {
	    [name]: function (a, b, c) {
	      if (warning.emitted === true && warning.unlimited !== true) {
	        return
	      }
	      warning.emitted = true;
	      process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	    }
	  };
	  if (unlimited) {
	    warningContainer = {
	      [name]: function (a, b, c) {
	        warning.emitted = true;
	        process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
	      }
	    };
	  }

	  const warning = warningContainer[name];

	  warning.emitted = false;
	  warning.message = message;
	  warning.unlimited = unlimited;
	  warning.code = code;

	  /**
	   * Formats the warning message.
	   * @param {*} [a] Possible message interpolation value.
	   * @param {*} [b] Possible message interpolation value.
	   * @param {*} [c] Possible message interpolation value.
	   * @returns {string} The formatted warning message.
	   */
	  warning.format = function (a, b, c) {
	    let formatted;
	    if (a && b && c) {
	      formatted = format(message, a, b, c);
	    } else if (a && b) {
	      formatted = format(message, a, b);
	    } else if (a) {
	      formatted = format(message, a);
	    } else {
	      formatted = message;
	    }
	    return formatted
	  };

	  return warning
	}

	/**
	 * Module exports containing the process warning functionality.
	 * @namespace
	 * @property {function} createWarning - Creates a warning item.
	 * @property {function} createDeprecation - Creates a deprecation warning item.
	 * @property {ProcessWarning} processWarning - Represents the process warning functionality.
	 */
	const out = { createWarning, createDeprecation };
	processWarning.exports = out;
	processWarning.exports.default = out;
	processWarning.exports.processWarning = out;
	return processWarning.exports;
}

var parseUrl;
var hasRequiredParseUrl;

function requireParseUrl () {
	if (hasRequiredParseUrl) return parseUrl;
	hasRequiredParseUrl = 1;

	const { URL } = require$$1$6;

	const BASE_URL = 'http://localhost';

	/**
	 * Parse URL
	 *
	 * @param {(Object|String)} url
	 * @param {Object} [query]
	 * @return {URL}
	 */
	parseUrl = function parseURL (url, query) {
	  if ((typeof url === 'string' || Object.prototype.toString.call(url) === '[object String]') && url.startsWith('//')) {
	    url = BASE_URL + url;
	  }
	  const result = typeof url === 'object'
	    ? Object.assign(new URL(BASE_URL), url)
	    : new URL(url, BASE_URL);

	  if (typeof query === 'string') {
	    query = new URLSearchParams(query);
	    for (const key of query.keys()) {
	      result.searchParams.delete(key);
	      for (const value of query.getAll(key)) {
	        result.searchParams.append(key, value);
	      }
	    }
	  } else {
	    const merged = Object.assign({}, url.query, query);
	    for (const key in merged) {
	      const value = merged[key];

	      if (Array.isArray(value)) {
	        result.searchParams.delete(key);
	        for (const param of value) {
	          result.searchParams.append(key, param);
	        }
	      } else {
	        result.searchParams.set(key, value);
	      }
	    }
	  }

	  return result
	};
	return parseUrl;
}

var formData = {};

var hasRequiredFormData;

function requireFormData () {
	if (hasRequiredFormData) return formData;
	hasRequiredFormData = 1;

	const { randomUUID } = require$$0$c;
	const { Readable } = require$$1$5;

	let textEncoder;

	function isFormDataLike (payload) {
	  return (
	    payload &&
	    typeof payload === 'object' &&
	    typeof payload.append === 'function' &&
	    typeof payload.delete === 'function' &&
	    typeof payload.get === 'function' &&
	    typeof payload.getAll === 'function' &&
	    typeof payload.has === 'function' &&
	    typeof payload.set === 'function' &&
	    payload[Symbol.toStringTag] === 'FormData'
	  )
	}

	/*
	  partial code extraction and refactoring of `undici`.
	  MIT License. https://github.com/nodejs/undici/blob/043d8f1a89f606b1db259fc71f4c9bc8eb2aa1e6/lib/web/fetch/LICENSE
	  Reference https://github.com/nodejs/undici/blob/043d8f1a89f606b1db259fc71f4c9bc8eb2aa1e6/lib/web/fetch/body.js#L102-L168
	*/
	function formDataToStream (formdata) {
	  // lazy creation of TextEncoder
	  textEncoder = textEncoder ?? new TextEncoder();

	  // we expect the function argument must be FormData
	  const boundary = `----formdata-${randomUUID()}`;
	  const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

	  /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
	  const escape = (str) =>
	    str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
	  const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');

	  const linebreak = new Uint8Array([13, 10]); // '\r\n'

	  async function * asyncIterator () {
	    for (const [name, value] of formdata) {
	      if (typeof value === 'string') {
	        // header
	        yield textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"\r\n\r\n`);
	        // body
	        yield textEncoder.encode(`${normalizeLinefeeds(value)}\r\n`);
	      } else {
	        let header = `${prefix}; name="${escape(normalizeLinefeeds(name))}"`;
	        value.name && (header += `; filename="${escape(value.name)}"`);
	        header += `\r\nContent-Type: ${value.type || 'application/octet-stream'}\r\n\r\n`;
	        // header
	        yield textEncoder.encode(header);
	        // body
	        if (value.stream) {
	          yield * value.stream();
	        } /* c8 ignore start */ else {
	          // shouldn't be here since Blob / File should provide .stream
	          // and FormData always convert to USVString
	          yield value;
	        } /* c8 ignore stop */
	        yield linebreak;
	      }
	    }
	    // end
	    yield textEncoder.encode(`--${boundary}--`);
	  }

	  const stream = Readable.from(asyncIterator());

	  return {
	    stream,
	    contentType: `multipart/form-data; boundary=${boundary}`
	  }
	}

	formData.isFormDataLike = isFormDataLike;
	formData.formDataToStream = formDataToStream;
	return formData;
}

var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request.exports;
	hasRequiredRequest = 1;

	/* eslint no-prototype-builtins: 0 */

	const { Readable, addAbortSignal } = require$$1$5;
	const util = require$$0$3;
	const cookie = requireDist$1();
	const assert = require$$0$b;
	const { createDeprecation } = requireProcessWarning();

	const parseURL = requireParseUrl();
	const { isFormDataLike, formDataToStream } = requireFormData();
	const { EventEmitter } = require$$0$4;

	// request.connectin deprecation https://nodejs.org/api/http.html#http_request_connection
	const FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
	  name: 'FastifyDeprecationLightMyRequest',
	  code: 'FST_LIGHTMYREQUEST_DEP01',
	  message: 'You are accessing "request.connection", use "request.socket" instead.'
	});

	/**
	 * Get hostname:port
	 *
	 * @param {URL} parsedURL
	 * @return {String}
	 */
	function hostHeaderFromURL (parsedURL) {
	  return parsedURL.port
	    ? parsedURL.host
	    : parsedURL.hostname + (parsedURL.protocol === 'https:' ? ':443' : ':80')
	}

	/**
	 * Mock socket object used to fake access to a socket for a request
	 *
	 * @constructor
	 * @param {String} remoteAddress the fake address to show consumers of the socket
	 */
	class MockSocket extends EventEmitter {
	  constructor (remoteAddress) {
	    super();
	    this.remoteAddress = remoteAddress;
	  }
	}

	/**
	 * CustomRequest
	 *
	 * @constructor
	 * @param {Object} options
	 * @param {(Object|String)} options.url || options.path
	 * @param {String} [options.method='GET']
	 * @param {String} [options.remoteAddress]
	 * @param {Object} [options.cookies]
	 * @param {Object} [options.headers]
	 * @param {Object} [options.query]
	 * @param {Object} [options.Request]
	 * @param {any} [options.payload]
	 */
	function CustomRequest (options) {
	  return new _CustomLMRRequest(this)

	  function _CustomLMRRequest (obj) {
	    Request.call(obj, {
	      ...options,
	      Request: undefined
	    });
	    Object.assign(this, obj);

	    for (const fn of Object.keys(Request.prototype)) {
	      this.constructor.prototype[fn] = Request.prototype[fn];
	    }

	    util.inherits(this.constructor, options.Request);
	    return this
	  }
	}

	/**
	 * Request
	 *
	 * @constructor
	 * @param {Object} options
	 * @param {(Object|String)} options.url || options.path
	 * @param {String} [options.method='GET']
	 * @param {String} [options.remoteAddress]
	 * @param {Object} [options.cookies]
	 * @param {Object} [options.headers]
	 * @param {Object} [options.query]
	 * @param {any} [options.payload]
	 */
	function Request (options) {
	  Readable.call(this, {
	    autoDestroy: false
	  });

	  const parsedURL = parseURL(options.url || options.path, options.query);

	  this.url = parsedURL.pathname + parsedURL.search;

	  this.aborted = false;
	  this.httpVersionMajor = 1;
	  this.httpVersionMinor = 1;
	  this.httpVersion = '1.1';
	  this.method = options.method ? options.method.toUpperCase() : 'GET';

	  this.headers = {};
	  this.rawHeaders = [];

	  const headers = options.headers || {};

	  for (const field in headers) {
	    const fieldLowerCase = field.toLowerCase();
	    if (
	      (
	        fieldLowerCase === 'user-agent' ||
	        fieldLowerCase === 'content-type'
	      ) && headers[field] === undefined
	    ) {
	      this.headers[fieldLowerCase] = undefined;
	      continue
	    }
	    const value = headers[field];
	    assert(value !== undefined, 'invalid value "undefined" for header ' + field);
	    this.headers[fieldLowerCase] = '' + value;
	  }

	  if (('user-agent' in this.headers) === false) {
	    this.headers['user-agent'] = 'lightMyRequest';
	  }
	  this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);

	  if (options.cookies) {
	    const { cookies } = options;
	    const cookieValues = Object.keys(cookies).map(key => cookie.serialize(key, cookies[key]));
	    if (this.headers.cookie) {
	      cookieValues.unshift(this.headers.cookie);
	    }
	    this.headers.cookie = cookieValues.join('; ');
	  }

	  this.socket = new MockSocket(options.remoteAddress || '127.0.0.1');

	  Object.defineProperty(this, 'connection', {
	    get () {
	      FST_LIGHTMYREQUEST_DEP01();
	      return this.socket
	    },
	    configurable: true
	  });

	  // we keep both payload and body for compatibility reasons
	  let payload = options.payload || options.body || null;
	  let payloadResume = payload && typeof payload.resume === 'function';

	  if (isFormDataLike(payload)) {
	    const stream = formDataToStream(payload);
	    payload = stream.stream;
	    payloadResume = true;
	    // we override the content-type
	    this.headers['content-type'] = stream.contentType;
	    this.headers['transfer-encoding'] = 'chunked';
	  }

	  if (payload && typeof payload !== 'string' && !payloadResume && !Buffer.isBuffer(payload)) {
	    payload = JSON.stringify(payload);

	    if (('content-type' in this.headers) === false) {
	      this.headers['content-type'] = 'application/json';
	    }
	  }

	  // Set the content-length for the corresponding payload if none set
	  if (payload && !payloadResume && !Object.hasOwn(this.headers, 'content-length')) {
	    this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
	  }

	  for (const header of Object.keys(this.headers)) {
	    this.rawHeaders.push(header, this.headers[header]);
	  }

	  // Use _lightMyRequest namespace to avoid collision with Node
	  this._lightMyRequest = {
	    payload,
	    isDone: false,
	    simulate: options.simulate || {},
	    payloadAsStream: options.payloadAsStream,
	    signal: options.signal
	  };

	  const signal = options.signal;
	  /* c8 ignore next 3 */
	  if (signal) {
	    addAbortSignal(signal, this);
	  }

	  {
	    const payload = this._lightMyRequest.payload;
	    if (payload?._readableState) { // does quack like a modern stream
	      this._read = readStream;

	      payload.on('error', (err) => {
	        this.destroy(err);
	      });

	      payload.on('end', () => {
	        this.push(null);
	      });
	    } else {
	      // Stream v1 are handled in index.js synchronously
	      this._read = readEverythingElse;
	    }
	  }

	  return this
	}

	function readStream () {
	  const payload = this._lightMyRequest.payload;

	  let more = true;
	  let pushed = false;
	  let chunk;
	  while (more && (chunk = payload.read())) {
	    pushed = true;
	    more = this.push(chunk);
	  }

	  // We set up a recursive 'readable' event only if we didn't read anything.
	  // Otheriwse, the stream machinery will call _read() for us.
	  if (more && !pushed) {
	    this._lightMyRequest.payload.once('readable', this._read.bind(this));
	  }
	}

	function readEverythingElse () {
	  setImmediate(() => {
	    if (this._lightMyRequest.isDone) {
	      // 'end' defaults to true
	      if (this._lightMyRequest.simulate.end !== false) {
	        this.push(null);
	      }
	      return
	    }

	    this._lightMyRequest.isDone = true;

	    if (this._lightMyRequest.payload) {
	      if (this._lightMyRequest.simulate.split) {
	        this.push(this._lightMyRequest.payload.slice(0, 1));
	        this.push(this._lightMyRequest.payload.slice(1));
	      } else {
	        this.push(this._lightMyRequest.payload);
	      }
	    }

	    if (this._lightMyRequest.simulate.error) {
	      this.emit('error', new Error('Simulated'));
	    }

	    if (this._lightMyRequest.simulate.close) {
	      this.emit('close');
	    }

	    // 'end' defaults to true
	    if (this._lightMyRequest.simulate.end !== false) {
	      this.push(null);
	    }
	  });
	}

	util.inherits(Request, Readable);
	util.inherits(CustomRequest, Request);

	Request.prototype.destroy = function (error) {
	  if (this.destroyed || this._lightMyRequest.isDone) return
	  this.destroyed = true;

	  if (error) {
	    this._error = true;
	    process.nextTick(() => this.emit('error', error));
	  }

	  process.nextTick(() => this.emit('close'));
	};

	request.exports = Request;
	request.exports.Request = Request;
	request.exports.CustomRequest = CustomRequest;
	return request.exports;
}

var setCookie = {exports: {}};

var hasRequiredSetCookie;

function requireSetCookie () {
	if (hasRequiredSetCookie) return setCookie.exports;
	hasRequiredSetCookie = 1;

	var defaultParseOptions = {
	  decodeValues: true,
	  map: false,
	  silent: false,
	};

	function isNonEmptyString(str) {
	  return typeof str === "string" && !!str.trim();
	}

	function parseString(setCookieValue, options) {
	  var parts = setCookieValue.split(";").filter(isNonEmptyString);

	  var nameValuePairStr = parts.shift();
	  var parsed = parseNameValuePair(nameValuePairStr);
	  var name = parsed.name;
	  var value = parsed.value;

	  options = options
	    ? Object.assign({}, defaultParseOptions, options)
	    : defaultParseOptions;

	  try {
	    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
	  } catch (e) {
	    console.error(
	      "set-cookie-parser encountered an error while decoding a cookie with value '" +
	        value +
	        "'. Set options.decodeValues to false to disable this feature.",
	      e
	    );
	  }

	  var cookie = {
	    name: name,
	    value: value,
	  };

	  parts.forEach(function (part) {
	    var sides = part.split("=");
	    var key = sides.shift().trimLeft().toLowerCase();
	    var value = sides.join("=");
	    if (key === "expires") {
	      cookie.expires = new Date(value);
	    } else if (key === "max-age") {
	      cookie.maxAge = parseInt(value, 10);
	    } else if (key === "secure") {
	      cookie.secure = true;
	    } else if (key === "httponly") {
	      cookie.httpOnly = true;
	    } else if (key === "samesite") {
	      cookie.sameSite = value;
	    } else if (key === "partitioned") {
	      cookie.partitioned = true;
	    } else {
	      cookie[key] = value;
	    }
	  });

	  return cookie;
	}

	function parseNameValuePair(nameValuePairStr) {
	  // Parses name-value-pair according to rfc6265bis draft

	  var name = "";
	  var value = "";
	  var nameValueArr = nameValuePairStr.split("=");
	  if (nameValueArr.length > 1) {
	    name = nameValueArr.shift();
	    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
	  } else {
	    value = nameValuePairStr;
	  }

	  return { name: name, value: value };
	}

	function parse(input, options) {
	  options = options
	    ? Object.assign({}, defaultParseOptions, options)
	    : defaultParseOptions;

	  if (!input) {
	    if (!options.map) {
	      return [];
	    } else {
	      return {};
	    }
	  }

	  if (input.headers) {
	    if (typeof input.headers.getSetCookie === "function") {
	      // for fetch responses - they combine headers of the same type in the headers array,
	      // but getSetCookie returns an uncombined array
	      input = input.headers.getSetCookie();
	    } else if (input.headers["set-cookie"]) {
	      // fast-path for node.js (which automatically normalizes header names to lower-case
	      input = input.headers["set-cookie"];
	    } else {
	      // slow-path for other environments - see #25
	      var sch =
	        input.headers[
	          Object.keys(input.headers).find(function (key) {
	            return key.toLowerCase() === "set-cookie";
	          })
	        ];
	      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
	      if (!sch && input.headers.cookie && !options.silent) {
	        console.warn(
	          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
	        );
	      }
	      input = sch;
	    }
	  }
	  if (!Array.isArray(input)) {
	    input = [input];
	  }

	  if (!options.map) {
	    return input.filter(isNonEmptyString).map(function (str) {
	      return parseString(str, options);
	    });
	  } else {
	    var cookies = {};
	    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
	      var cookie = parseString(str, options);
	      cookies[cookie.name] = cookie;
	      return cookies;
	    }, cookies);
	  }
	}

	/*
	  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
	  that are within a single set-cookie field-value, such as in the Expires portion.

	  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
	  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
	  React Native's fetch does this for *every* header, including set-cookie.

	  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
	  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
	*/
	function splitCookiesString(cookiesString) {
	  if (Array.isArray(cookiesString)) {
	    return cookiesString;
	  }
	  if (typeof cookiesString !== "string") {
	    return [];
	  }

	  var cookiesStrings = [];
	  var pos = 0;
	  var start;
	  var ch;
	  var lastComma;
	  var nextStart;
	  var cookiesSeparatorFound;

	  function skipWhitespace() {
	    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
	      pos += 1;
	    }
	    return pos < cookiesString.length;
	  }

	  function notSpecialChar() {
	    ch = cookiesString.charAt(pos);

	    return ch !== "=" && ch !== ";" && ch !== ",";
	  }

	  while (pos < cookiesString.length) {
	    start = pos;
	    cookiesSeparatorFound = false;

	    while (skipWhitespace()) {
	      ch = cookiesString.charAt(pos);
	      if (ch === ",") {
	        // ',' is a cookie separator if we have later first '=', not ';' or ','
	        lastComma = pos;
	        pos += 1;

	        skipWhitespace();
	        nextStart = pos;

	        while (pos < cookiesString.length && notSpecialChar()) {
	          pos += 1;
	        }

	        // currently special character
	        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
	          // we found cookies separator
	          cookiesSeparatorFound = true;
	          // pos is inside the next cookie, so back up and return it.
	          pos = nextStart;
	          cookiesStrings.push(cookiesString.substring(start, lastComma));
	          start = pos;
	        } else {
	          // in param ',' or param separator ';',
	          // we continue from that comma
	          pos = lastComma + 1;
	        }
	      } else {
	        pos += 1;
	      }
	    }

	    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
	      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
	    }
	  }

	  return cookiesStrings;
	}

	setCookie.exports = parse;
	setCookie.exports.parse = parse;
	setCookie.exports.parseString = parseString;
	setCookie.exports.splitCookiesString = splitCookiesString;
	return setCookie.exports;
}

var response;
var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;

	const http = require$$0$5;
	const { Writable, Readable, addAbortSignal } = require$$1$5;
	const util = require$$0$3;

	const setCookie = /*@__PURE__*/ requireSetCookie();

	function Response (req, onEnd, reject) {
	  http.ServerResponse.call(this, req);

	  if (req._lightMyRequest?.payloadAsStream) {
	    const read = this.emit.bind(this, 'drain');
	    this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
	    const signal = req._lightMyRequest.signal;

	    if (signal) {
	      addAbortSignal(signal, this._lightMyRequest.stream);
	    }
	  } else {
	    this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
	  }
	  // This forces node@8 to always render the headers
	  this.setHeader('foo', 'bar'); this.removeHeader('foo');

	  this.assignSocket(getNullSocket());

	  this._promiseCallback = typeof reject === 'function';

	  let called = false;
	  const onEndSuccess = (payload) => {
	    if (called) return
	    called = true;
	    if (this._promiseCallback) {
	      return process.nextTick(() => onEnd(payload))
	    }
	    process.nextTick(() => onEnd(null, payload));
	  };
	  this._lightMyRequest.onEndSuccess = onEndSuccess;

	  let finished = false;
	  const onEndFailure = (err) => {
	    if (called) {
	      if (this._lightMyRequest.stream && !finished) {
	        if (!err) {
	          err = new Error('response destroyed before completion');
	          err.code = 'LIGHT_ECONNRESET';
	        }
	        this._lightMyRequest.stream.destroy(err);
	        this._lightMyRequest.stream.on('error', () => {});
	      }
	      return
	    }
	    called = true;
	    if (!err) {
	      err = new Error('response destroyed before completion');
	      err.code = 'LIGHT_ECONNRESET';
	    }
	    if (this._promiseCallback) {
	      return process.nextTick(() => reject(err))
	    }
	    process.nextTick(() => onEnd(err, null));
	  };

	  if (this._lightMyRequest.stream) {
	    this.once('finish', () => {
	      finished = true;
	      this._lightMyRequest.stream.push(null);
	    });
	  } else {
	    this.once('finish', () => {
	      const res = generatePayload(this);
	      res.raw.req = req;
	      onEndSuccess(res);
	    });
	  }

	  this.connection.once('error', onEndFailure);

	  this.once('error', onEndFailure);

	  this.once('close', onEndFailure);
	}

	util.inherits(Response, http.ServerResponse);

	Response.prototype.setTimeout = function (msecs, callback) {
	  this.timeoutHandle = setTimeout(() => {
	    this.emit('timeout');
	  }, msecs);
	  this.on('timeout', callback);
	  return this
	};

	Response.prototype.writeHead = function () {
	  const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);

	  copyHeaders(this);

	  if (this._lightMyRequest.stream) {
	    this._lightMyRequest.onEndSuccess(generatePayload(this));
	  }

	  return result
	};

	Response.prototype.write = function (data, encoding, callback) {
	  if (this.timeoutHandle) {
	    clearTimeout(this.timeoutHandle);
	  }
	  http.ServerResponse.prototype.write.call(this, data, encoding, callback);
	  if (this._lightMyRequest.stream) {
	    return this._lightMyRequest.stream.push(Buffer.from(data, encoding))
	  } else {
	    this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
	    return true
	  }
	};

	Response.prototype.end = function (data, encoding, callback) {
	  if (data) {
	    this.write(data, encoding);
	  }

	  http.ServerResponse.prototype.end.call(this, callback);

	  this.emit('finish');

	  // We need to emit 'close' otherwise stream.finished() would
	  // not pick it up on Node v16

	  this.destroy();
	};

	Response.prototype.destroy = function (error) {
	  if (this.destroyed) return
	  this.destroyed = true;

	  if (error) {
	    process.nextTick(() => this.emit('error', error));
	  }

	  process.nextTick(() => this.emit('close'));
	};

	Response.prototype.addTrailers = function (trailers) {
	  for (const key in trailers) {
	    this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
	  }
	};

	function generatePayload (response) {
	  // This seems only to happen when using `fastify-express` - see https://github.com/fastify/fastify-express/issues/47
	  /* c8 ignore next 3  */
	  if (response._lightMyRequest.headers === null) {
	    copyHeaders(response);
	  }
	  serializeHeaders(response);
	  // Prepare response object
	  const res = {
	    raw: {
	      res: response
	    },
	    headers: response._lightMyRequest.headers,
	    statusCode: response.statusCode,
	    statusMessage: response.statusMessage,
	    trailers: {},
	    get cookies () {
	      return setCookie.parse(this)
	    }
	  };

	  res.trailers = response._lightMyRequest.trailers;

	  if (response._lightMyRequest.payloadChunks) {
	    // Prepare payload and trailers
	    const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
	    res.rawPayload = rawBuffer;

	    // we keep both of them for compatibility reasons
	    res.payload = rawBuffer.toString();
	    res.body = res.payload;

	    // Prepare payload parsers
	    res.json = function parseJsonPayload () {
	      return JSON.parse(res.payload)
	    };
	  } else {
	    res.json = function () {
	      throw new Error('Response payload is not available with payloadAsStream: true')
	    };
	  }

	  // Provide stream Readable for advanced user
	  res.stream = function streamPayload () {
	    if (response._lightMyRequest.stream) {
	      return response._lightMyRequest.stream
	    }
	    return Readable.from(response._lightMyRequest.payloadChunks)
	  };

	  return res
	}

	// Throws away all written data to prevent response from buffering payload
	function getNullSocket () {
	  return new Writable({
	    write (_chunk, _encoding, callback) {
	      setImmediate(callback);
	    }
	  })
	}

	function serializeHeaders (response) {
	  const headers = response._lightMyRequest.headers;

	  for (const headerName of Object.keys(headers)) {
	    const headerValue = headers[headerName];
	    if (Array.isArray(headerValue)) {
	      headers[headerName] = headerValue.map(value => '' + value);
	    } else {
	      headers[headerName] = '' + headerValue;
	    }
	  }
	}

	function copyHeaders (response) {
	  response._lightMyRequest.headers = Object.assign({}, response.getHeaders())

	  // Add raw headers
	  ;['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {
	    const regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');
	    const field = response._header?.match(regex);
	    if (field) {
	      response._lightMyRequest.headers[name.toLowerCase()] = field[1];
	    }
	  });
	}

	response = Response;
	return response;
}

var configValidator = {exports: {}};

var hasRequiredConfigValidator;

function requireConfigValidator () {
	if (hasRequiredConfigValidator) return configValidator.exports;
	hasRequiredConfigValidator = 1;
	configValidator.exports = validate10;
	configValidator.exports.default = validate10;
	const schema11 = {"properties":{"method":{"enum":["ACL","BIND","CHECKOUT","CONNECT","COPY","DELETE","GET","HEAD","LINK","LOCK","M-SEARCH","MERGE","MKACTIVITY","MKCALENDAR","MKCOL","MOVE","NOTIFY","OPTIONS","PATCH","POST","PROPFIND","PROPPATCH","PURGE","PUT","QUERY","REBIND","REPORT","SEARCH","SOURCE","SUBSCRIBE","TRACE","UNBIND","UNLINK","UNLOCK","UNSUBSCRIBE","acl","bind","checkout","connect","copy","delete","get","head","link","lock","m-search","merge","mkactivity","mkcalendar","mkcol","move","notify","options","patch","post","propfind","proppatch","purge","put","query","rebind","report","search","source","subscribe","trace","unbind","unlink","unlock","unsubscribe"]}}};

	function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
	let vErrors = null;
	let errors = 0;
	const _errs1 = errors;
	let valid0 = false;
	let passing0 = null;
	const _errs2 = errors;
	if(data && typeof data == "object" && !Array.isArray(data)){
	let missing0;
	if((data.url === undefined) && (missing0 = "url")){
	const err0 = {instancePath,schemaPath:"#/oneOf/0/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"};
	if(vErrors === null){
	vErrors = [err0];
	}
	else {
	vErrors.push(err0);
	}
	errors++;
	}
	}
	var _valid0 = _errs2 === errors;
	if(_valid0){
	valid0 = true;
	passing0 = 0;
	}
	const _errs3 = errors;
	if(data && typeof data == "object" && !Array.isArray(data)){
	let missing1;
	if((data.path === undefined) && (missing1 = "path")){
	const err1 = {instancePath,schemaPath:"#/oneOf/1/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property '"+missing1+"'"};
	if(vErrors === null){
	vErrors = [err1];
	}
	else {
	vErrors.push(err1);
	}
	errors++;
	}
	}
	var _valid0 = _errs3 === errors;
	if(_valid0 && valid0){
	valid0 = false;
	passing0 = [passing0, 1];
	}
	else {
	if(_valid0){
	valid0 = true;
	passing0 = 1;
	}
	}
	if(!valid0){
	const err2 = {instancePath,schemaPath:"#/oneOf",keyword:"oneOf",params:{passingSchemas: passing0},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err2];
	}
	else {
	vErrors.push(err2);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs1;
	if(vErrors !== null){
	if(_errs1){
	vErrors.length = _errs1;
	}
	else {
	vErrors = null;
	}
	}
	}
	if(errors === 0){
	if(data && typeof data == "object" && !Array.isArray(data)){
	if(data.url !== undefined){
	let data0 = data.url;
	const _errs5 = errors;
	const _errs6 = errors;
	let valid2 = false;
	let passing1 = null;
	const _errs7 = errors;
	if(typeof data0 !== "string"){
	let dataType0 = typeof data0;
	let coerced0 = undefined;
	if(!(coerced0 !== undefined)){
	if(dataType0 == "number" || dataType0 == "boolean"){
	coerced0 = "" + data0;
	}
	else if(data0 === null){
	coerced0 = "";
	}
	else {
	const err3 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err3];
	}
	else {
	vErrors.push(err3);
	}
	errors++;
	}
	}
	if(coerced0 !== undefined){
	data0 = coerced0;
	if(data !== undefined){
	data["url"] = coerced0;
	}
	}
	}
	var _valid1 = _errs7 === errors;
	if(_valid1){
	valid2 = true;
	passing1 = 0;
	}
	const _errs9 = errors;
	if(errors === _errs9){
	if(data0 && typeof data0 == "object" && !Array.isArray(data0)){
	let missing2;
	if((data0.pathname === undefined) && (missing2 = "pathname")){
	const err4 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/1/required",keyword:"required",params:{missingProperty: missing2},message:"must have required property '"+missing2+"'"};
	if(vErrors === null){
	vErrors = [err4];
	}
	else {
	vErrors.push(err4);
	}
	errors++;
	}
	else {
	if(data0.protocol !== undefined){
	let data1 = data0.protocol;
	const _errs12 = errors;
	if(typeof data1 !== "string"){
	let dataType1 = typeof data1;
	let coerced1 = undefined;
	if(!(coerced1 !== undefined)){
	if(dataType1 == "number" || dataType1 == "boolean"){
	coerced1 = "" + data1;
	}
	else if(data1 === null){
	coerced1 = "";
	}
	else {
	const err5 = {instancePath:instancePath+"/url/protocol",schemaPath:"#/properties/url/oneOf/1/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err5];
	}
	else {
	vErrors.push(err5);
	}
	errors++;
	}
	}
	if(coerced1 !== undefined){
	data1 = coerced1;
	if(data0 !== undefined){
	data0["protocol"] = coerced1;
	}
	}
	}
	var valid3 = _errs12 === errors;
	}
	else {
	var valid3 = true;
	}
	if(valid3){
	if(data0.hostname !== undefined){
	let data2 = data0.hostname;
	const _errs14 = errors;
	if(typeof data2 !== "string"){
	let dataType2 = typeof data2;
	let coerced2 = undefined;
	if(!(coerced2 !== undefined)){
	if(dataType2 == "number" || dataType2 == "boolean"){
	coerced2 = "" + data2;
	}
	else if(data2 === null){
	coerced2 = "";
	}
	else {
	const err6 = {instancePath:instancePath+"/url/hostname",schemaPath:"#/properties/url/oneOf/1/properties/hostname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err6];
	}
	else {
	vErrors.push(err6);
	}
	errors++;
	}
	}
	if(coerced2 !== undefined){
	data2 = coerced2;
	if(data0 !== undefined){
	data0["hostname"] = coerced2;
	}
	}
	}
	var valid3 = _errs14 === errors;
	}
	else {
	var valid3 = true;
	}
	if(valid3){
	if(data0.pathname !== undefined){
	let data3 = data0.pathname;
	const _errs16 = errors;
	if(typeof data3 !== "string"){
	let dataType3 = typeof data3;
	let coerced3 = undefined;
	if(!(coerced3 !== undefined)){
	if(dataType3 == "number" || dataType3 == "boolean"){
	coerced3 = "" + data3;
	}
	else if(data3 === null){
	coerced3 = "";
	}
	else {
	const err7 = {instancePath:instancePath+"/url/pathname",schemaPath:"#/properties/url/oneOf/1/properties/pathname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err7];
	}
	else {
	vErrors.push(err7);
	}
	errors++;
	}
	}
	if(coerced3 !== undefined){
	data3 = coerced3;
	if(data0 !== undefined){
	data0["pathname"] = coerced3;
	}
	}
	}
	var valid3 = _errs16 === errors;
	}
	else {
	var valid3 = true;
	}
	}
	}
	}
	}
	else {
	const err8 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf/1/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err8];
	}
	else {
	vErrors.push(err8);
	}
	errors++;
	}
	}
	var _valid1 = _errs9 === errors;
	if(_valid1 && valid2){
	valid2 = false;
	passing1 = [passing1, 1];
	}
	else {
	if(_valid1){
	valid2 = true;
	passing1 = 1;
	}
	}
	if(!valid2){
	const err9 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/oneOf",keyword:"oneOf",params:{passingSchemas: passing1},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err9];
	}
	else {
	vErrors.push(err9);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs6;
	if(vErrors !== null){
	if(_errs6){
	vErrors.length = _errs6;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs5 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.path !== undefined){
	let data4 = data.path;
	const _errs18 = errors;
	const _errs19 = errors;
	let valid4 = false;
	let passing2 = null;
	const _errs20 = errors;
	if(typeof data4 !== "string"){
	let dataType4 = typeof data4;
	let coerced4 = undefined;
	if(!(coerced4 !== undefined)){
	if(dataType4 == "number" || dataType4 == "boolean"){
	coerced4 = "" + data4;
	}
	else if(data4 === null){
	coerced4 = "";
	}
	else {
	const err10 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/0/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err10];
	}
	else {
	vErrors.push(err10);
	}
	errors++;
	}
	}
	if(coerced4 !== undefined){
	data4 = coerced4;
	if(data !== undefined){
	data["path"] = coerced4;
	}
	}
	}
	var _valid2 = _errs20 === errors;
	if(_valid2){
	valid4 = true;
	passing2 = 0;
	}
	const _errs22 = errors;
	if(errors === _errs22){
	if(data4 && typeof data4 == "object" && !Array.isArray(data4)){
	let missing3;
	if((data4.pathname === undefined) && (missing3 = "pathname")){
	const err11 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/1/required",keyword:"required",params:{missingProperty: missing3},message:"must have required property '"+missing3+"'"};
	if(vErrors === null){
	vErrors = [err11];
	}
	else {
	vErrors.push(err11);
	}
	errors++;
	}
	else {
	if(data4.protocol !== undefined){
	let data5 = data4.protocol;
	const _errs25 = errors;
	if(typeof data5 !== "string"){
	let dataType5 = typeof data5;
	let coerced5 = undefined;
	if(!(coerced5 !== undefined)){
	if(dataType5 == "number" || dataType5 == "boolean"){
	coerced5 = "" + data5;
	}
	else if(data5 === null){
	coerced5 = "";
	}
	else {
	const err12 = {instancePath:instancePath+"/path/protocol",schemaPath:"#/properties/path/oneOf/1/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err12];
	}
	else {
	vErrors.push(err12);
	}
	errors++;
	}
	}
	if(coerced5 !== undefined){
	data5 = coerced5;
	if(data4 !== undefined){
	data4["protocol"] = coerced5;
	}
	}
	}
	var valid5 = _errs25 === errors;
	}
	else {
	var valid5 = true;
	}
	if(valid5){
	if(data4.hostname !== undefined){
	let data6 = data4.hostname;
	const _errs27 = errors;
	if(typeof data6 !== "string"){
	let dataType6 = typeof data6;
	let coerced6 = undefined;
	if(!(coerced6 !== undefined)){
	if(dataType6 == "number" || dataType6 == "boolean"){
	coerced6 = "" + data6;
	}
	else if(data6 === null){
	coerced6 = "";
	}
	else {
	const err13 = {instancePath:instancePath+"/path/hostname",schemaPath:"#/properties/path/oneOf/1/properties/hostname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err13];
	}
	else {
	vErrors.push(err13);
	}
	errors++;
	}
	}
	if(coerced6 !== undefined){
	data6 = coerced6;
	if(data4 !== undefined){
	data4["hostname"] = coerced6;
	}
	}
	}
	var valid5 = _errs27 === errors;
	}
	else {
	var valid5 = true;
	}
	if(valid5){
	if(data4.pathname !== undefined){
	let data7 = data4.pathname;
	const _errs29 = errors;
	if(typeof data7 !== "string"){
	let dataType7 = typeof data7;
	let coerced7 = undefined;
	if(!(coerced7 !== undefined)){
	if(dataType7 == "number" || dataType7 == "boolean"){
	coerced7 = "" + data7;
	}
	else if(data7 === null){
	coerced7 = "";
	}
	else {
	const err14 = {instancePath:instancePath+"/path/pathname",schemaPath:"#/properties/path/oneOf/1/properties/pathname/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err14];
	}
	else {
	vErrors.push(err14);
	}
	errors++;
	}
	}
	if(coerced7 !== undefined){
	data7 = coerced7;
	if(data4 !== undefined){
	data4["pathname"] = coerced7;
	}
	}
	}
	var valid5 = _errs29 === errors;
	}
	else {
	var valid5 = true;
	}
	}
	}
	}
	}
	else {
	const err15 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf/1/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err15];
	}
	else {
	vErrors.push(err15);
	}
	errors++;
	}
	}
	var _valid2 = _errs22 === errors;
	if(_valid2 && valid4){
	valid4 = false;
	passing2 = [passing2, 1];
	}
	else {
	if(_valid2){
	valid4 = true;
	passing2 = 1;
	}
	}
	if(!valid4){
	const err16 = {instancePath:instancePath+"/path",schemaPath:"#/properties/path/oneOf",keyword:"oneOf",params:{passingSchemas: passing2},message:"must match exactly one schema in oneOf"};
	if(vErrors === null){
	vErrors = [err16];
	}
	else {
	vErrors.push(err16);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs19;
	if(vErrors !== null){
	if(_errs19){
	vErrors.length = _errs19;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs18 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.cookies !== undefined){
	let data8 = data.cookies;
	const _errs31 = errors;
	if(errors === _errs31){
	if(!(data8 && typeof data8 == "object" && !Array.isArray(data8))){
	validate10.errors = [{instancePath:instancePath+"/cookies",schemaPath:"#/properties/cookies/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs31 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.headers !== undefined){
	let data9 = data.headers;
	const _errs34 = errors;
	if(errors === _errs34){
	if(!(data9 && typeof data9 == "object" && !Array.isArray(data9))){
	validate10.errors = [{instancePath:instancePath+"/headers",schemaPath:"#/properties/headers/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs34 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.query !== undefined){
	let data10 = data.query;
	const _errs37 = errors;
	const _errs38 = errors;
	let valid6 = false;
	const _errs39 = errors;
	if(errors === _errs39){
	if(!(data10 && typeof data10 == "object" && !Array.isArray(data10))){
	const err17 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf/0/type",keyword:"type",params:{type: "object"},message:"must be object"};
	if(vErrors === null){
	vErrors = [err17];
	}
	else {
	vErrors.push(err17);
	}
	errors++;
	}
	}
	var _valid3 = _errs39 === errors;
	valid6 = valid6 || _valid3;
	if(!valid6){
	const _errs42 = errors;
	if(typeof data10 !== "string"){
	let dataType8 = typeof data10;
	let coerced8 = undefined;
	if(!(coerced8 !== undefined)){
	if(dataType8 == "number" || dataType8 == "boolean"){
	coerced8 = "" + data10;
	}
	else if(data10 === null){
	coerced8 = "";
	}
	else {
	const err18 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf/1/type",keyword:"type",params:{type: "string"},message:"must be string"};
	if(vErrors === null){
	vErrors = [err18];
	}
	else {
	vErrors.push(err18);
	}
	errors++;
	}
	}
	if(coerced8 !== undefined){
	data10 = coerced8;
	if(data !== undefined){
	data["query"] = coerced8;
	}
	}
	}
	var _valid3 = _errs42 === errors;
	valid6 = valid6 || _valid3;
	}
	if(!valid6){
	const err19 = {instancePath:instancePath+"/query",schemaPath:"#/properties/query/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
	if(vErrors === null){
	vErrors = [err19];
	}
	else {
	vErrors.push(err19);
	}
	errors++;
	validate10.errors = vErrors;
	return false;
	}
	else {
	errors = _errs38;
	if(vErrors !== null){
	if(_errs38){
	vErrors.length = _errs38;
	}
	else {
	vErrors = null;
	}
	}
	}
	var valid1 = _errs37 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.simulate !== undefined){
	let data11 = data.simulate;
	const _errs44 = errors;
	if(errors === _errs44){
	if(data11 && typeof data11 == "object" && !Array.isArray(data11)){
	if(data11.end !== undefined){
	let data12 = data11.end;
	const _errs46 = errors;
	if(typeof data12 !== "boolean"){
	let coerced9 = undefined;
	if(!(coerced9 !== undefined)){
	if(data12 === "false" || data12 === 0 || data12 === null){
	coerced9 = false;
	}
	else if(data12 === "true" || data12 === 1){
	coerced9 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/end",schemaPath:"#/properties/simulate/properties/end/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced9 !== undefined){
	data12 = coerced9;
	if(data11 !== undefined){
	data11["end"] = coerced9;
	}
	}
	}
	var valid7 = _errs46 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.split !== undefined){
	let data13 = data11.split;
	const _errs48 = errors;
	if(typeof data13 !== "boolean"){
	let coerced10 = undefined;
	if(!(coerced10 !== undefined)){
	if(data13 === "false" || data13 === 0 || data13 === null){
	coerced10 = false;
	}
	else if(data13 === "true" || data13 === 1){
	coerced10 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/split",schemaPath:"#/properties/simulate/properties/split/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced10 !== undefined){
	data13 = coerced10;
	if(data11 !== undefined){
	data11["split"] = coerced10;
	}
	}
	}
	var valid7 = _errs48 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.error !== undefined){
	let data14 = data11.error;
	const _errs50 = errors;
	if(typeof data14 !== "boolean"){
	let coerced11 = undefined;
	if(!(coerced11 !== undefined)){
	if(data14 === "false" || data14 === 0 || data14 === null){
	coerced11 = false;
	}
	else if(data14 === "true" || data14 === 1){
	coerced11 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/error",schemaPath:"#/properties/simulate/properties/error/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced11 !== undefined){
	data14 = coerced11;
	if(data11 !== undefined){
	data11["error"] = coerced11;
	}
	}
	}
	var valid7 = _errs50 === errors;
	}
	else {
	var valid7 = true;
	}
	if(valid7){
	if(data11.close !== undefined){
	let data15 = data11.close;
	const _errs52 = errors;
	if(typeof data15 !== "boolean"){
	let coerced12 = undefined;
	if(!(coerced12 !== undefined)){
	if(data15 === "false" || data15 === 0 || data15 === null){
	coerced12 = false;
	}
	else if(data15 === "true" || data15 === 1){
	coerced12 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate/close",schemaPath:"#/properties/simulate/properties/close/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced12 !== undefined){
	data15 = coerced12;
	if(data11 !== undefined){
	data11["close"] = coerced12;
	}
	}
	}
	var valid7 = _errs52 === errors;
	}
	else {
	var valid7 = true;
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/simulate",schemaPath:"#/properties/simulate/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	var valid1 = _errs44 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.authority !== undefined){
	let data16 = data.authority;
	const _errs54 = errors;
	if(typeof data16 !== "string"){
	let dataType13 = typeof data16;
	let coerced13 = undefined;
	if(!(coerced13 !== undefined)){
	if(dataType13 == "number" || dataType13 == "boolean"){
	coerced13 = "" + data16;
	}
	else if(data16 === null){
	coerced13 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/authority",schemaPath:"#/properties/authority/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced13 !== undefined){
	data16 = coerced13;
	if(data !== undefined){
	data["authority"] = coerced13;
	}
	}
	}
	var valid1 = _errs54 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.remoteAddress !== undefined){
	let data17 = data.remoteAddress;
	const _errs56 = errors;
	if(typeof data17 !== "string"){
	let dataType14 = typeof data17;
	let coerced14 = undefined;
	if(!(coerced14 !== undefined)){
	if(dataType14 == "number" || dataType14 == "boolean"){
	coerced14 = "" + data17;
	}
	else if(data17 === null){
	coerced14 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/remoteAddress",schemaPath:"#/properties/remoteAddress/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced14 !== undefined){
	data17 = coerced14;
	if(data !== undefined){
	data["remoteAddress"] = coerced14;
	}
	}
	}
	var valid1 = _errs56 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.method !== undefined){
	let data18 = data.method;
	const _errs58 = errors;
	if(typeof data18 !== "string"){
	let dataType15 = typeof data18;
	let coerced15 = undefined;
	if(!(coerced15 !== undefined)){
	if(dataType15 == "number" || dataType15 == "boolean"){
	coerced15 = "" + data18;
	}
	else if(data18 === null){
	coerced15 = "";
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/method",schemaPath:"#/properties/method/type",keyword:"type",params:{type: "string"},message:"must be string"}];
	return false;
	}
	}
	if(coerced15 !== undefined){
	data18 = coerced15;
	if(data !== undefined){
	data["method"] = coerced15;
	}
	}
	}
	if(!((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((data18 === "ACL") || (data18 === "BIND")) || (data18 === "CHECKOUT")) || (data18 === "CONNECT")) || (data18 === "COPY")) || (data18 === "DELETE")) || (data18 === "GET")) || (data18 === "HEAD")) || (data18 === "LINK")) || (data18 === "LOCK")) || (data18 === "M-SEARCH")) || (data18 === "MERGE")) || (data18 === "MKACTIVITY")) || (data18 === "MKCALENDAR")) || (data18 === "MKCOL")) || (data18 === "MOVE")) || (data18 === "NOTIFY")) || (data18 === "OPTIONS")) || (data18 === "PATCH")) || (data18 === "POST")) || (data18 === "PROPFIND")) || (data18 === "PROPPATCH")) || (data18 === "PURGE")) || (data18 === "PUT")) || (data18 === "QUERY")) || (data18 === "REBIND")) || (data18 === "REPORT")) || (data18 === "SEARCH")) || (data18 === "SOURCE")) || (data18 === "SUBSCRIBE")) || (data18 === "TRACE")) || (data18 === "UNBIND")) || (data18 === "UNLINK")) || (data18 === "UNLOCK")) || (data18 === "UNSUBSCRIBE")) || (data18 === "acl")) || (data18 === "bind")) || (data18 === "checkout")) || (data18 === "connect")) || (data18 === "copy")) || (data18 === "delete")) || (data18 === "get")) || (data18 === "head")) || (data18 === "link")) || (data18 === "lock")) || (data18 === "m-search")) || (data18 === "merge")) || (data18 === "mkactivity")) || (data18 === "mkcalendar")) || (data18 === "mkcol")) || (data18 === "move")) || (data18 === "notify")) || (data18 === "options")) || (data18 === "patch")) || (data18 === "post")) || (data18 === "propfind")) || (data18 === "proppatch")) || (data18 === "purge")) || (data18 === "put")) || (data18 === "query")) || (data18 === "rebind")) || (data18 === "report")) || (data18 === "search")) || (data18 === "source")) || (data18 === "subscribe")) || (data18 === "trace")) || (data18 === "unbind")) || (data18 === "unlink")) || (data18 === "unlock")) || (data18 === "unsubscribe"))){
	validate10.errors = [{instancePath:instancePath+"/method",schemaPath:"#/properties/method/enum",keyword:"enum",params:{allowedValues: schema11.properties.method.enum},message:"must be equal to one of the allowed values"}];
	return false;
	}
	var valid1 = _errs58 === errors;
	}
	else {
	var valid1 = true;
	}
	if(valid1){
	if(data.validate !== undefined){
	let data19 = data.validate;
	const _errs60 = errors;
	if(typeof data19 !== "boolean"){
	let coerced16 = undefined;
	if(!(coerced16 !== undefined)){
	if(data19 === "false" || data19 === 0 || data19 === null){
	coerced16 = false;
	}
	else if(data19 === "true" || data19 === 1){
	coerced16 = true;
	}
	else {
	validate10.errors = [{instancePath:instancePath+"/validate",schemaPath:"#/properties/validate/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];
	return false;
	}
	}
	if(coerced16 !== undefined){
	data19 = coerced16;
	if(data !== undefined){
	data["validate"] = coerced16;
	}
	}
	}
	var valid1 = _errs60 === errors;
	}
	else {
	var valid1 = true;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	else {
	validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];
	return false;
	}
	}
	validate10.errors = vErrors;
	return errors === 0;
	}
	return configValidator.exports;
}

var hasRequiredLightMyRequest;

function requireLightMyRequest () {
	if (hasRequiredLightMyRequest) return lightMyRequest.exports;
	hasRequiredLightMyRequest = 1;

	const assert = require$$0$b;
	const Request = requireRequest();
	const Response = requireResponse();

	const errorMessage = 'The dispatch function has already been invoked';

	const optsValidator = requireConfigValidator();

	function inject (dispatchFunc, options, callback) {
	  if (callback === undefined) {
	    return new Chain(dispatchFunc, options)
	  } else {
	    return doInject(dispatchFunc, options, callback)
	  }
	}

	function supportStream1 (req, next) {
	  const payload = req._lightMyRequest.payload;
	  if (!payload || payload._readableState || typeof payload.resume !== 'function') { // does quack like a modern stream
	    return next()
	  }

	  // This is a non-compliant stream
	  const chunks = [];

	  // We are accumulating because Readable.wrap() does not really work as expected
	  // in this case.
	  payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)));

	  payload.on('end', () => {
	    const payload = Buffer.concat(chunks);
	    req.headers['content-length'] = req.headers['content-length'] || ('' + payload.length);
	    delete req.headers['transfer-encoding'];
	    req._lightMyRequest.payload = payload;
	    return next()
	  });

	  // Force to resume the stream. Needed for Stream 1
	  payload.resume();
	}

	function makeRequest (dispatchFunc, server, req, res) {
	  req.once('error', function (err) {
	    if (this.destroyed) res.destroy(err);
	  });

	  req.once('close', function () {
	    if (this.destroyed && !this._error) {
	      res.destroy();
	    }
	  });

	  return supportStream1(req, () => dispatchFunc.call(server, req, res))
	}

	function doInject (dispatchFunc, options, callback) {
	  options = (typeof options === 'string' ? { url: options } : options);

	  if (options.validate !== false) {
	    assert(typeof dispatchFunc === 'function', 'dispatchFunc should be a function');
	    const isOptionValid = optsValidator(options);
	    if (!isOptionValid) {
	      throw new Error(optsValidator.errors.map(e => e.message))
	    }
	  }

	  const server = options.server || {};

	  const RequestConstructor = options.Request
	    ? Request.CustomRequest
	    : Request;

	  // Express.js detection
	  if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
	    Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
	    Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response.prototype);
	  }

	  if (typeof callback === 'function') {
	    const req = new RequestConstructor(options);
	    const res = new Response(req, callback);

	    return makeRequest(dispatchFunc, server, req, res)
	  } else {
	    return new Promise((resolve, reject) => {
	      const req = new RequestConstructor(options);
	      const res = new Response(req, resolve, reject);

	      makeRequest(dispatchFunc, server, req, res);
	    })
	  }
	}

	function Chain (dispatch, option) {
	  if (typeof option === 'string') {
	    this.option = { url: option };
	  } else {
	    this.option = Object.assign({}, option);
	  }

	  this.dispatch = dispatch;
	  this._hasInvoked = false;
	  this._promise = null;

	  if (this.option.autoStart !== false) {
	    process.nextTick(() => {
	      if (!this._hasInvoked) {
	        this.end();
	      }
	    });
	  }
	}

	const httpMethods = [
	  'delete',
	  'get',
	  'head',
	  'options',
	  'patch',
	  'post',
	  'put',
	  'trace'
	];

	httpMethods.forEach(method => {
	  Chain.prototype[method] = function (url) {
	    if (this._hasInvoked === true || this._promise) {
	      throw new Error(errorMessage)
	    }
	    this.option.url = url;
	    this.option.method = method.toUpperCase();
	    return this
	  };
	});

	const chainMethods = [
	  'body',
	  'cookies',
	  'headers',
	  'payload',
	  'query'
	];

	chainMethods.forEach(method => {
	  Chain.prototype[method] = function (value) {
	    if (this._hasInvoked === true || this._promise) {
	      throw new Error(errorMessage)
	    }
	    this.option[method] = value;
	    return this
	  };
	});

	Chain.prototype.end = function (callback) {
	  if (this._hasInvoked === true || this._promise) {
	    throw new Error(errorMessage)
	  }
	  this._hasInvoked = true;
	  if (typeof callback === 'function') {
	    doInject(this.dispatch, this.option, callback);
	  } else {
	    this._promise = doInject(this.dispatch, this.option);
	    return this._promise
	  }
	};

	Object.getOwnPropertyNames(Promise.prototype).forEach(method => {
	  if (method === 'constructor') return
	  Chain.prototype[method] = function (...args) {
	    if (!this._promise) {
	      if (this._hasInvoked === true) {
	        throw new Error(errorMessage)
	      }
	      this._hasInvoked = true;
	      this._promise = doInject(this.dispatch, this.option);
	    }
	    return this._promise[method](...args)
	  };
	});

	function isInjection (obj) {
	  return (
	    obj instanceof Request ||
	    obj instanceof Response ||
	    obj?.constructor?.name === '_CustomLMRRequest'
	  )
	}

	lightMyRequest.exports = inject;
	lightMyRequest.exports.default = inject;
	lightMyRequest.exports.inject = inject;
	lightMyRequest.exports.isInjection = isInjection;
	return lightMyRequest.exports;
}

var hasRequiredFastify;

function requireFastify () {
	if (hasRequiredFastify) return fastify.exports;
	hasRequiredFastify = 1;

	const VERSION = '5.4.0';

	const Avvio = requireBoot();
	const http = require$$0$5;
	const diagnostics = require$$1$2;
	let lightMyRequest;

	const {
	  kAvvioBoot,
	  kChildren,
	  kServerBindings,
	  kBodyLimit,
	  kSupportedHTTPMethods,
	  kRoutePrefix,
	  kLogLevel,
	  kLogSerializers,
	  kHooks,
	  kSchemaController,
	  kRequestAcceptVersion,
	  kReplySerializerDefault,
	  kContentTypeParser,
	  kReply,
	  kRequest,
	  kFourOhFour,
	  kState,
	  kOptions,
	  kPluginNameChain,
	  kSchemaErrorFormatter,
	  kErrorHandler,
	  kKeepAliveConnections,
	  kChildLoggerFactory,
	  kGenReqId,
	  kErrorHandlerAlreadySet
	} = requireSymbols$2();

	const { createServer } = requireServer();
	const Reply = requireReply();
	const Request = requireRequest$1();
	const Context = requireContext();
	const decorator = requireDecorate();
	const ContentTypeParser = requireContentTypeParser();
	const SchemaController = requireSchemaController();
	const { Hooks, hookRunnerApplication, supportedHooks } = requireHooks();
	const { createChildLogger, defaultChildLoggerFactory, createLogger } = requireLoggerFactory();
	const pluginUtils = requirePluginUtils();
	const { getGenReqId, reqIdGenFactory } = requireReqIdGenFactory();
	const { buildRouting, validateBodyLimitOption } = requireRoute();
	const build404 = requireFourOhFour();
	const getSecuredInitialConfig = requireInitialConfigValidation();
	const override = requirePluginOverride();
	const noopSet = requireNoopSet();
	const {
	  appendStackTrace,
	  AVVIO_ERRORS_MAP,
	  ...errorCodes
	} = requireErrors$2();

	const { defaultInitOptions } = getSecuredInitialConfig;

	const {
	  FST_ERR_ASYNC_CONSTRAINT,
	  FST_ERR_BAD_URL,
	  FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
	  FST_ERR_OPTIONS_NOT_OBJ,
	  FST_ERR_QSP_NOT_FN,
	  FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
	  FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
	  FST_ERR_INSTANCE_ALREADY_LISTENING,
	  FST_ERR_REOPENED_CLOSE_SERVER,
	  FST_ERR_ROUTE_REWRITE_NOT_STR,
	  FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
	  FST_ERR_ERROR_HANDLER_NOT_FN,
	  FST_ERR_ERROR_HANDLER_ALREADY_SET,
	  FST_ERR_ROUTE_METHOD_INVALID
	} = errorCodes;

	const { buildErrorHandler } = requireErrorHandler();
	const { FSTWRN004 } = requireWarnings();

	const initChannel = diagnostics.channel('fastify.initialization');

	function defaultBuildPrettyMeta (route) {
	  // return a shallow copy of route's sanitized context

	  const cleanKeys = {};
	  const allowedProps = ['errorHandler', 'logLevel', 'logSerializers'];

	  allowedProps.concat(supportedHooks).forEach(k => {
	    cleanKeys[k] = route.store[k];
	  });

	  return Object.assign({}, cleanKeys)
	}

	/**
	 * @param {import('./fastify.js').FastifyServerOptions} options
	 */
	function fastify$1 (options) {
	  // Options validations
	  if (options && typeof options !== 'object') {
	    throw new FST_ERR_OPTIONS_NOT_OBJ()
	  } else {
	    // Shallow copy options object to prevent mutations outside of this function
	    options = Object.assign({}, options);
	  }

	  if (options.querystringParser && typeof options.querystringParser !== 'function') {
	    throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser)
	  }

	  if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== 'function') {
	    throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket)
	  }

	  validateBodyLimitOption(options.bodyLimit);

	  const requestIdHeader = typeof options.requestIdHeader === 'string' && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : (options.requestIdHeader === true && 'request-id');
	  const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
	  const requestIdLogLabel = options.requestIdLogLabel || 'reqId';
	  const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
	  const disableRequestLogging = options.disableRequestLogging || false;

	  const ajvOptions = Object.assign({
	    customOptions: {},
	    plugins: []
	  }, options.ajv);
	  const frameworkErrors = options.frameworkErrors;

	  // Ajv options
	  if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== '[object Object]') {
	    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions)
	  }
	  if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
	    throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins)
	  }

	  // Instance Fastify components

	  const { logger, hasLogger } = createLogger(options);

	  // Update the options with the fixed values
	  options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
	  options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
	  options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
	  options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
	  options.logger = logger;
	  options.requestIdHeader = requestIdHeader;
	  options.requestIdLogLabel = requestIdLogLabel;
	  options.disableRequestLogging = disableRequestLogging;
	  options.ajv = ajvOptions;
	  options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
	  options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;

	  const initialConfig = getSecuredInitialConfig(options);

	  // exposeHeadRoutes have its default set from the validator
	  options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;

	  // Default router
	  const router = buildRouting({
	    config: {
	      defaultRoute,
	      onBadUrl,
	      constraints: options.constraints,
	      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
	      ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
	      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
	      caseSensitive: options.caseSensitive,
	      allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
	      buildPrettyMeta: defaultBuildPrettyMeta,
	      querystringParser: options.querystringParser,
	      useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
	    }
	  });

	  // 404 router, used for handling encapsulated 404 handlers
	  const fourOhFour = build404(options);

	  // HTTP server and its handler
	  const httpHandler = wrapRouting(router, options);

	  // we need to set this before calling createServer
	  options.http2SessionTimeout = initialConfig.http2SessionTimeout;
	  const { server, listen } = createServer(options, httpHandler);

	  const serverHasCloseAllConnections = typeof server.closeAllConnections === 'function';
	  const serverHasCloseIdleConnections = typeof server.closeIdleConnections === 'function';

	  let forceCloseConnections = options.forceCloseConnections;
	  if (forceCloseConnections === 'idle' && !serverHasCloseIdleConnections) {
	    throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE()
	  } else if (typeof forceCloseConnections !== 'boolean') {
	    /* istanbul ignore next: only one branch can be valid in a given Node.js version */
	    forceCloseConnections = serverHasCloseIdleConnections ? 'idle' : false;
	  }

	  const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? new Set() : noopSet();

	  const setupResponseListeners = Reply.setupResponseListeners;
	  const schemaController = SchemaController.buildSchemaController(null, options.schemaController);

	  // Public API
	  const fastify = {
	    // Fastify internals
	    [kState]: {
	      listening: false,
	      closing: false,
	      started: false,
	      ready: false,
	      booting: false,
	      readyPromise: null
	    },
	    [kKeepAliveConnections]: keepAliveConnections,
	    [kSupportedHTTPMethods]: {
	      bodyless: new Set([
	        // Standard
	        'GET',
	        'HEAD',
	        'TRACE'
	      ]),
	      bodywith: new Set([
	        // Standard
	        'DELETE',
	        'OPTIONS',
	        'PATCH',
	        'PUT',
	        'POST'
	      ])
	    },
	    [kOptions]: options,
	    [kChildren]: [],
	    [kServerBindings]: [],
	    [kBodyLimit]: bodyLimit,
	    [kRoutePrefix]: '',
	    [kLogLevel]: '',
	    [kLogSerializers]: null,
	    [kHooks]: new Hooks(),
	    [kSchemaController]: schemaController,
	    [kSchemaErrorFormatter]: null,
	    [kErrorHandler]: buildErrorHandler(),
	    [kErrorHandlerAlreadySet]: false,
	    [kChildLoggerFactory]: defaultChildLoggerFactory,
	    [kReplySerializerDefault]: null,
	    [kContentTypeParser]: new ContentTypeParser(
	      bodyLimit,
	      (options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning),
	      (options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning)
	    ),
	    [kReply]: Reply.buildReply(Reply),
	    [kRequest]: Request.buildRequest(Request, options.trustProxy),
	    [kFourOhFour]: fourOhFour,
	    [pluginUtils.kRegisteredPlugins]: [],
	    [kPluginNameChain]: ['fastify'],
	    [kAvvioBoot]: null,
	    [kGenReqId]: genReqId,
	    // routing method
	    routing: httpHandler,
	    // routes shorthand methods
	    delete: function _delete (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'DELETE', url, options, handler })
	    },
	    get: function _get (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'GET', url, options, handler })
	    },
	    head: function _head (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'HEAD', url, options, handler })
	    },
	    trace: function _trace (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'TRACE', url, options, handler })
	    },
	    patch: function _patch (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'PATCH', url, options, handler })
	    },
	    post: function _post (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'POST', url, options, handler })
	    },
	    put: function _put (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'PUT', url, options, handler })
	    },
	    options: function _options (url, options, handler) {
	      return router.prepareRoute.call(this, { method: 'OPTIONS', url, options, handler })
	    },
	    all: function _all (url, options, handler) {
	      return router.prepareRoute.call(this, { method: this.supportedMethods, url, options, handler })
	    },
	    // extended route
	    route: function _route (options) {
	      // we need the fastify object that we are producing so we apply a lazy loading of the function,
	      // otherwise we should bind it after the declaration
	      return router.route.call(this, { options })
	    },
	    hasRoute: function _route (options) {
	      return router.hasRoute.call(this, { options })
	    },
	    findRoute: function _findRoute (options) {
	      return router.findRoute(options)
	    },
	    // expose logger instance
	    log: logger,
	    // type provider
	    withTypeProvider,
	    // hooks
	    addHook,
	    // schemas
	    addSchema,
	    getSchema: schemaController.getSchema.bind(schemaController),
	    getSchemas: schemaController.getSchemas.bind(schemaController),
	    setValidatorCompiler,
	    setSerializerCompiler,
	    setSchemaController,
	    setReplySerializer,
	    setSchemaErrorFormatter,
	    // set generated request id
	    setGenReqId,
	    // custom parsers
	    addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
	    hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
	    getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
	    defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
	    removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
	    removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
	    // Fastify architecture methods (initialized by Avvio)
	    register: null,
	    after: null,
	    ready: null,
	    onClose: null,
	    close: null,
	    printPlugins: null,
	    hasPlugin: function (name) {
	      return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name)
	    },
	    // http server
	    listen,
	    server,
	    addresses: function () {
	      /* istanbul ignore next */
	      const binded = this[kServerBindings].map(b => b.address());
	      binded.push(this.server.address());
	      return binded.filter(adr => adr)
	    },
	    // extend fastify objects
	    decorate: decorator.add,
	    hasDecorator: decorator.exist,
	    decorateReply: decorator.decorateReply,
	    decorateRequest: decorator.decorateRequest,
	    hasRequestDecorator: decorator.existRequest,
	    hasReplyDecorator: decorator.existReply,
	    getDecorator: decorator.getInstanceDecorator,
	    addHttpMethod,
	    // fake http injection
	    inject,
	    // pretty print of the registered routes
	    printRoutes,
	    // custom error handling
	    setNotFoundHandler,
	    setErrorHandler,
	    // child logger
	    setChildLoggerFactory,
	    // Set fastify initial configuration options read-only object
	    initialConfig,
	    // constraint strategies
	    addConstraintStrategy: router.addConstraintStrategy.bind(router),
	    hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
	  };

	  Object.defineProperties(fastify, {
	    listeningOrigin: {
	      get () {
	        const address = this.addresses().slice(-1).pop();
	        /* ignore if windows: unix socket is not testable on Windows platform */
	        /* c8 ignore next 3 */
	        if (typeof address === 'string') {
	          return address
	        }
	        const host = address.family === 'IPv6' ? `[${address.address}]` : address.address;
	        return `${this[kOptions].https ? 'https' : 'http'}://${host}:${address.port}`
	      }
	    },
	    pluginName: {
	      configurable: true,
	      get () {
	        if (this[kPluginNameChain].length > 1) {
	          return this[kPluginNameChain].join(' -> ')
	        }
	        return this[kPluginNameChain][0]
	      }
	    },
	    prefix: {
	      configurable: true,
	      get () { return this[kRoutePrefix] }
	    },
	    validatorCompiler: {
	      configurable: true,
	      get () { return this[kSchemaController].getValidatorCompiler() }
	    },
	    serializerCompiler: {
	      configurable: true,
	      get () { return this[kSchemaController].getSerializerCompiler() }
	    },
	    childLoggerFactory: {
	      configurable: true,
	      get () { return this[kChildLoggerFactory] }
	    },
	    version: {
	      configurable: true,
	      get () { return VERSION }
	    },
	    errorHandler: {
	      configurable: true,
	      get () {
	        return this[kErrorHandler].func
	      }
	    },
	    genReqId: {
	      configurable: true,
	      get () { return this[kGenReqId] }
	    },
	    supportedMethods: {
	      configurable: false,
	      get () {
	        return [
	          ...this[kSupportedHTTPMethods].bodyless,
	          ...this[kSupportedHTTPMethods].bodywith
	        ]
	      }
	    }
	  });

	  if (options.schemaErrorFormatter) {
	    validateSchemaErrorFormatter(options.schemaErrorFormatter);
	    fastify[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify);
	  }

	  // Install and configure Avvio
	  // Avvio will update the following Fastify methods:
	  // - register
	  // - after
	  // - ready
	  // - onClose
	  // - close

	  const avvioPluginTimeout = Number(options.pluginTimeout);
	  const avvio = Avvio(fastify, {
	    autostart: false,
	    timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
	    expose: {
	      use: 'register'
	    }
	  });
	  // Override to allow the plugin encapsulation
	  avvio.override = override;
	  avvio.on('start', () => (fastify[kState].started = true));
	  fastify[kAvvioBoot] = fastify.ready; // the avvio ready function
	  fastify.ready = ready; // overwrite the avvio ready function
	  fastify.printPlugins = avvio.prettyPrint.bind(avvio);

	  // cache the closing value, since we are checking it in an hot path
	  avvio.once('preReady', () => {
	    fastify.onClose((instance, done) => {
	      fastify[kState].closing = true;
	      router.closeRoutes();

	      hookRunnerApplication('preClose', fastify[kAvvioBoot], fastify, function () {
	        if (fastify[kState].listening) {
	          /* istanbul ignore next: Cannot test this without Node.js core support */
	          if (forceCloseConnections === 'idle') {
	            // Not needed in Node 19
	            instance.server.closeIdleConnections();
	            /* istanbul ignore next: Cannot test this without Node.js core support */
	          } else if (serverHasCloseAllConnections && forceCloseConnections) {
	            instance.server.closeAllConnections();
	          } else if (forceCloseConnections === true) {
	            for (const conn of fastify[kKeepAliveConnections]) {
	              // We must invoke the destroy method instead of merely unreffing
	              // the sockets. If we only unref, then the callback passed to
	              // `fastify.close` will never be invoked; nor will any of the
	              // registered `onClose` hooks.
	              conn.destroy();
	              fastify[kKeepAliveConnections].delete(conn);
	            }
	          }
	        }

	        // No new TCP connections are accepted.
	        // We must call close on the server even if we are not listening
	        // otherwise memory will be leaked.
	        // https://github.com/nodejs/node/issues/48604
	        if (!options.serverFactory || fastify[kState].listening) {
	          instance.server.close(function (err) {
	            /* c8 ignore next 6 */
	            if (err && err.code !== 'ERR_SERVER_NOT_RUNNING') {
	              done(null);
	            } else {
	              done();
	            }
	          });
	        } else {
	          process.nextTick(done, null);
	        }
	      });
	    });
	  });

	  // Create bad URL context
	  const onBadUrlContext = new Context({
	    server: fastify,
	    config: {}
	  });

	  // Set the default 404 handler
	  fastify.setNotFoundHandler();
	  fourOhFour.arrange404(fastify);

	  router.setup(options, {
	    avvio,
	    fourOhFour,
	    logger,
	    hasLogger,
	    setupResponseListeners,
	    throwIfAlreadyStarted,
	    keepAliveConnections
	  });

	  // Delay configuring clientError handler so that it can access fastify state.
	  server.on('clientError', options.clientErrorHandler.bind(fastify));

	  if (initChannel.hasSubscribers) {
	    initChannel.publish({ fastify });
	  }

	  // Older nodejs versions may not have asyncDispose
	  if ('asyncDispose' in Symbol) {
	    fastify[Symbol.asyncDispose] = function dispose () {
	      return fastify.close()
	    };
	  }

	  return fastify

	  function throwIfAlreadyStarted (msg) {
	    if (fastify[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg)
	  }

	  // HTTP injection handling
	  // If the server is not ready yet, this
	  // utility will automatically force it.
	  function inject (opts, cb) {
	    // lightMyRequest is dynamically loaded as it seems very expensive
	    // because of Ajv
	    if (lightMyRequest === undefined) {
	      lightMyRequest = requireLightMyRequest();
	    }

	    if (fastify[kState].started) {
	      if (fastify[kState].closing) {
	        // Force to return an error
	        const error = new FST_ERR_REOPENED_CLOSE_SERVER();
	        if (cb) {
	          cb(error);
	          return
	        } else {
	          return Promise.reject(error)
	        }
	      }
	      return lightMyRequest(httpHandler, opts, cb)
	    }

	    if (cb) {
	      this.ready(err => {
	        if (err) cb(err, null);
	        else lightMyRequest(httpHandler, opts, cb);
	      });
	    } else {
	      return lightMyRequest((req, res) => {
	        this.ready(function (err) {
	          if (err) {
	            res.emit('error', err);
	            return
	          }
	          httpHandler(req, res);
	        });
	      }, opts)
	    }
	  }

	  function ready (cb) {
	    if (this[kState].readyPromise !== null) {
	      if (cb != null) {
	        this[kState].readyPromise.then(() => cb(null, fastify), cb);
	        return
	      }

	      return this[kState].readyPromise
	    }

	    let resolveReady;
	    let rejectReady;

	    // run the hooks after returning the promise
	    process.nextTick(runHooks);

	    // Create a promise no matter what
	    // It will work as a barrier for all the .ready() calls (ensuring single hook execution)
	    // as well as a flow control mechanism to chain cbs and further
	    // promises
	    this[kState].readyPromise = new Promise(function (resolve, reject) {
	      resolveReady = resolve;
	      rejectReady = reject;
	    });

	    if (!cb) {
	      return this[kState].readyPromise
	    } else {
	      this[kState].readyPromise.then(() => cb(null, fastify), cb);
	    }

	    function runHooks () {
	      // start loading
	      fastify[kAvvioBoot]((err, done) => {
	        if (err || fastify[kState].started || fastify[kState].ready || fastify[kState].booting) {
	          manageErr(err);
	        } else {
	          fastify[kState].booting = true;
	          hookRunnerApplication('onReady', fastify[kAvvioBoot], fastify, manageErr);
	        }
	        done();
	      });
	    }

	    function manageErr (err) {
	      // If the error comes out of Avvio's Error codes
	      // We create a make and preserve the previous error
	      // as cause
	      err = err != null && AVVIO_ERRORS_MAP[err.code] != null
	        ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))
	        : err;

	      if (err) {
	        return rejectReady(err)
	      }

	      resolveReady(fastify);
	      fastify[kState].booting = false;
	      fastify[kState].ready = true;
	      fastify[kState].readyPromise = null;
	    }
	  }

	  // Used exclusively in TypeScript contexts to enable auto type inference from JSON schema.
	  function withTypeProvider () {
	    return this
	  }

	  // wrapper that we expose to the user for hooks handling
	  function addHook (name, fn) {
	    throwIfAlreadyStarted('Cannot call "addHook"!');

	    if (fn == null) {
	      throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn)
	    }

	    if (name === 'onSend' || name === 'preSerialization' || name === 'onError' || name === 'preParsing') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else if (name === 'onReady' || name === 'onListen') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length !== 0) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else if (name === 'onRequestAbort') {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length !== 1) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    } else {
	      if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
	        throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER()
	      }
	    }

	    if (name === 'onClose') {
	      this.onClose(fn.bind(this));
	    } else if (name === 'onReady' || name === 'onListen' || name === 'onRoute') {
	      this[kHooks].add(name, fn);
	    } else {
	      this.after((err, done) => {
	        try {
	          _addHook.call(this, name, fn);
	          done(err);
	        } catch (err) {
	          done(err);
	        }
	      });
	    }
	    return this

	    function _addHook (name, fn) {
	      this[kHooks].add(name, fn);
	      this[kChildren].forEach(child => _addHook.call(child, name, fn));
	    }
	  }

	  // wrapper that we expose to the user for schemas handling
	  function addSchema (schema) {
	    throwIfAlreadyStarted('Cannot call "addSchema"!');
	    this[kSchemaController].add(schema);
	    this[kChildren].forEach(child => child.addSchema(schema));
	    return this
	  }

	  function defaultClientErrorHandler (err, socket) {
	    // In case of a connection reset, the socket has been destroyed and there is nothing that needs to be done.
	    // https://nodejs.org/api/http.html#http_event_clienterror
	    if (err.code === 'ECONNRESET' || socket.destroyed) {
	      return
	    }

	    let body, errorCode, errorStatus, errorLabel;

	    if (err.code === 'ERR_HTTP_REQUEST_TIMEOUT') {
	      errorCode = '408';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
	      errorLabel = 'timeout';
	    } else if (err.code === 'HPE_HEADER_OVERFLOW') {
	      errorCode = '431';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
	      errorLabel = 'header_overflow';
	    } else {
	      errorCode = '400';
	      errorStatus = http.STATUS_CODES[errorCode];
	      body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
	      errorLabel = 'error';
	    }

	    // Most devs do not know what to do with this error.
	    // In the vast majority of cases, it's a network error and/or some
	    // config issue on the load balancer side.
	    this.log.trace({ err }, `client ${errorLabel}`);
	    // Copying standard node behavior
	    // https://github.com/nodejs/node/blob/6ca23d7846cb47e84fd344543e394e50938540be/lib/_http_server.js#L666

	    // If the socket is not writable, there is no reason to try to send data.
	    if (socket.writable) {
	      socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r\nContent-Length: ${body.length}\r\nContent-Type: application/json\r\n\r\n${body}`);
	    }
	    socket.destroy(err);
	  }

	  // If the router does not match any route, every request will land here
	  // req and res are Node.js core objects
	  function defaultRoute (req, res) {
	    if (req.headers['accept-version'] !== undefined) {
	      // we remove the accept-version header for performance result
	      // because we do not want to go through the constraint checking
	      // the usage of symbol here to prevent any collision on custom header name
	      req.headers[kRequestAcceptVersion] = req.headers['accept-version'];
	      req.headers['accept-version'] = undefined;
	    }
	    fourOhFour.router.lookup(req, res);
	  }

	  function onBadUrl (path, req, res) {
	    if (frameworkErrors) {
	      const id = getGenReqId(onBadUrlContext.server, req);
	      const childLogger = createChildLogger(onBadUrlContext, logger, req, id);

	      const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
	      const reply = new Reply(res, request, childLogger);

	      if (disableRequestLogging === false) {
	        childLogger.info({ req: request }, 'incoming request');
	      }

	      return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply)
	    }
	    const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
	    res.writeHead(400, {
	      'Content-Type': 'application/json',
	      'Content-Length': body.length
	    });
	    res.end(body);
	  }

	  function buildAsyncConstraintCallback (isAsync, req, res) {
	    if (isAsync === false) return undefined
	    return function onAsyncConstraintError (err) {
	      if (err) {
	        if (frameworkErrors) {
	          const id = getGenReqId(onBadUrlContext.server, req);
	          const childLogger = createChildLogger(onBadUrlContext, logger, req, id);

	          const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
	          const reply = new Reply(res, request, childLogger);

	          if (disableRequestLogging === false) {
	            childLogger.info({ req: request }, 'incoming request');
	          }

	          return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request, reply)
	        }
	        const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
	        res.writeHead(500, {
	          'Content-Type': 'application/json',
	          'Content-Length': body.length
	        });
	        res.end(body);
	      }
	    }
	  }

	  function setNotFoundHandler (opts, handler) {
	    throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');

	    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
	    return this
	  }

	  function setValidatorCompiler (validatorCompiler) {
	    throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
	    this[kSchemaController].setValidatorCompiler(validatorCompiler);
	    return this
	  }

	  function setSchemaErrorFormatter (errorFormatter) {
	    throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
	    validateSchemaErrorFormatter(errorFormatter);
	    this[kSchemaErrorFormatter] = errorFormatter.bind(this);
	    return this
	  }

	  function setSerializerCompiler (serializerCompiler) {
	    throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
	    this[kSchemaController].setSerializerCompiler(serializerCompiler);
	    return this
	  }

	  function setSchemaController (schemaControllerOpts) {
	    throwIfAlreadyStarted('Cannot call "setSchemaController"!');
	    const old = this[kSchemaController];
	    const schemaController = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
	    this[kSchemaController] = schemaController;
	    this.getSchema = schemaController.getSchema.bind(schemaController);
	    this.getSchemas = schemaController.getSchemas.bind(schemaController);
	    return this
	  }

	  function setReplySerializer (replySerializer) {
	    throwIfAlreadyStarted('Cannot call "setReplySerializer"!');

	    this[kReplySerializerDefault] = replySerializer;
	    return this
	  }

	  // wrapper that we expose to the user for configure the custom error handler
	  function setErrorHandler (func) {
	    throwIfAlreadyStarted('Cannot call "setErrorHandler"!');

	    if (typeof func !== 'function') {
	      throw new FST_ERR_ERROR_HANDLER_NOT_FN()
	    }

	    if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
	      throw new FST_ERR_ERROR_HANDLER_ALREADY_SET()
	    } else if (this[kErrorHandlerAlreadySet]) {
	      FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
	    }

	    this[kErrorHandlerAlreadySet] = true;
	    this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
	    return this
	  }

	  function setChildLoggerFactory (factory) {
	    throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');

	    this[kChildLoggerFactory] = factory;
	    return this
	  }

	  function printRoutes (opts = {}) {
	    // includeHooks:true - shortcut to include all supported hooks exported by fastify.Hooks
	    opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
	    return router.printRoutes(opts)
	  }

	  function wrapRouting (router, { rewriteUrl, logger }) {
	    let isAsync;
	    return function preRouting (req, res) {
	      // only call isAsyncConstraint once
	      if (isAsync === undefined) isAsync = router.isAsyncConstraint();
	      if (rewriteUrl) {
	        req.originalUrl = req.url;
	        const url = rewriteUrl.call(fastify, req);
	        if (typeof url === 'string') {
	          req.url = url;
	        } else {
	          const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
	          req.destroy(err);
	        }
	      }
	      router.routing(req, res, buildAsyncConstraintCallback(isAsync, req, res));
	    }
	  }

	  function setGenReqId (func) {
	    throwIfAlreadyStarted('Cannot call "setGenReqId"!');

	    this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
	    return this
	  }

	  function addHttpMethod (method, { hasBody = false } = {}) {
	    if (typeof method !== 'string' || http.METHODS.indexOf(method) === -1) {
	      throw new FST_ERR_ROUTE_METHOD_INVALID()
	    }

	    if (hasBody === true) {
	      this[kSupportedHTTPMethods].bodywith.add(method);
	      this[kSupportedHTTPMethods].bodyless.delete(method);
	    } else {
	      this[kSupportedHTTPMethods].bodywith.delete(method);
	      this[kSupportedHTTPMethods].bodyless.add(method);
	    }

	    const _method = method.toLowerCase();
	    if (!this.hasDecorator(_method)) {
	      this.decorate(_method, function (url, options, handler) {
	        return router.prepareRoute.call(this, { method, url, options, handler })
	      });
	    }

	    return this
	  }
	}

	function validateSchemaErrorFormatter (schemaErrorFormatter) {
	  if (typeof schemaErrorFormatter !== 'function') {
	    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter)
	  } else if (schemaErrorFormatter.constructor.name === 'AsyncFunction') {
	    throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN('AsyncFunction')
	  }
	}

	/**
	 * These export configurations enable JS and TS developers
	 * to consume fastify in whatever way best suits their needs.
	 * Some examples of supported import syntax includes:
	 * - `const fastify = require('fastify')`
	 * - `const { fastify } = require('fastify')`
	 * - `import * as Fastify from 'fastify'`
	 * - `import { fastify, TSC_definition } from 'fastify'`
	 * - `import fastify from 'fastify'`
	 * - `import fastify, { TSC_definition } from 'fastify'`
	 */
	fastify.exports = fastify$1;
	fastify.exports.errorCodes = errorCodes;
	fastify.exports.fastify = fastify$1;
	fastify.exports.default = fastify$1;
	return fastify.exports;
}

var fastifyExports = requireFastify();

var cors = {exports: {}};

var plugin = {exports: {}};

var getPluginName = {exports: {}};

var hasRequiredGetPluginName;

function requireGetPluginName () {
	if (hasRequiredGetPluginName) return getPluginName.exports;
	hasRequiredGetPluginName = 1;

	const fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
	const fileNamePattern = /(\w*(\.\w*)*)\..*/;

	getPluginName.exports = function getPluginName (fn) {
	  if (fn.name.length > 0) return fn.name

	  const stackTraceLimit = Error.stackTraceLimit;
	  Error.stackTraceLimit = 10;
	  try {
	    throw new Error('anonymous function')
	  } catch (e) {
	    Error.stackTraceLimit = stackTraceLimit;
	    return extractPluginName(e.stack)
	  }
	};

	function extractPluginName (stack) {
	  const m = stack.match(fpStackTracePattern);

	  // get last section of path and match for filename
	  return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : 'anonymous'
	}
	getPluginName.exports.extractPluginName = extractPluginName;
	return getPluginName.exports;
}

var toCamelCase;
var hasRequiredToCamelCase;

function requireToCamelCase () {
	if (hasRequiredToCamelCase) return toCamelCase;
	hasRequiredToCamelCase = 1;

	toCamelCase = function toCamelCase (name) {
	  if (name[0] === '@') {
	    name = name.slice(1).replace('/', '-');
	  }
	  return name.replace(/-(.)/g, function (match, g1) {
	    return g1.toUpperCase()
	  })
	};
	return toCamelCase;
}

var hasRequiredPlugin;

function requirePlugin () {
	if (hasRequiredPlugin) return plugin.exports;
	hasRequiredPlugin = 1;

	const getPluginName = requireGetPluginName();
	const toCamelCase = requireToCamelCase();

	let count = 0;

	function plugin$1 (fn, options = {}) {
	  let autoName = false;

	  if (fn.default !== undefined) {
	    // Support for 'export default' behaviour in transpiled ECMAScript module
	    fn = fn.default;
	  }

	  if (typeof fn !== 'function') {
	    throw new TypeError(
	      `fastify-plugin expects a function, instead got a '${typeof fn}'`
	    )
	  }

	  if (typeof options === 'string') {
	    options = {
	      fastify: options
	    };
	  }

	  if (
	    typeof options !== 'object' ||
	    Array.isArray(options) ||
	    options === null
	  ) {
	    throw new TypeError('The options object should be an object')
	  }

	  if (options.fastify !== undefined && typeof options.fastify !== 'string') {
	    throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`)
	  }

	  if (!options.name) {
	    autoName = true;
	    options.name = getPluginName(fn) + '-auto-' + count++;
	  }

	  fn[Symbol.for('skip-override')] = options.encapsulate !== true;
	  fn[Symbol.for('fastify.display-name')] = options.name;
	  fn[Symbol.for('plugin-meta')] = options;

	  // Faux modules support
	  if (!fn.default) {
	    fn.default = fn;
	  }

	  // TypeScript support for named imports
	  // See https://github.com/fastify/fastify/issues/2404 for more details
	  // The type definitions would have to be update to match this.
	  const camelCase = toCamelCase(options.name);
	  if (!autoName && !fn[camelCase]) {
	    fn[camelCase] = fn;
	  }

	  return fn
	}

	plugin.exports = plugin$1;
	plugin.exports.default = plugin$1;
	plugin.exports.fastifyPlugin = plugin$1;
	return plugin.exports;
}

var vary = {};

var hasRequiredVary;

function requireVary () {
	if (hasRequiredVary) return vary;
	hasRequiredVary = 1;

	const { FifoMap: FifoCache } = requireToadCache();

	/**
	 * Field Value Components
	 * Most HTTP header field values are defined using common syntax
	 * components (token, quoted-string, and comment) separated by
	 * whitespace or specific delimiting characters.  Delimiters are chosen
	 * from the set of US-ASCII visual characters not allowed in a token
	 * (DQUOTE and "(),/:;<=>?@[\]{}").
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 *
	 * @see https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6
	 */

	const validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
	function validateFieldname (fieldname) {
	  if (validFieldnameRE.test(fieldname) === false) {
	    throw new TypeError('Fieldname contains invalid characters.')
	  }
	}

	function parse (header) {
	  header = header.trim().toLowerCase();
	  const result = [];

	  if (header.length === 0) ; else if (header.indexOf(',') === -1) {
	    result.push(header);
	  } else {
	    const il = header.length;
	    let i = 0;
	    let pos = 0;
	    let char;

	    // tokenize the header
	    for (i; i < il; ++i) {
	      char = header[i];
	      // when we have whitespace set the pos to the next position
	      if (char === ' ') {
	        pos = i + 1;
	      // `,` is the separator of vary-values
	      } else if (char === ',') {
	        // if pos and current position are not the same we have a valid token
	        if (pos !== i) {
	          result.push(header.slice(pos, i));
	        }
	        // reset the positions
	        pos = i + 1;
	      }
	    }

	    if (pos !== i) {
	      result.push(header.slice(pos, i));
	    }
	  }

	  return result
	}

	function createAddFieldnameToVary (fieldname) {
	  const headerCache = new FifoCache(1000);

	  validateFieldname(fieldname);

	  return function (reply) {
	    let header = reply.getHeader('Vary');

	    if (!header) {
	      reply.header('Vary', fieldname);
	      return
	    }

	    if (header === '*') {
	      return
	    }

	    if (fieldname === '*') {
	      reply.header('Vary', '*');
	      return
	    }

	    if (Array.isArray(header)) {
	      header = header.join(', ');
	    }

	    if (headerCache.get(header) === undefined) {
	      const vals = parse(header);

	      if (vals.indexOf('*') !== -1) {
	        headerCache.set(header, '*');
	      } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
	        headerCache.set(header, header + ', ' + fieldname);
	      } else {
	        headerCache.set(header, null);
	      }
	    }
	    const cached = headerCache.get(header);
	    if (cached !== null) {
	      reply.header('Vary', cached);
	    }
	  }
	}

	vary.createAddFieldnameToVary = createAddFieldnameToVary;
	vary.addOriginToVaryHeader = createAddFieldnameToVary('Origin');
	vary.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary('Access-Control-Request-Headers');
	vary.parse = parse;
	return vary;
}

var hasRequiredCors;

function requireCors () {
	if (hasRequiredCors) return cors.exports;
	hasRequiredCors = 1;

	const fp = requirePlugin();
	const {
	  addAccessControlRequestHeadersToVaryHeader,
	  addOriginToVaryHeader
	} = requireVary();

	const defaultOptions = {
	  origin: '*',
	  methods: 'GET,HEAD,POST',
	  hook: 'onRequest',
	  preflightContinue: false,
	  optionsSuccessStatus: 204,
	  credentials: false,
	  exposedHeaders: null,
	  allowedHeaders: null,
	  maxAge: null,
	  preflight: true,
	  strictPreflight: true
	};

	const validHooks = [
	  'onRequest',
	  'preParsing',
	  'preValidation',
	  'preHandler',
	  'preSerialization',
	  'onSend'
	];

	const hookWithPayload = [
	  'preSerialization',
	  'preParsing',
	  'onSend'
	];

	function validateHook (value, next) {
	  if (validHooks.indexOf(value) !== -1) {
	    return
	  }
	  next(new TypeError('@fastify/cors: Invalid hook option provided.'));
	}

	function fastifyCors (fastify, opts, next) {
	  fastify.decorateRequest('corsPreflightEnabled', false);

	  let hideOptionsRoute = true;
	  if (typeof opts === 'function') {
	    handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions.hook }, next);
	  } else if (opts.delegator) {
	    const { delegator, ...options } = opts;
	    handleCorsOptionsDelegator(delegator, fastify, options, next);
	  } else {
	    if (opts.hideOptionsRoute !== undefined) hideOptionsRoute = opts.hideOptionsRoute;
	    const corsOptions = normalizeCorsOptions(opts);
	    validateHook(corsOptions.hook, next);
	    if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
	      fastify.addHook(corsOptions.hook, function handleCors (req, reply, _payload, next) {
	        addCorsHeadersHandler(fastify, corsOptions, req, reply, next);
	      });
	    } else {
	      fastify.addHook(corsOptions.hook, function handleCors (req, reply, next) {
	        addCorsHeadersHandler(fastify, corsOptions, req, reply, next);
	      });
	    }
	  }

	  // The preflight reply must occur in the hook. This allows fastify-cors to reply to
	  // preflight requests BEFORE possible authentication plugins. If the preflight reply
	  // occurred in this handler, other plugins may deny the request since the browser will
	  // remove most headers (such as the Authentication header).
	  //
	  // This route simply enables fastify to accept preflight requests.
	  fastify.options('*', { schema: { hide: hideOptionsRoute } }, (req, reply) => {
	    if (!req.corsPreflightEnabled) {
	      // Do not handle preflight requests if the origin option disabled CORS
	      reply.callNotFound();
	      return
	    }

	    reply.send();
	  });

	  next();
	}

	function handleCorsOptionsDelegator (optionsResolver, fastify, opts, next) {
	  const hook = opts?.hook || defaultOptions.hook;
	  validateHook(hook, next);
	  if (optionsResolver.length === 2) {
	    if (hookWithPayload.indexOf(hook) !== -1) {
	      fastify.addHook(hook, function handleCors (req, reply, _payload, next) {
	        handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next);
	      });
	    } else {
	      fastify.addHook(hook, function handleCors (req, reply, next) {
	        handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next);
	      });
	    }
	  } else {
	    if (hookWithPayload.indexOf(hook) !== -1) {
	      // handle delegator based on Promise
	      fastify.addHook(hook, function handleCors (req, reply, _payload, next) {
	        const ret = optionsResolver(req);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(options => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next)).catch(next);
	          return
	        }
	        next(new Error('Invalid CORS origin option'));
	      });
	    } else {
	      // handle delegator based on Promise
	      fastify.addHook(hook, function handleCors (req, reply, next) {
	        const ret = optionsResolver(req);
	        if (ret && typeof ret.then === 'function') {
	          ret.then(options => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next)).catch(next);
	          return
	        }
	        next(new Error('Invalid CORS origin option'));
	      });
	    }
	  }
	}

	function handleCorsOptionsCallbackDelegator (optionsResolver, fastify, req, reply, next) {
	  optionsResolver(req, (err, options) => {
	    if (err) {
	      next(err);
	    } else {
	      addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
	    }
	  });
	}

	/**
	 * @param {import('./types').FastifyCorsOptions} opts
	 */
	function normalizeCorsOptions (opts, dynamic) {
	  const corsOptions = { ...defaultOptions, ...opts };
	  if (Array.isArray(opts.origin) && opts.origin.indexOf('*') !== -1) {
	    corsOptions.origin = '*';
	  }
	  if (Number.isInteger(corsOptions.cacheControl)) {
	    // integer numbers are formatted this way
	    corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
	  } else if (typeof corsOptions.cacheControl !== 'string') {
	    // strings are applied directly and any other value is ignored
	    corsOptions.cacheControl = null;
	  }
	  corsOptions.dynamic = dynamic || false;
	  return corsOptions
	}

	function addCorsHeadersHandler (fastify, options, req, reply, next) {
	  if ((typeof options.origin !== 'string' && options.origin !== false) || options.dynamic) {
	    // Always set Vary header for non-static origin option
	    // https://fetch.spec.whatwg.org/#cors-protocol-and-http-caches
	    addOriginToVaryHeader(reply);
	  }

	  const resolveOriginOption = typeof options.origin === 'function' ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin);

	  resolveOriginOption(req, (error, resolvedOriginOption) => {
	    if (error !== null) {
	      return next(error)
	    }

	    // Disable CORS and preflight if false
	    if (resolvedOriginOption === false) {
	      return next()
	    }

	    // Allow routes to disable CORS individually
	    if (req.routeOptions.config?.cors === false) {
	      return next()
	    }

	    // Falsy values are invalid
	    if (!resolvedOriginOption) {
	      return next(new Error('Invalid CORS origin option'))
	    }

	    addCorsHeaders(req, reply, resolvedOriginOption, options);

	    if (req.raw.method === 'OPTIONS' && options.preflight === true) {
	      // Strict mode enforces the required headers for preflight
	      if (options.strictPreflight === true && (!req.headers.origin || !req.headers['access-control-request-method'])) {
	        reply.status(400).type('text/plain').send('Invalid Preflight Request');
	        return
	      }

	      req.corsPreflightEnabled = true;

	      addPreflightHeaders(req, reply, options);

	      if (!options.preflightContinue) {
	        // Do not call the hook callback and terminate the request
	        // Safari (and potentially other browsers) need content-length 0,
	        // for 204 or they just hang waiting for a body
	        reply
	          .code(options.optionsSuccessStatus)
	          .header('Content-Length', '0')
	          .send();
	        return
	      }
	    }

	    return next()
	  });
	}

	function addCorsHeaders (req, reply, originOption, corsOptions) {
	  const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
	  // In the case of origin not allowed the header is not
	  // written in the response.
	  // https://github.com/fastify/fastify-cors/issues/127
	  if (origin) {
	    reply.header('Access-Control-Allow-Origin', origin);
	  }

	  if (corsOptions.credentials) {
	    reply.header('Access-Control-Allow-Credentials', 'true');
	  }

	  if (corsOptions.exposedHeaders !== null) {
	    reply.header(
	      'Access-Control-Expose-Headers',
	      Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(', ') : corsOptions.exposedHeaders
	    );
	  }
	}

	function addPreflightHeaders (req, reply, corsOptions) {
	  reply.header(
	    'Access-Control-Allow-Methods',
	    Array.isArray(corsOptions.methods) ? corsOptions.methods.join(', ') : corsOptions.methods
	  );

	  if (corsOptions.allowedHeaders === null) {
	    addAccessControlRequestHeadersToVaryHeader(reply);
	    const reqAllowedHeaders = req.headers['access-control-request-headers'];
	    if (reqAllowedHeaders !== undefined) {
	      reply.header('Access-Control-Allow-Headers', reqAllowedHeaders);
	    }
	  } else {
	    reply.header(
	      'Access-Control-Allow-Headers',
	      Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(', ') : corsOptions.allowedHeaders
	    );
	  }

	  if (corsOptions.maxAge !== null) {
	    reply.header('Access-Control-Max-Age', String(corsOptions.maxAge));
	  }

	  if (corsOptions.cacheControl) {
	    reply.header('Cache-Control', corsOptions.cacheControl);
	  }
	}

	function resolveOriginWrapper (fastify, origin) {
	  return function (req, cb) {
	    const result = origin.call(fastify, req.headers.origin, cb);

	    // Allow for promises
	    if (result && typeof result.then === 'function') {
	      result.then(res => cb(null, res), cb);
	    }
	  }
	}

	function getAccessControlAllowOriginHeader (reqOrigin, originOption) {
	  if (typeof originOption === 'string') {
	    // fixed or any origin ('*')
	    return originOption
	  }

	  // reflect origin
	  return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false
	}

	function isRequestOriginAllowed (reqOrigin, allowedOrigin) {
	  if (Array.isArray(allowedOrigin)) {
	    for (let i = 0; i < allowedOrigin.length; ++i) {
	      if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
	        return true
	      }
	    }
	    return false
	  } else if (typeof allowedOrigin === 'string') {
	    return reqOrigin === allowedOrigin
	  } else if (allowedOrigin instanceof RegExp) {
	    allowedOrigin.lastIndex = 0;
	    return allowedOrigin.test(reqOrigin)
	  } else {
	    return !!allowedOrigin
	  }
	}

	const _fastifyCors = fp(fastifyCors, {
	  fastify: '5.x',
	  name: '@fastify/cors'
	});

	/**
	 * These export configurations enable JS and TS developers
	 * to consumer fastify in whatever way best suits their needs.
	 */
	cors.exports = _fastifyCors;
	cors.exports.fastifyCors = _fastifyCors;
	cors.exports.default = _fastifyCors;
	return cors.exports;
}

var corsExports = requireCors();

var websocket$2 = {exports: {}};

var bufferUtil$1 = {exports: {}};

var constants$2;
var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;

	const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
	const hasBlob = typeof Blob !== 'undefined';

	if (hasBlob) BINARY_TYPES.push('blob');

	constants$2 = {
	  BINARY_TYPES,
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  hasBlob,
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants$2;
}

var hasRequiredBufferUtil$1;

function requireBufferUtil$1 () {
	if (hasRequiredBufferUtil$1) return bufferUtil$1.exports;
	hasRequiredBufferUtil$1 = 1;

	const { EMPTY_BUFFER } = requireConstants$2();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil$1.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil = require('bufferutil');

	    bufferUtil$1.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil.mask(source, mask, output, offset, length);
	    };

	    bufferUtil$1.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil$1.exports;
}

var limiter$1;
var hasRequiredLimiter$1;

function requireLimiter$1 () {
	if (hasRequiredLimiter$1) return limiter$1;
	hasRequiredLimiter$1 = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter$1 = Limiter;
	return limiter$1;
}

var permessageDeflate$1;
var hasRequiredPermessageDeflate$1;

function requirePermessageDeflate$1 () {
	if (hasRequiredPermessageDeflate$1) return permessageDeflate$1;
	hasRequiredPermessageDeflate$1 = 1;

	const zlib = require$$0$d;

	const bufferUtil = requireBufferUtil$1();
	const Limiter = requireLimiter$1();
	const { kStatusCode } = requireConstants$2();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate$1 = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);

	  //
	  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
	  // fact that in Node.js versions prior to 13.10.0, the callback for
	  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
	  // `zlib.reset()` ensures that either the callback is invoked or an error is
	  // emitted.
	  //
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;

	  if (this[kError]) {
	    this[kCallback](this[kError]);
	    return;
	  }

	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate$1;
}

var validation$1 = {exports: {}};

var hasRequiredValidation$1;

function requireValidation$1 () {
	if (hasRequiredValidation$1) return validation$1.exports;
	hasRequiredValidation$1 = 1;

	const { isUtf8 } = require$$0$8;

	const { hasBlob } = requireConstants$2();

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Determines whether a value is a `Blob`.
	 *
	 * @param {*} value The value to be tested
	 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
	 * @private
	 */
	function isBlob(value) {
	  return (
	    hasBlob &&
	    typeof value === 'object' &&
	    typeof value.arrayBuffer === 'function' &&
	    typeof value.type === 'string' &&
	    typeof value.stream === 'function' &&
	    (value[Symbol.toStringTag] === 'Blob' ||
	      value[Symbol.toStringTag] === 'File')
	  );
	}

	validation$1.exports = {
	  isBlob,
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation$1.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');

	    validation$1.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation$1.exports;
}

var receiver$1;
var hasRequiredReceiver$1;

function requireReceiver$1 () {
	if (hasRequiredReceiver$1) return receiver$1;
	hasRequiredReceiver$1 = 1;

	const { Writable } = require$$0$e;

	const PerMessageDeflate = requirePermessageDeflate$1();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants$2();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil$1();
	const { isValidStatusCode, isValidUTF8 } = requireValidation$1();

	const FastBuffer = Buffer[Symbol.species];

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else if (this._binaryType === 'blob') {
	        data = new Blob(fragments);
	      } else {
	        data = fragments;
	      }

	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver$1 = Receiver;
	return receiver$1;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender$1;
var hasRequiredSender$1;

function requireSender$1 () {
	if (hasRequiredSender$1) return sender$1;
	hasRequiredSender$1 = 1;

	const { Duplex } = require$$0$e;
	const { randomFillSync } = require$$1$7;

	const PerMessageDeflate = requirePermessageDeflate$1();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants$2();
	const { isBlob, isValidStatusCode } = requireValidation$1();
	const { mask: applyMask, toBuffer } = requireBufferUtil$1();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;

	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._queue = [];
	    this._state = DEFAULT;
	    this.onerror = NOOP;
	    this[kWebSocket] = undefined;
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          /* istanbul ignore else  */
	          if (randomPool === undefined) {
	            //
	            // This is lazily initialized because server-sent frames must not
	            // be masked so it may never be used.
	            //
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }

	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }

	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    const opts = {
	      [kByteLength]: byteLength,
	      fin: options.fin,
	      generateMask: this._generateMask,
	      mask: options.mask,
	      maskBuffer: this._maskBuffer,
	      opcode,
	      readOnly,
	      rsv1
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
	      } else {
	        this.getBlobData(data, this._compress, opts, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	    } else {
	      this.dispatch(data, this._compress, opts, cb);
	    }
	  }

	  /**
	   * Gets the contents of a blob as binary data.
	   *
	   * @param {Blob} blob The blob
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     the data
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  getBlobData(blob, compress, options, cb) {
	    this._bufferedBytes += options[kByteLength];
	    this._state = GET_BLOB_DATA;

	    blob
	      .arrayBuffer()
	      .then((arrayBuffer) => {
	        if (this._socket.destroyed) {
	          const err = new Error(
	            'The socket was closed while the blob was being read'
	          );

	          //
	          // `callCallbacks` is called in the next tick to ensure that errors
	          // that might be thrown in the callbacks behave like errors thrown
	          // outside the promise chain.
	          //
	          process.nextTick(callCallbacks, this, err, cb);
	          return;
	        }

	        this._bufferedBytes -= options[kByteLength];
	        const data = toBuffer(arrayBuffer);

	        if (!compress) {
	          this._state = DEFAULT;
	          this.sendFrame(Sender.frame(data, options), cb);
	          this.dequeue();
	        } else {
	          this.dispatch(data, compress, options, cb);
	        }
	      })
	      .catch((err) => {
	        //
	        // `onError` is called in the next tick for the same reason that
	        // `callCallbacks` above is.
	        //
	        process.nextTick(onError, this, err, cb);
	      });
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._state = DEFLATING;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        callCallbacks(this, err, cb);
	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._state = DEFAULT;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (this._state === DEFAULT && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {(Buffer | String)[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender$1 = Sender;

	/**
	 * Calls queued callbacks with an error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error to call the callbacks with
	 * @param {Function} [cb] The first callback
	 * @private
	 */
	function callCallbacks(sender, err, cb) {
	  if (typeof cb === 'function') cb(err);

	  for (let i = 0; i < sender._queue.length; i++) {
	    const params = sender._queue[i];
	    const callback = params[params.length - 1];

	    if (typeof callback === 'function') callback(err);
	  }
	}

	/**
	 * Handles a `Sender` error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error
	 * @param {Function} [cb] The first pending callback
	 * @private
	 */
	function onError(sender, err, cb) {
	  callCallbacks(sender, err, cb);
	  sender.onerror(err);
	}
	return sender$1;
}

var eventTarget$1;
var hasRequiredEventTarget$1;

function requireEventTarget$1 () {
	if (hasRequiredEventTarget$1) return eventTarget$1;
	hasRequiredEventTarget$1 = 1;

	const { kForOnEventAttribute, kListener } = requireConstants$2();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget$1 = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget$1;
}

var extension$1;
var hasRequiredExtension$1;

function requireExtension$1 () {
	if (hasRequiredExtension$1) return extension$1;
	hasRequiredExtension$1 = 1;

	const { tokenChars } = requireValidation$1();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension$1 = { format, parse };
	return extension$1;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

var websocket$1;
var hasRequiredWebsocket$2;

function requireWebsocket$2 () {
	if (hasRequiredWebsocket$2) return websocket$1;
	hasRequiredWebsocket$2 = 1;

	const EventEmitter = require$$0$7;
	const https = require$$1$8;
	const http = require$$2$2;
	const net = require$$3$3;
	const tls = require$$4;
	const { randomBytes, createHash } = require$$1$7;
	const { Duplex, Readable } = require$$0$e;
	const { URL } = require$$7;

	const PerMessageDeflate = requirePermessageDeflate$1();
	const Receiver = requireReceiver$1();
	const Sender = requireSender$1();
	const { isBlob } = requireValidation$1();

	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants$2();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget$1();
	const { format, parse } = requireExtension$1();
	const { toBuffer } = requireBufferUtil$1();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._errorEmitted = false;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * For historical reasons, the custom "nodebuffer" type is used by the default
	   * instead of "blob".
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    const sender = new Sender(socket, this._extensions, options.generateMask);

	    this._receiver = receiver;
	    this._sender = sender;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    sender[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    sender.onerror = senderOnError;

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    setCloseTimer(this);
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket$1 = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https:", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  //
	  // The following assignment is practically useless and is done only for
	  // consistency.
	  //
	  websocket._errorEmitted = true;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = isBlob(data) ? data.size : toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The `Sender` error event handler.
	 *
	 * @param {Error} The error
	 * @private
	 */
	function senderOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket.readyState === WebSocket.CLOSED) return;
	  if (websocket.readyState === WebSocket.OPEN) {
	    websocket._readyState = WebSocket.CLOSING;
	    setCloseTimer(websocket);
	  }

	  //
	  // `socket.end()` is used instead of `socket.destroy()` to allow the other
	  // peer to finish sending queued data. There is no need to set a timer here
	  // because `CLOSING` means that it is already set or not needed.
	  //
	  this._socket.end();

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * Set a timer to destroy the underlying raw socket of a WebSocket.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @private
	 */
	function setCloseTimer(websocket) {
	  websocket._closeTimer = setTimeout(
	    websocket._socket.destroy.bind(websocket._socket),
	    closeTimeout
	  );
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket$1;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */

var stream$2;
var hasRequiredStream$2;

function requireStream$2 () {
	if (hasRequiredStream$2) return stream$2;
	hasRequiredStream$2 = 1;

	requireWebsocket$2();
	const { Duplex } = require$$0$e;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream$2 = createWebSocketStream;
	return stream$2;
}

var subprotocol$1;
var hasRequiredSubprotocol$1;

function requireSubprotocol$1 () {
	if (hasRequiredSubprotocol$1) return subprotocol$1;
	hasRequiredSubprotocol$1 = 1;

	const { tokenChars } = requireValidation$1();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol$1 = { parse };
	return subprotocol$1;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

var websocketServer$1;
var hasRequiredWebsocketServer$1;

function requireWebsocketServer$1 () {
	if (hasRequiredWebsocketServer$1) return websocketServer$1;
	hasRequiredWebsocketServer$1 = 1;

	const EventEmitter = require$$0$7;
	const http = require$$2$2;
	const { Duplex } = require$$0$e;
	const { createHash } = require$$1$7;

	const extension = requireExtension$1();
	const PerMessageDeflate = requirePermessageDeflate$1();
	const subprotocol = requireSubprotocol$1();
	const WebSocket = requireWebsocket$2();
	const { GUID, kWebSocket } = requireConstants$2();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 13 && version !== 8) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
	        'Sec-WebSocket-Version': '13, 8'
	      });
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer$1 = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @param {Object} [headers] The HTTP response headers
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(
	  server,
	  req,
	  socket,
	  code,
	  message,
	  headers
	) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message, headers);
	  }
	}
	return websocketServer$1;
}

var ws;
var hasRequiredWs;

function requireWs () {
	if (hasRequiredWs) return ws;
	hasRequiredWs = 1;

	const WebSocket = requireWebsocket$2();

	WebSocket.createWebSocketStream = requireStream$2();
	WebSocket.Server = requireWebsocketServer$1();
	WebSocket.Receiver = requireReceiver$1();
	WebSocket.Sender = requireSender$1();

	WebSocket.WebSocket = WebSocket;
	WebSocket.WebSocketServer = WebSocket.Server;

	ws = WebSocket;
	return ws;
}

var readable = {exports: {}};

var stream$1;
var hasRequiredStream$1;

function requireStream$1 () {
	if (hasRequiredStream$1) return stream$1;
	hasRequiredStream$1 = 1;
	stream$1 = require$$0$e;
	return stream$1;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
	var _require = require$$0$8,
	  Buffer = _require.Buffer;
	var _require2 = require$$1$3,
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage (arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message
	    } else {
	      return message(arg1, arg2, arg3)
	    }
	  }

	  class NodeError extends Base {
	    constructor (arg1, arg2, arg3) {
	      super(getMessage(arg1, arg2, arg3));
	    }
	  }

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;

	  codes[code] = NodeError;
	}

	// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    const len = expected.length;
	    expected = expected.map((i) => String(i));
	    if (len > 2) {
	      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
	             expected[len - 1];
	    } else if (len === 2) {
	      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
	    } else {
	      return `of ${thing} ${expected[0]}`;
	    }
	  } else {
	    return `of ${thing} ${String(expected)}`;
	  }
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	function startsWith(str, search, pos) {
		return str.substr(0 , search.length) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
		if (this_len === undefined || this_len > str.length) {
			this_len = str.length;
		}
		return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"'
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  let determiner;
	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  let msg;
	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
	  } else {
	    const type = includes(name, '.') ? 'property' : 'argument';
	    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
	  }

	  msg += `. Received type ${typeof actual}`;
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented'
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

	errors.codes = codes;
	return errors;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state = {
	  getHighWaterMark: getHighWaterMark
	};
	return state;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var node$1;
var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1;
	hasRequiredNode$1 = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node$1 = require$$1$3.deprecate;
	return node$1;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireNode$1()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream$1();
	/*</replacement>*/

	var Buffer = require$$0$8.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;
	var Readable = require_stream_readable();
	var Writable = require_stream_writable();
	requireInherits()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$8;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var endOfStream$1;
var hasRequiredEndOfStream$1;

function requireEndOfStream$1 () {
	if (hasRequiredEndOfStream$1) return endOfStream$1;
	hasRequiredEndOfStream$1 = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream$1 = eos;
	return endOfStream$1;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream$1();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
	function from(Readable, iterable, opts) {
	  var iterator;
	  if (iterable && typeof iterable.next === 'function') {
	    iterator = iterable;
	  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
	  var readable = new Readable(_objectSpread({
	    objectMode: true
	  }, opts));
	  // Reading boolean to protect against _read
	  // being called before last iteration completion.
	  var reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  function next() {
	    return _next2.apply(this, arguments);
	  }
	  function _next2() {
	    _next2 = _asyncToGenerator(function* () {
	      try {
	        var _yield$iterator$next = yield iterator.next(),
	          value = _yield$iterator$next.value,
	          done = _yield$iterator$next.done;
	        if (done) {
	          readable.push(null);
	        } else if (readable.push(yield value)) {
	          next();
	        } else {
	          reading = false;
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	    });
	    return _next2.apply(this, arguments);
	  }
	  return readable;
	}
	from_1 = from;
	return from_1;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	_stream_readable = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$0$7.EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream$1();
	/*</replacement>*/

	var Buffer = require$$0$8.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = require$$1$3;
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFrom();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;
	var _require$codes = requireErrors().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	requireInherits()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;
	var Transform = require_stream_transform();
	requireInherits()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrors().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream$1();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports) {
		var Stream = require$$0$e;
		if (process.env.READABLE_STREAM === 'disable' && Stream) {
		  module.exports = Stream.Readable;
		  Object.assign(module.exports, Stream);
		  module.exports.Stream = Stream;
		} else {
		  exports = module.exports = require_stream_readable();
		  exports.Stream = Stream || exports;
		  exports.Readable = exports;
		  exports.Writable = require_stream_writable();
		  exports.Duplex = require_stream_duplex();
		  exports.Transform = require_stream_transform();
		  exports.PassThrough = require_stream_passthrough();
		  exports.finished = requireEndOfStream$1();
		  exports.pipeline = requirePipeline();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var once = {exports: {}};

var wrappy_1;
var hasRequiredWrappy;

function requireWrappy () {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	wrappy_1 = wrappy;
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length-1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret
	  }
	}
	return wrappy_1;
}

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once.exports = wrappy(once$1);
	once.exports.strict = wrappy(onceStrict);

	once$1.proto = once$1(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once$1(this)
	    },
	    configurable: true
	  });

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  });
	});

	function once$1 (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  f.called = false;
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  var name = fn.name || 'Function wrapped with `once`';
	  f.onceError = name + " shouldn't be called more than once";
	  f.called = false;
	  return f
	}
	return once.exports;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;
	var once = requireOnce();

	var noop = function() {};

	var qnt = commonjsGlobal.Bare ? queueMicrotask : process.nextTick.bind(process);

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);
		var cancelled = false;

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback.call(stream);
		};

		var onend = function() {
			readable = false;
			if (!writable) callback.call(stream);
		};

		var onexit = function(exitCode) {
			callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
		};

		var onerror = function(err) {
			callback.call(stream, err);
		};

		var onclose = function() {
			qnt(onclosenexttick);
		};

		var onclosenexttick = function() {
			if (cancelled) return;
			if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
			if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		if (isChildProcess(stream)) stream.on('exit', onexit);

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', onerror);
		stream.on('close', onclose);

		return function() {
			cancelled = true;
			stream.removeListener('complete', onfinish);
			stream.removeListener('abort', onclose);
			stream.removeListener('request', onrequest);
			if (stream.req) stream.req.removeListener('finish', onfinish);
			stream.removeListener('end', onlegacyfinish);
			stream.removeListener('close', onlegacyfinish);
			stream.removeListener('finish', onfinish);
			stream.removeListener('exit', onexit);
			stream.removeListener('end', onend);
			stream.removeListener('error', onerror);
			stream.removeListener('close', onclose);
		};
	};

	endOfStream = eos;
	return endOfStream;
}

var streamShift;
var hasRequiredStreamShift;

function requireStreamShift () {
	if (hasRequiredStreamShift) return streamShift;
	hasRequiredStreamShift = 1;
	streamShift = shift;

	function shift (stream) {
	  var rs = stream._readableState;
	  if (!rs) return null
	  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))
	}

	function getStateLength (state) {
	  if (state.buffer.length) {
	    var idx = state.bufferIndex || 0;
	    // Since node 6.3.0 state.buffer is a BufferList not an array
	    if (state.buffer.head) {
	      return state.buffer.head.data.length
	    } else if (state.buffer.length - idx > 0 && state.buffer[idx]) {
	      return state.buffer[idx].length
	    }
	  }

	  return state.length
	}
	return streamShift;
}

var duplexify;
var hasRequiredDuplexify;

function requireDuplexify () {
	if (hasRequiredDuplexify) return duplexify;
	hasRequiredDuplexify = 1;
	var stream = requireReadable();
	var eos = requireEndOfStream();
	var inherits = requireInherits();
	var shift = requireStreamShift();

	var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
	  ? Buffer.from([0])
	  : new Buffer([0]);

	var onuncork = function(self, fn) {
	  if (self._corked) self.once('uncork', fn);
	  else fn();
	};

	var autoDestroy = function (self, err) {
	  if (self._autoDestroy) self.destroy(err);
	};

	var destroyer = function(self, end) {
	  return function(err) {
	    if (err) autoDestroy(self, err.message === 'premature close' ? null : err);
	    else if (end && !self._ended) self.end();
	  }
	};

	var end = function(ws, fn) {
	  if (!ws) return fn()
	  if (ws._writableState && ws._writableState.finished) return fn()
	  if (ws._writableState) return ws.end(fn)
	  ws.end();
	  fn();
	};

	var noop = function() {};

	var toStreams2 = function(rs) {
	  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
	};

	var Duplexify = function(writable, readable, opts) {
	  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
	  stream.Duplex.call(this, opts);

	  this._writable = null;
	  this._readable = null;
	  this._readable2 = null;

	  this._autoDestroy = !opts || opts.autoDestroy !== false;
	  this._forwardDestroy = !opts || opts.destroy !== false;
	  this._forwardEnd = !opts || opts.end !== false;
	  this._corked = 1; // start corked
	  this._ondrain = null;
	  this._drained = false;
	  this._forwarding = false;
	  this._unwrite = null;
	  this._unread = null;
	  this._ended = false;

	  this.destroyed = false;

	  if (writable) this.setWritable(writable);
	  if (readable) this.setReadable(readable);
	};

	inherits(Duplexify, stream.Duplex);

	Duplexify.obj = function(writable, readable, opts) {
	  if (!opts) opts = {};
	  opts.objectMode = true;
	  opts.highWaterMark = 16;
	  return new Duplexify(writable, readable, opts)
	};

	Duplexify.prototype.cork = function() {
	  if (++this._corked === 1) this.emit('cork');
	};

	Duplexify.prototype.uncork = function() {
	  if (this._corked && --this._corked === 0) this.emit('uncork');
	};

	Duplexify.prototype.setWritable = function(writable) {
	  if (this._unwrite) this._unwrite();

	  if (this.destroyed) {
	    if (writable && writable.destroy) writable.destroy();
	    return
	  }

	  if (writable === null || writable === false) {
	    this.end();
	    return
	  }

	  var self = this;
	  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd));

	  var ondrain = function() {
	    var ondrain = self._ondrain;
	    self._ondrain = null;
	    if (ondrain) ondrain();
	  };

	  var clear = function() {
	    self._writable.removeListener('drain', ondrain);
	    unend();
	  };

	  if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks

	  this._writable = writable;
	  this._writable.on('drain', ondrain);
	  this._unwrite = clear;

	  this.uncork(); // always uncork setWritable
	};

	Duplexify.prototype.setReadable = function(readable) {
	  if (this._unread) this._unread();

	  if (this.destroyed) {
	    if (readable && readable.destroy) readable.destroy();
	    return
	  }

	  if (readable === null || readable === false) {
	    this.push(null);
	    this.resume();
	    return
	  }

	  var self = this;
	  var unend = eos(readable, {writable:false, readable:true}, destroyer(this));

	  var onreadable = function() {
	    self._forward();
	  };

	  var onend = function() {
	    self.push(null);
	  };

	  var clear = function() {
	    self._readable2.removeListener('readable', onreadable);
	    self._readable2.removeListener('end', onend);
	    unend();
	  };

	  this._drained = true;
	  this._readable = readable;
	  this._readable2 = readable._readableState ? readable : toStreams2(readable);
	  this._readable2.on('readable', onreadable);
	  this._readable2.on('end', onend);
	  this._unread = clear;

	  this._forward();
	};

	Duplexify.prototype._read = function() {
	  this._drained = true;
	  this._forward();
	};

	Duplexify.prototype._forward = function() {
	  if (this._forwarding || !this._readable2 || !this._drained) return
	  this._forwarding = true;

	  var data;

	  while (this._drained && (data = shift(this._readable2)) !== null) {
	    if (this.destroyed) continue
	    this._drained = this.push(data);
	  }

	  this._forwarding = false;
	};

	Duplexify.prototype.destroy = function(err, cb) {
	  if (!cb) cb = noop;
	  if (this.destroyed) return cb(null)
	  this.destroyed = true;

	  var self = this;
	  process.nextTick(function() {
	    self._destroy(err);
	    cb(null);
	  });
	};

	Duplexify.prototype._destroy = function(err) {
	  if (err) {
	    var ondrain = this._ondrain;
	    this._ondrain = null;
	    if (ondrain) ondrain(err);
	    else this.emit('error', err);
	  }

	  if (this._forwardDestroy) {
	    if (this._readable && this._readable.destroy) this._readable.destroy();
	    if (this._writable && this._writable.destroy) this._writable.destroy();
	  }

	  this.emit('close');
	};

	Duplexify.prototype._write = function(data, enc, cb) {
	  if (this.destroyed) return
	  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
	  if (data === SIGNAL_FLUSH) return this._finish(cb)
	  if (!this._writable) return cb()

	  if (this._writable.write(data) === false) this._ondrain = cb;
	  else if (!this.destroyed) cb();
	};

	Duplexify.prototype._finish = function(cb) {
	  var self = this;
	  this.emit('preend');
	  onuncork(this, function() {
	    end(self._forwardEnd && self._writable, function() {
	      // haxx to not emit prefinish twice
	      if (self._writableState.prefinished === false) self._writableState.prefinished = true;
	      self.emit('prefinish');
	      onuncork(self, cb);
	    });
	  });
	};

	Duplexify.prototype.end = function(data, enc, cb) {
	  if (typeof data === 'function') return this.end(null, null, data)
	  if (typeof enc === 'function') return this.end(data, null, enc)
	  this._ended = true;
	  if (data) this.write(data);
	  if (!this._writableState.ending && !this._writableState.destroyed) this.write(SIGNAL_FLUSH);
	  return stream.Writable.prototype.end.call(this, cb)
	};

	duplexify = Duplexify;
	return duplexify;
}

var hasRequiredWebsocket$1;

function requireWebsocket$1 () {
	if (hasRequiredWebsocket$1) return websocket$2.exports;
	hasRequiredWebsocket$1 = 1;

	const { ServerResponse } = require$$0$5;
	const { PassThrough } = require$$1$5;
	const { randomBytes } = require$$0$c;
	const fp = requirePlugin();
	const WebSocket = requireWs();
	const Duplexify = requireDuplexify();

	const kWs = Symbol('ws-socket');
	const kWsHead = Symbol('ws-head');
	const statusCodeReg = /HTTP\/1.1 (\d+)/u;

	function fastifyWebsocket (fastify, opts, next) {
	  fastify.decorateRequest('ws', null);

	  let errorHandler = defaultErrorHandler;
	  if (opts.errorHandler) {
	    if (typeof opts.errorHandler !== 'function') {
	      return next(new Error('invalid errorHandler function'))
	    }

	    errorHandler = opts.errorHandler;
	  }

	  let preClose = defaultPreClose;
	  if (opts?.preClose) {
	    if (typeof opts.preClose !== 'function') {
	      return next(new Error('invalid preClose function'))
	    }

	    preClose = opts.preClose;
	  }

	  if (opts.options?.noServer) {
	    return next(new Error("fastify-websocket doesn't support the ws noServer option. If you want to create a websocket server detatched from fastify, use the ws library directly."))
	  }

	  const wssOptions = Object.assign({ noServer: true }, opts.options);

	  if (wssOptions.path) {
	    fastify.log.warn('ws server path option shouldn\'t be provided, use a route instead');
	  }

	  // We always handle upgrading ourselves in this library so that we can dispatch through the fastify stack before actually upgrading
	  // For this reason, we run the WebSocket.Server in noServer mode, and prevent the user from passing in a http.Server instance for it to attach to.
	  // Usually, we listen to the upgrade event of the `fastify.server`, but we do still support this server option by just listening to upgrades on it if passed.
	  const websocketListenServer = wssOptions.server || fastify.server;
	  delete wssOptions.server;

	  const wss = new WebSocket.Server(wssOptions);
	  fastify.decorate('websocketServer', wss);

	  // TODO: place upgrade context as options
	  async function injectWS (path = '/', upgradeContext = {}, options = {}) {
	    const server2Client = new PassThrough();
	    const client2Server = new PassThrough();

	    const serverStream = new Duplexify(server2Client, client2Server);
	    const clientStream = new Duplexify(client2Server, server2Client);

	    const ws = new WebSocket(null, undefined, { isServer: false });
	    const head = Buffer.from([]);

	    let resolve, reject;
	    const promise = new Promise((_resolve, _reject) => { resolve = _resolve; reject = _reject; });

	    typeof options.onInit === 'function' && options.onInit(ws);

	    ws.on('open', () => {
	      typeof options.onOpen === 'function' && options.onOpen(ws);
	      clientStream.removeListener('data', onData);
	      resolve(ws);
	    });

	    const onData = (chunk) => {
	      if (chunk.toString().includes('HTTP/1.1 101 Switching Protocols')) {
	        ws._isServer = false;
	        ws.setSocket(clientStream, head, { maxPayload: 0 });
	      } else {
	        clientStream.removeListener('data', onData);
	        const statusCode = Number(statusCodeReg.exec(chunk.toString())[1]);
	        reject(new Error('Unexpected server response: ' + statusCode));
	      }
	    };

	    clientStream.on('data', onData);

	    const req = {
	      ...upgradeContext,
	      method: 'GET',
	      headers: {
	        ...upgradeContext.headers,
	        connection: 'upgrade',
	        upgrade: 'websocket',
	        'sec-websocket-version': 13,
	        'sec-websocket-key': randomBytes(16).toString('base64')
	      },
	      httpVersion: '1.1',
	      url: path,
	      [kWs]: serverStream,
	      [kWsHead]: head
	    };

	    websocketListenServer.emit('upgrade', req, req[kWs], req[kWsHead]);

	    return promise
	  }

	  fastify.decorate('injectWS', injectWS);

	  function onUpgrade (rawRequest, socket, head) {
	    // Save a reference to the socket and then dispatch the request through the normal fastify router so that it will invoke hooks and then eventually a route handler that might upgrade the socket.
	    rawRequest[kWs] = socket;
	    rawRequest[kWsHead] = head;
	    const rawResponse = new ServerResponse(rawRequest);
	    try {
	      rawResponse.assignSocket(socket);
	      fastify.routing(rawRequest, rawResponse);
	    } catch (err) {
	      fastify.log.warn({ err }, 'websocket upgrade failed');
	    }
	  }
	  websocketListenServer.on('upgrade', onUpgrade);

	  const handleUpgrade = (rawRequest, callback) => {
	    wss.handleUpgrade(rawRequest, rawRequest[kWs], rawRequest[kWsHead], (socket) => {
	      wss.emit('connection', socket, rawRequest);

	      socket.on('error', (error) => {
	        fastify.log.error(error);
	      });

	      callback(socket);
	    });
	  };

	  fastify.addHook('onRequest', (request, _reply, done) => { // this adds req.ws to the Request object
	    if (request.raw[kWs]) {
	      request.ws = true;
	    } else {
	      request.ws = false;
	    }
	    done();
	  });

	  fastify.addHook('onResponse', (request, _reply, done) => {
	    if (request.ws) {
	      request.raw[kWs].destroy();
	    }
	    done();
	  });

	  fastify.addHook('onRoute', routeOptions => {
	    let isWebsocketRoute = false;
	    let wsHandler = routeOptions.wsHandler;
	    let handler = routeOptions.handler;

	    if (routeOptions.websocket || routeOptions.wsHandler) {
	      if (routeOptions.method === 'HEAD') {
	        return
	      } else if (routeOptions.method !== 'GET') {
	        throw new Error('websocket handler can only be declared in GET method')
	      }

	      isWebsocketRoute = true;

	      if (routeOptions.websocket) {
	        if (!routeOptions.schema) {
	          routeOptions.schema = {};
	        }
	        routeOptions.schema.hide = true;

	        wsHandler = routeOptions.handler;
	        handler = function (_, reply) {
	          reply.code(404).send();
	        };
	      }

	      if (typeof wsHandler !== 'function') {
	        throw new TypeError('invalid wsHandler function')
	      }
	    }

	    // we always override the route handler so we can close websocket connections to routes to handlers that don't support websocket connections
	    // This is not an arrow function to fetch the encapsulated this
	    routeOptions.handler = function (request, reply) {
	      // within the route handler, we check if there has been a connection upgrade by looking at request.raw[kWs]. we need to dispatch the normal HTTP handler if not, and hijack to dispatch the websocket handler if so
	      if (request.raw[kWs]) {
	        reply.hijack();
	        handleUpgrade(request.raw, socket => {
	          let result;
	          try {
	            if (isWebsocketRoute) {
	              result = wsHandler.call(this, socket, request);
	            } else {
	              result = noHandle.call(this, socket, request);
	            }
	          } catch (err) {
	            return errorHandler.call(this, err, socket, request, reply)
	          }

	          if (result && typeof result.catch === 'function') {
	            result.catch(err => errorHandler.call(this, err, socket, request, reply));
	          }
	        });
	      } else {
	        return handler.call(this, request, reply)
	      }
	    };
	  });

	  // Fastify is missing a pre-close event, or the ability to
	  // add a hook before the server.close call. We need to resort
	  // to monkeypatching for now.
	  fastify.addHook('preClose', preClose);

	  function defaultPreClose (done) {
	    const server = this.websocketServer;
	    if (server.clients) {
	      for (const client of server.clients) {
	        client.close();
	      }
	    }

	    fastify.server.removeListener('upgrade', onUpgrade);

	    server.close(done);

	    done();
	  }

	  function noHandle (socket, rawRequest) {
	    this.log.info({ path: rawRequest.url }, 'closed incoming websocket connection for path with no websocket handler');
	    socket.close();
	  }

	  function defaultErrorHandler (error, socket, request) {
	    request.log.error(error);
	    socket.terminate();
	  }

	  next();
	}

	websocket$2.exports = fp(fastifyWebsocket, {
	  fastify: '5.x',
	  name: '@fastify/websocket'
	});
	websocket$2.exports.default = fastifyWebsocket;
	websocket$2.exports.fastifyWebsocket = fastifyWebsocket;
	return websocket$2.exports;
}

var websocketExports$1 = requireWebsocket$1();

var swagger$1 = {exports: {}};

var formatParamUrl_1;
var hasRequiredFormatParamUrl;

function requireFormatParamUrl () {
	if (hasRequiredFormatParamUrl) return formatParamUrl_1;
	hasRequiredFormatParamUrl = 1;

	// The swagger standard does not accept the url param with ':'
	// so '/user/:id' is not valid.
	// This function converts the url in a swagger compliant url string
	// => '/user/{id}'
	// custom verbs at the end of a url are okay => /user::watch but should be rendered as /user:watch in swagger
	const COLON = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';
	function formatParamUrl (str) {
	  let i, char;
	  let state = 'skip';
	  let path = '';
	  let param = '';
	  let level = 0;
	  // count for regex if no param exist
	  let regexp = 0;
	  for (i = 0; i < str.length; i++) {
	    char = str[i];
	    switch (state) {
	      case 'colon': {
	        // we only accept a-zA-Z0-9_ in param
	        if (COLON.indexOf(char) !== -1) {
	          param += char;
	        } else if (char === '(') {
	          state = 'regexp';
	          level++;
	        } else {
	          // end
	          state = 'skip';
	          path += '{' + param + '}';
	          path += char;
	          param = '';
	        }
	        break
	      }
	      case 'regexp': {
	        if (char === '(') {
	          level++;
	        } else if (char === ')') {
	          level--;
	        }
	        // we end if the level reach zero
	        if (level === 0) {
	          state = 'skip';
	          if (param === '') {
	            regexp++;
	            param = 'regexp' + String(regexp);
	          }
	          path += '{' + param + '}';
	          param = '';
	        }
	        break
	      }
	      default: {
	        // we check if we need to change state
	        if (char === ':' && str[i + 1] === ':') {
	          // double colon -> single colon
	          path += char;
	          // skip one more
	          i++;
	        } else if (char === ':') {
	          // single colon -> state colon
	          state = 'colon';
	        } else if (char === '(') {
	          state = 'regexp';
	          level++;
	        } else if (char === '*') {
	          // * -> {*}
	          // should be exist once only
	          path += '{*}';
	        } else {
	          path += char;
	        }
	      }
	    }
	  }
	  // clean up
	  if (state === 'colon' && param !== '') {
	    path += '{' + param + '}';
	  }
	  return path
	}

	formatParamUrl_1 = {
	  formatParamUrl
	};
	return formatParamUrl_1;
}

const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR$1 = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar$1 = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection$1(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR$1:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar$1(node) || isCollection$1(node)) && !!node.anchor;

const BREAK$1 = Symbol('break visit');
const SKIP$1 = Symbol('skip children');
const REMOVE$1 = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit$1(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE$1)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit$1.BREAK = BREAK$1;
/** Do not visit the children of the current node */
visit$1.SKIP = SKIP$1;
/** Remove the current node */
visit$1.REMOVE = REMOVE$1;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (isNode(ctrl) || isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (isCollection$1(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK$1)
                    return BREAK$1;
                else if (ci === REMOVE$1) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK$1)
                return BREAK$1;
            else if (ck === REMOVE$1)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK$1)
                return BREAK$1;
            else if (cv === REMOVE$1)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE$1)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK$1;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP$1;
/** Remove the current node */
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (isNode(ctrl) || isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (isCollection$1(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK$1)
                    return BREAK$1;
                else if (ci === REMOVE$1) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK$1)
                return BREAK$1;
            else if (ck === REMOVE$1)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK$1)
                return BREAK$1;
            else if (cv === REMOVE$1)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (isMap(node))
        return visitor.Map?.(key, node, path);
    if (isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (isPair(node))
        return visitor.Pair?.(key, node, path);
    if (isScalar$1(node))
        return visitor.Scalar?.(key, node, path);
    if (isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (isCollection$1(parent)) {
        parent.items[key] = node;
    }
    else if (isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
            const tags = {};
            visit$1(doc.contents, (_key, node) => {
                if (isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit$1(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            prevAnchors ?? (prevAnchors = anchorNames(doc));
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (isScalar$1(ref.node) || isCollection$1(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                // eslint-disable-next-line @typescript-eslint/no-array-delete
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

class Alias extends NodeBase {
    constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
            nodes = ctx.aliasResolveCache;
        }
        else {
            nodes = [];
            visit$1(doc, {
                Node: (_key, node) => {
                    if (isAlias(node) || hasAnchor(node))
                        nodes.push(node);
                }
            });
            if (ctx)
                ctx.aliasResolveCache = nodes;
        }
        let found = undefined;
        for (const node of nodes) {
            if (node === this)
                break;
            if (node.anchor === this.source)
                found = node;
        }
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (isCollection$1(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends NodeBase {
    constructor(value) {
        super(SCALAR$1);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (isDocument(value))
        value = value.contents;
    if (isNode(value))
        return value;
    if (isPair(value)) {
        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            ref.anchor ?? (ref.anchor = onAnchor(value));
            return new Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[MAP]
                : Symbol.iterator in Object(value)
                    ? schema[SEQ]
                    : schema[MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (isCollection$1(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (isCollection$1(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && isScalar$1(node) ? node.value : node;
        else
            return isCollection$1(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    isScalar$1(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return isCollection$1(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (isCollection$1(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    if (lineWidth < minContentWidth)
        minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    // Leading | or > is added later
    let header = (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (!literal) {
        const foldedValue = value
            .replace(/\n+/g, '\n$&')
            .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== 'folded' && type !== Scalar.BLOCK_FOLDED) {
            foldOptions.onOverflow = () => {
                literalFallback = true;
            };
        }
        const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
        if (!literalFallback)
            return `>${header}\n${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}\n${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.BLOCK_FOLDED:
            case Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (isScalar$1(item)) {
        obj = item.value;
        let match = tags.filter(t => t.identify?.(obj));
        if (match.length > 1) {
            const testMatch = match.filter(t => t.test);
            if (testMatch.length > 0)
                match = testMatch;
        }
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (isScalar$1(node) || isCollection$1(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
        anchors.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify$2(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : isScalar$1(node)
            ? stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return isScalar$1(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (isCollection$1(key) || (!isNode(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            isCollection$1(key) ||
            (isScalar$1(key)
                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify$2(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar$1(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify$2(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && isCollection$1(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        console.warn(warning);
    }
}

// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
const MERGE_KEY = '<<';
const merge = {
    identify: value => value === MERGE_KEY ||
        (typeof value === 'symbol' && value.description === MERGE_KEY),
    default: 'key',
    tag: 'tag:yaml.org,2002:merge',
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge.identify(key) ||
    (isScalar$1(key) &&
        (!key.type || key.type === Scalar.PLAIN) &&
        merge.identify(key.value))) &&
    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map, value) {
    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
        for (const it of value.items)
            mergeValue(ctx, map, it);
    else if (Array.isArray(value))
        for (const it of value)
            mergeValue(ctx, map, it);
    else
        mergeValue(ctx, map, value);
}
function mergeValue(ctx, map, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}

function addPairToJSMap(ctx, map, { key, value }) {
    if (isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
    // TODO: Should drop this special case for bare << handling
    else if (isMergeKey(ctx, key))
        addMergeToJSMap(ctx, map, value);
    else {
        const jsKey = toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (isNode(key) && ctx?.doc) {
        const strCtx = createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

function createPair(key, value, ctx) {
    const k = createNode(key, undefined, ctx);
    const v = createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (isNode(key))
            key = key.clone(schema);
        if (isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify$2(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify$2(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

function findPair(items, key) {
    const k = isScalar$1(key) ? key.value : key;
    for (const it of items) {
        if (isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (isScalar$1(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair(pair, pair?.value);
        }
        else
            _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (isScalar$1(prev.value) && isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar$1(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)
};

class YAMLSeq extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && isScalar$1(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar$1(prev) && isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = isScalar$1(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)
};

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
    }
};

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

const floatNaN$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify$1(node, radix, prefix) {
    const { value } = node;
    if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber(node);
}
const intOct$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
    stringify: node => intStringify$1(node, 8, '0o')
};
const int$1 = {
    identify: intIdentify$2,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
    stringify: node => intStringify$1(node, 16, '0x')
};

const schema$2 = [
    map,
    seq,
    string,
    nullTag,
    boolTag,
    intOct$1,
    int$1,
    intHex$1,
    floatNaN$1,
    floatExp$1,
    float$1
];

function intIdentify$1(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true$|^false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify$1,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema$1 = [map, seq].concat(jsonScalars, jsonError);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
            return '';
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        type ?? (type = Scalar.BLOCK_LITERAL);
        if (type !== Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

function resolvePairs(seq, onError) {
    if (isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (isPair(item))
                continue;
            else if (isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair(new Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = isPair(item) ? item : new Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

class YAMLOMap extends YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (isPair(pair)) {
                key = toJS(pair.key, '', ctx);
                value = toJS(pair.value, key, ctx);
            }
            else {
                key = toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs = createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs = resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs.items) {
            if (isScalar$1(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar(false),
    stringify: boolStringify
};

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

class YAMLSet extends YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair(key.key, null);
        else
            pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair)
            ? isScalar$1(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, '') ?? ''
};

const schema = [
    map,
    seq,
    string,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct,
    int,
    intHex,
    floatNaN,
    floatExp,
    float,
    binary,
    merge,
    omap,
    pairs,
    set,
    intTime,
    floatTime,
    timestamp
];

const schemas = new Map([
    ['core', schema$2],
    ['failsafe', [map, seq, string]],
    ['json', schema$1],
    ['yaml11', schema],
    ['yaml-1.1', schema]
]);
const tagsByName = {
    binary,
    bool: boolTag,
    float: float$1,
    floatExp: floatExp$1,
    floatNaN: floatNaN$1,
    floatTime,
    int: int$1,
    intHex: intHex$1,
    intOct: intOct$1,
    intTime,
    map,
    merge,
    null: nullTag,
    omap,
    pairs,
    seq,
    set,
    timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary,
    'tag:yaml.org,2002:merge': merge,
    'tag:yaml.org,2002:omap': omap,
    'tag:yaml.org,2002:pairs': pairs,
    'tag:yaml.org,2002:set': set,
    'tag:yaml.org,2002:timestamp': timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge)
            ? schemaTags.concat(merge)
            : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    if (addMergeTag)
        tags = tags.concat(merge);
    return tags.reduce((tags, tag) => {
        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
        if (!tagObj) {
            const tagName = JSON.stringify(tag);
            const keys = Object.keys(tagsByName)
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj))
            tags.push(tagObj);
        return tags;
    }, []);
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? getTags(compat, 'compat')
            : compat
                ? getTags(null, compat)
                : null;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR$1, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify$2(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify$2(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection$1(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection$1(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar$1(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection$1(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection$1(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection$1(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new Directives({ version: '1.1' });
                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new Directives({ version });
                opt = { resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (isCollection$1(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
            }
            tab = null;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
                    token.source.includes('\t')) {
                    tab = token;
                }
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else if (!found || indicator !== 'seq-item-ind')
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    newlineAfterProp = token;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline =
                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    }
    if (tab &&
        ((atNewline && tab.indent <= parentIndent) ||
            next?.type === 'block-map' ||
            next?.type === 'block-seq'))
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
    };
}

function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b || (isScalar$1(a) && isScalar$1(b) && a.value === b.value);
    return items.some(pair => isEqual(pair.key, search));
}

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.newlineAfterProp || containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            //  key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            ctx.atKey = true;
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            ctx.atKey = false;
            // value properties
            const valueProps = resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                const endRange = (valueNode ?? keyNode).range;
                map.range = [keyNode.range[0], endRange[1], endRange[2]];
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (token.type === 'block-seq') {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken
            ? anchor.offset > tagToken.offset
                ? anchor
                : tagToken
            : (anchor ?? tagToken);
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
            const message = 'Missing newline after block sequence props';
            onError(lastProp, 'MISSING_CHAR', message);
        }
    }
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.tagName && expType === 'seq')) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = isNode(res)
        ? res
        : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = 'Block scalar values in collections must be indented';
                onError(offset, 'BAD_INDENT', message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar(ctx, token, onError)
        : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[SCALAR$1];
    }
    else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === 'scalar')
        tag = findScalarTagByTest(ctx, value, token, onError);
    else
        tag = ctx.schema[SCALAR$1];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = isScalar$1(res) ? res : new Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[SCALAR$1]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[SCALAR$1];
}
function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&
        tag.test?.test(value)) || schema[SCALAR$1];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[SCALAR$1];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

function emptyScalarPosition(offset, before, pos) {
    if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection(CN, ctx, token, props, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (atKey &&
        ctx.options.stringKeys &&
        (!isScalar$1(node) ||
            typeof node.value !== 'string' ||
            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {
        const msg = 'With stringKeys, all keys must be strings';
        onError(tag ?? token, 'NON_STRING_KEY', msg);
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(undefined, opts);
    const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode(ctx, value, props, onError)
        : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new YAMLWarning(pos, code, message));
            else
                this.errors.push(new YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar({ options: { strict } }, token, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify$1 = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]`  Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null`  Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]`  Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token`  The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

var cst = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BOM: BOM,
  DOCUMENT: DOCUMENT,
  FLOW_END: FLOW_END,
  SCALAR: SCALAR,
  createScalarToken: createScalarToken,
  isCollection: isCollection,
  isScalar: isScalar,
  prettyToken: prettyToken,
  resolveAsScalar: resolveAsScalar,
  setScalarValue: setScalarValue,
  stringify: stringify$1,
  tokenType: tokenType,
  visit: visit
});

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
                    cs = line.indexOf('#', cs + 1);
                }
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return s === '---' ? 'doc' : 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (bv.type === 'block-seq') {
                            if (!it.explicitKey &&
                                it.sep &&
                                !includesToken(it.sep, 'newline')) {
                                yield* this.pop({
                                    type: 'error',
                                    offset: this.offset,
                                    message: 'Unexpected block-seq-ind on same line with key',
                                    source: this.source
                                });
                                return;
                            }
                        }
                        else if (atMapIndent) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, explicitKey: true }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;
    return { lineCounter, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    const docs = Array.from(composer.compose(parser.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(prettifyError(source, lineCounter));
            doc.warnings.forEach(prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(prettifyError(source, lineCounter));
        doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    if (isDocument(value) && !_replacer)
        return value.toString(options);
    return new Document(value, _replacer, options).toString(options);
}

var YAML = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Alias: Alias,
  CST: cst,
  Composer: Composer,
  Document: Document,
  Lexer: Lexer,
  LineCounter: LineCounter,
  Pair: Pair,
  Parser: Parser,
  Scalar: Scalar,
  Schema: Schema,
  YAMLError: YAMLError,
  YAMLMap: YAMLMap,
  YAMLParseError: YAMLParseError,
  YAMLSeq: YAMLSeq,
  YAMLWarning: YAMLWarning,
  isAlias: isAlias,
  isCollection: isCollection$1,
  isDocument: isDocument,
  isMap: isMap,
  isNode: isNode,
  isPair: isPair,
  isScalar: isScalar$1,
  isSeq: isSeq,
  parse: parse,
  parseAllDocuments: parseAllDocuments,
  parseDocument: parseDocument,
  stringify: stringify,
  visit: visit$1,
  visitAsync: visitAsync
});

// `export * as default from ...` fails on Webpack v4
// https://github.com/eemeli/yaml/issues/228

var browser$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Alias: Alias,
  CST: cst,
  Composer: Composer,
  Document: Document,
  Lexer: Lexer,
  LineCounter: LineCounter,
  Pair: Pair,
  Parser: Parser,
  Scalar: Scalar,
  Schema: Schema,
  YAMLError: YAMLError,
  YAMLMap: YAMLMap,
  YAMLParseError: YAMLParseError,
  YAMLSeq: YAMLSeq,
  YAMLWarning: YAMLWarning,
  default: YAML,
  isAlias: isAlias,
  isCollection: isCollection$1,
  isDocument: isDocument,
  isMap: isMap,
  isNode: isNode,
  isPair: isPair,
  isScalar: isScalar$1,
  isSeq: isSeq,
  parse: parse,
  parseAllDocuments: parseAllDocuments,
  parseDocument: parseDocument,
  stringify: stringify,
  visit: visit$1,
  visitAsync: visitAsync
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(browser$1);

var _static$1;
var hasRequired_static$1;

function require_static$1 () {
	if (hasRequired_static$1) return _static$1;
	hasRequired_static$1 = 1;

	const path = require$$1$4;
	const fs = require$$0$f;
	const yaml = require$$1;

	_static$1 = function (fastify, opts, done) {
	  if (!opts.specification) return done(new Error('specification is missing in the module options'))
	  if (typeof opts.specification !== 'object') return done(new Error('specification is not an object'))

	  let swaggerObject = {};

	  if (!opts.specification.path && !opts.specification.document) {
	    return done(new Error('both specification.path and specification.document are missing, should be path to the file or swagger document spec'))
	  } else if (opts.specification.path) {
	    if (typeof opts.specification.path !== 'string') return done(new Error('specification.path is not a string'))

	    if (!fs.existsSync(path.resolve(opts.specification.path))) return done(new Error(`${opts.specification.path} does not exist`))

	    const extName = path.extname(opts.specification.path).toLowerCase();
	    if (['.yaml', '.json'].indexOf(extName) === -1) return done(new Error("specification.path extension name is not supported, should be one from ['.yaml', '.json']"))

	    if (opts.specification.postProcessor && typeof opts.specification.postProcessor !== 'function') return done(new Error('specification.postProcessor should be a function'))

	    if (opts.specification.baseDir && typeof opts.specification.baseDir !== 'string') return done(new Error('specification.baseDir should be string'))

	    if (!opts.specification.baseDir) {
	      opts.specification.baseDir = path.resolve(path.dirname(opts.specification.path));
	    } else {
	      while (opts.specification.baseDir.endsWith('/')) {
	        opts.specification.baseDir = opts.specification.baseDir.slice(0, -1);
	      }
	    }

	    // read
	    const source = fs.readFileSync(
	      path.resolve(opts.specification.path),
	      'utf8'
	    );
	    switch (extName) {
	      case '.yaml':
	        swaggerObject = yaml.parse(source);
	        break
	      case '.json':
	        swaggerObject = JSON.parse(source);
	        break
	    }

	    // apply postProcessor, if one was passed as an argument
	    if (opts.specification.postProcessor) {
	      swaggerObject = opts.specification.postProcessor(swaggerObject);
	    }
	  } else {
	    if (typeof opts.specification.document !== 'object') return done(new Error('specification.document is not an object'))

	    swaggerObject = opts.specification.document;
	  }

	  fastify.decorate(opts.decorator || 'swagger', swagger);

	  const cache = {
	    swaggerObject: null,
	    swaggerString: null
	  };

	  function swagger (opts) {
	    if (opts?.yaml) {
	      if (cache.swaggerString) return cache.swaggerString
	    } else {
	      if (cache.swaggerObject) return cache.swaggerObject
	    }

	    if (opts?.yaml) {
	      const swaggerString = yaml.stringify(swaggerObject, { strict: false });
	      cache.swaggerString = swaggerString;
	      return swaggerString
	    }

	    cache.swaggerObject = swaggerObject;
	    return swaggerObject
	  }

	  done();
	};
	return _static$1;
}

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			// eslint-disable-next-line no-return-assign
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os$1 = os;
	const tty = require$$1$9;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os$1.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$1$9;
		const util = require$$1$3;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var refResolver;
var hasRequiredRefResolver;

function requireRefResolver () {
	if (hasRequiredRefResolver) return refResolver;
	hasRequiredRefResolver = 1;

	const URI = requireFastUri();
	const cloner = requireRfdc()({ proto: true, circles: false });
	const { EventEmitter } = require$$0$7;
	const debug = requireSrc()('json-schema-resolver');

	const kIgnore = Symbol('json-schema-resolver.ignore'); // untrack a schema (usually the root one)
	const kRefToDef = Symbol('json-schema-resolver.refToDef'); // assign to an external json a new reference
	const kConsumed = Symbol('json-schema-resolver.consumed'); // when an external json has been referenced

	// ! Target: DRAFT-07
	// https://tools.ietf.org/html/draft-handrews-json-schema-01

	// ? Open to DRAFT 08
	// https://json-schema.org/draft/2019-09/json-schema-core.html

	const defaultOpts = {
	  target: 'draft-07',
	  clone: false,
	  buildLocalReference (json, baseUri, fragment, i) {
	    return `def-${i}`
	  }
	};

	const targetSupported = ['draft-07']; // TODO , 'draft-08'
	const targetCfg = {
	  'draft-07': {
	    def: 'definitions'
	  },
	  'draft-08': {
	    def: '$defs'
	  }
	};

	// logic: https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.B.1
	function jsonSchemaResolver (options) {
	  const ee = new EventEmitter();
	  const {
	    clone,
	    target,
	    applicationUri,
	    externalSchemas: rootExternalSchemas,
	    buildLocalReference
	  } = Object.assign({}, defaultOpts, options);

	  const allIds = new Map();
	  let rolling = 0;
	  ee.on('$id', collectIds);

	  const allRefs = [];
	  ee.on('$ref', collectRefs);

	  if (!targetSupported.includes(target)) {
	    throw new Error(`Unsupported JSON schema version ${target}`)
	  }

	  let defaultUri;
	  if (applicationUri) {
	    defaultUri = getRootUri(applicationUri);

	    if (rootExternalSchemas) {
	      for (const es of rootExternalSchemas) { mapIds(ee, defaultUri, es); }
	      debug('Processed root external schemas');
	    }
	  } else if (rootExternalSchemas) {
	    throw new Error('If you set root externalSchema, the applicationUri option is needed')
	  }

	  return {
	    resolve,
	    definitions () {
	      const defKey = targetCfg[target].def;
	      const x = { [defKey]: {} };
	      allIds.forEach((json, baseUri) => {
	        x[defKey][json[kRefToDef]] = json;
	      });
	      return x
	    }
	  }

	  function resolve (rootSchema, opts) {
	    const { externalSchemas } = opts || {};

	    if (!rootExternalSchemas) {
	      allIds.clear();
	    }
	    allRefs.length = 0;

	    if (clone) {
	      rootSchema = cloner(rootSchema);
	    }

	    const appUri = defaultUri || getRootUri(rootSchema.$id);
	    debug('Found app URI %o', appUri);

	    if (externalSchemas) {
	      for (const es of externalSchemas) { mapIds(ee, appUri, es); }
	      debug('Processed external schemas');
	    }

	    const baseUri = URI.serialize(appUri); // canonical absolute-URI
	    if (rootSchema.$id) {
	      rootSchema.$id = baseUri; // fix the schema $id value
	    }
	    Object.defineProperty(rootSchema, kIgnore, { value: true, enumerable: false });

	    mapIds(ee, appUri, rootSchema);
	    debug('Processed root schema');

	    debug('Generating %d refs', allRefs.length);
	    allRefs.forEach(({ baseUri, ref, refUri, json }) => {
	      debug('Evaluating $ref %s', ref);
	      if (ref[0] === '#') { return }

	      const evaluatedJson = allIds.get(baseUri);
	      if (!evaluatedJson) {
	        debug('External $ref %s not provided with baseUri %s', ref, baseUri);
	        return
	      }
	      Object.defineProperty(evaluatedJson, kConsumed, { value: true, enumerable: false });
	      json.$ref = `#/definitions/${evaluatedJson[kRefToDef]}${refUri.fragment || ''}`;
	    });

	    if (externalSchemas) {
	      // only if user sets external schema add it to the definitions
	      const defKey = targetCfg[target].def;
	      allIds.forEach((json, baseUri) => {
	        if (json[kConsumed] === true) {
	          if (!rootSchema[defKey]) {
	            rootSchema[defKey] = {};
	          }

	          rootSchema[defKey][json[kRefToDef]] = json;
	        }
	      });
	    }

	    return rootSchema
	  }

	  function collectIds (json, baseUri, fragment) {
	    if (json[kIgnore]) { return }

	    const rel = (fragment && URI.serialize(fragment)) || '';
	    const id = URI.serialize(baseUri) + rel;
	    if (!allIds.has(id)) {
	      debug('Collected $id %s', id);
	      const value = buildLocalReference(json, baseUri, fragment, rolling++);
	      Object.defineProperty(json, kRefToDef, { value, enumerable: false });
	      allIds.set(id, json);
	    } else {
	      debug('WARN duplicated id %s .. IGNORED - ', id);
	    }
	  }

	  function collectRefs (json, baseUri, refVal) {
	    const refUri = URI.parse(refVal);
	    debug('Pre enqueue $ref %o', refUri);

	    // "same-document";
	    // "relative";
	    // "absolute";
	    // "uri";
	    if (refUri.reference === 'relative') {
	      refUri.scheme = baseUri.scheme;
	      refUri.userinfo = baseUri.userinfo;
	      refUri.host = baseUri.host;
	      refUri.port = baseUri.port;

	      const newBaseUri = Object.assign({}, baseUri);
	      newBaseUri.path = refUri.path;
	      baseUri = newBaseUri;
	    } else if (refUri.reference === 'uri' || refUri.reference === 'absolute') {
	      baseUri = { ...refUri, fragment: undefined };
	    }

	    const ref = URI.serialize(refUri);
	    allRefs.push({
	      baseUri: URI.serialize(baseUri),
	      refUri,
	      ref,
	      json
	    });
	    debug('Enqueue $ref %s', ref);
	  }
	}

	/**
	   *
	   * @param {URI} baseUri
	   * @param {*} json
	   */
	function mapIds (ee, baseUri, json) {
	  if (!(json instanceof Object)) return

	  if (json.$id) {
	    const $idUri = URI.parse(json.$id);
	    let fragment = null;

	    if ($idUri.reference === 'absolute') {
	      // "$id": "http://example.com/root.json"
	      baseUri = $idUri; // a new baseURI for children
	    } else if ($idUri.reference === 'relative') {
	      // "$id": "other.json",
	      const newBaseUri = Object.assign({}, baseUri);
	      newBaseUri.path = $idUri.path;
	      newBaseUri.fragment = $idUri.fragment;
	      baseUri = newBaseUri;
	    } else {
	      // { "$id": "#bar" }
	      fragment = $idUri;
	    }
	    ee.emit('$id', json, baseUri, fragment);
	  }
	  // else if (json.$anchor) {
	  // TODO the $id should manage $anchor to support draft 08
	  // }

	  const fields = Object.keys(json);
	  for (const prop of fields) {
	    if (prop === '$ref') {
	      ee.emit('$ref', json, baseUri, json[prop]);
	    }
	    mapIds(ee, baseUri, json[prop]);
	  }
	}

	function getRootUri (strUri = 'application.uri') {
	  // If present, the value for this keyword MUST be a string, and MUST
	  // represent a valid URI-reference [RFC3986].  This value SHOULD be
	  // normalized, and SHOULD NOT be an empty fragment <#> or an empty
	  // string <>.
	  const uri = URI.parse(strUri);
	  uri.fragment = undefined;
	  return uri
	}

	refResolver = jsonSchemaResolver;
	return refResolver;
}

var addHook_1;
var hasRequiredAddHook;

function requireAddHook () {
	if (hasRequiredAddHook) return addHook_1;
	hasRequiredAddHook = 1;

	const Ref = requireRefResolver();
	const cloner = requireRfdc()({ proto: true, circles: false });

	function addHook (fastify, pluginOptions) {
	  const routes = [];
	  const sharedSchemasMap = new Map();
	  let hookRun = false;

	  fastify.addHook('onRoute', (routeOptions) => {
	    const routeConfig = routeOptions.config || {};
	    const swaggerConfig = routeConfig.swagger || {};
	    if (routeOptions.method === 'HEAD' && pluginOptions.exposeHeadRoutes !== true && swaggerConfig.exposeHeadRoute !== true) {
	      return
	    }

	    if (
	      routeOptions.method === 'HEAD' &&
	            routeOptions.schema !== undefined &&
	            routeOptions.schema.operationId !== undefined
	    ) {
	      routes.push(
	        // If two routes with operationId are added to the swagger
	        // object, it is no longer valid.
	        // therefore we suffix the operationId with `-head`.
	        Object.assign({}, routeOptions, {
	          schema: Object.assign({}, routeOptions.schema, {
	            operationId: `${routeOptions.schema.operationId}-head`
	          })
	        })
	      );
	      return
	    }

	    routes.push(routeOptions);
	  });

	  fastify.addHook('onRegister', async (instance) => {
	    // we need to wait the ready event to get all the .getSchemas()
	    // otherwise it will be empty
	    // TODO: better handle for schemaId
	    // when schemaId is the same in difference instance
	    // the latter will lost
	    instance.addHook('onReady', (done) => {
	      const allSchemas = instance.getSchemas();
	      for (const schemaId of Object.keys(allSchemas)) {
	        sharedSchemasMap.set(schemaId, allSchemas[schemaId]);
	      }
	      done();
	    });
	  });

	  fastify.addHook('onReady', (done) => {
	    hookRun = true;
	    const allSchemas = fastify.getSchemas();
	    for (const schemaId of Object.keys(allSchemas)) {
	      // it is the top-level, we do not expect to have duplicate id
	      sharedSchemasMap.set(schemaId, allSchemas[schemaId]);
	    }
	    done();
	  });

	  return {
	    routes,
	    Ref () {
	      if (hookRun === false) {
	        throw new Error('.swagger() must be called after .ready()')
	      }
	      const externalSchemas = cloner(Array.from(sharedSchemasMap.values()));
	      return Ref(Object.assign(
	        { applicationUri: 'todo.com' },
	        pluginOptions.refResolver,
	        { clone: true, externalSchemas })
	      )
	    }
	  }
	}

	addHook_1 = {
	  addHook
	};
	return addHook_1;
}

var shouldRouteHide_1;
var hasRequiredShouldRouteHide;

function requireShouldRouteHide () {
	if (hasRequiredShouldRouteHide) return shouldRouteHide_1;
	hasRequiredShouldRouteHide = 1;

	function shouldRouteHide (schema, opts) {
	  const { hiddenTag, hideUntagged } = opts;

	  if (schema?.hide) {
	    return true
	  }

	  const tags = schema?.tags || [];

	  if (tags.length === 0 && hideUntagged) {
	    return true
	  }

	  if (tags.includes(hiddenTag)) {
	    return schema.tags.includes(hiddenTag)
	  }

	  return false
	}

	shouldRouteHide_1 = {
	  shouldRouteHide
	};
	return shouldRouteHide_1;
}

var readPackageJson_1;
var hasRequiredReadPackageJson;

function requireReadPackageJson () {
	if (hasRequiredReadPackageJson) return readPackageJson_1;
	hasRequiredReadPackageJson = 1;

	const fs = require$$0$f;
	const path = require$$1$4;

	function readPackageJson () {
	  try {
	    return JSON.parse(fs.readFileSync(path.join(__dirname, '..', '..', 'package.json')))
	  } catch {
	    return {}
	  }
	}

	readPackageJson_1 = {
	  readPackageJson
	};
	return readPackageJson_1;
}

var symbols;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	const rawRequired = Symbol('@fastify/swagger.rawRequired');

	symbols = {
	  rawRequired
	};
	return symbols;
}

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	const xConsume = 'x-consume';
	const xResponseDescription = 'x-response-description';
	const xExamples = 'x-examples';

	constants$1 = {
	  xConsume,
	  xResponseDescription,
	  xExamples
	};
	return constants$1;
}

var resolveLocalRef_1;
var hasRequiredResolveLocalRef;

function requireResolveLocalRef () {
	if (hasRequiredResolveLocalRef) return resolveLocalRef_1;
	hasRequiredResolveLocalRef = 1;

	const { rawRequired } = requireSymbols();
	const { xConsume } = requireConstants$1();

	function resolveLocalRef (jsonSchema, externalSchemas) {
	  if (jsonSchema.type !== undefined && jsonSchema.properties !== undefined) {
	    // for the shorthand querystring/params/headers declaration
	    const propertiesMap = Object.keys(jsonSchema.properties).reduce((acc, headers) => {
	      const rewriteProps = {};
	      rewriteProps.required = (Array.isArray(jsonSchema.required) && jsonSchema.required.indexOf(headers) >= 0) || false;
	      // save raw required for next restore in the content/<media-type>
	      if (jsonSchema.properties[headers][xConsume]) {
	        rewriteProps[rawRequired] = jsonSchema.properties[headers].required;
	      }
	      const newProps = Object.assign({}, jsonSchema.properties[headers], rewriteProps);

	      return Object.assign({}, acc, { [headers]: newProps })
	    }, {});

	    return propertiesMap
	  }

	  // for oneOf, anyOf, allOf support in querystring/params/headers
	  if (jsonSchema.oneOf || jsonSchema.anyOf || jsonSchema.allOf) {
	    const schemas = jsonSchema.oneOf || jsonSchema.anyOf || jsonSchema.allOf;
	    return schemas.reduce((acc, schema) => Object.assign(acc, resolveLocalRef(schema, externalSchemas)), {})
	  }

	  // $ref is in the format: #/definitions/<resolved definition>/<optional fragment>
	  if (jsonSchema.$ref) {
	    const localRef = jsonSchema.$ref.split('/', 3)[2];
	    if (externalSchemas[localRef]) return resolveLocalRef(externalSchemas[localRef], externalSchemas)
	    // $ref is in the format: #/components/schemas/<resolved definition>
	    return resolveLocalRef(externalSchemas[jsonSchema.$ref.split('/', 4)[3]], externalSchemas)
	  }
	  return jsonSchema
	}

	resolveLocalRef_1 = {
	  resolveLocalRef
	};
	return resolveLocalRef_1;
}

var resolveSchemaReference_1;
var hasRequiredResolveSchemaReference;

function requireResolveSchemaReference () {
	if (hasRequiredResolveSchemaReference) return resolveSchemaReference_1;
	hasRequiredResolveSchemaReference = 1;

	function resolveSchemaReference (rawSchema, ref) {
	  const resolvedReference = ref.resolve(rawSchema, { externalSchemas: [ref.definitions().definitions] });

	  // Ref has format `#/definitions/id`
	  const schemaId = resolvedReference?.$ref?.split('/', 3)[2];

	  if (schemaId === undefined) {
	    return undefined
	  }

	  return resolvedReference.definitions?.[schemaId]
	}

	resolveSchemaReference_1 = {
	  resolveSchemaReference
	};
	return resolveSchemaReference_1;
}

var matchParams_1;
var hasRequiredMatchParams;

function requireMatchParams () {
	if (hasRequiredMatchParams) return matchParams_1;
	hasRequiredMatchParams = 1;

	const paramPattern = /\{[^{}]+\}/gu;

	function hasParams (url) {
	  if (!url) return false
	  return paramPattern.test(url)
	}

	function matchParams (url) {
	  if (!url) return []
	  return url.match(paramPattern) || []
	}

	matchParams_1 = {
	  hasParams,
	  matchParams
	};
	return matchParams_1;
}

var generateParamsSchema_1;
var hasRequiredGenerateParamsSchema;

function requireGenerateParamsSchema () {
	if (hasRequiredGenerateParamsSchema) return generateParamsSchema_1;
	hasRequiredGenerateParamsSchema = 1;

	const { matchParams } = requireMatchParams();

	const namePattern = /\{([^{}]+)\}/u;

	function paramName (param) {
	  return param.replace(namePattern, (_, captured) => captured)
	}

	// Generates default parameters schema from the given URL. (ex: /example/{userId})
	function generateParamsSchema (url) {
	  const params = matchParams(url);
	  const schema = {
	    params: {
	      type: 'object',
	      properties: {}
	    }
	  };

	  schema.params.properties = params.reduce((acc, param) => {
	    const name = paramName(param);
	    acc[name] = {
	      type: 'string'
	    };
	    return acc
	  }, {});

	  return schema
	}

	generateParamsSchema_1 = {
	  generateParamsSchema,
	  paramName
	};
	return generateParamsSchema_1;
}

var utils$1;
var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;

	const { readPackageJson } = requireReadPackageJson();
	const { formatParamUrl } = requireFormatParamUrl();
	const { resolveLocalRef } = requireResolveLocalRef();
	const { resolveSchemaReference } = requireResolveSchemaReference();
	const { xResponseDescription, xConsume } = requireConstants$1();
	const { generateParamsSchema } = requireGenerateParamsSchema();
	const { hasParams } = requireMatchParams();

	function prepareDefaultOptions (opts) {
	  const swagger = opts.swagger;
	  const info = swagger.info || null;
	  const host = swagger.host || null;
	  const schemes = swagger.schemes || null;
	  const consumes = swagger.consumes || null;
	  const produces = swagger.produces || null;
	  const definitions = swagger.definitions || null;
	  const paths = swagger.paths || null;
	  const basePath = swagger.basePath || null;
	  const securityDefinitions = swagger.securityDefinitions || null;
	  const security = swagger.security || null;
	  const tags = swagger.tags || null;
	  const externalDocs = swagger.externalDocs || null;
	  const stripBasePath = opts.stripBasePath;
	  const transform = opts.transform;
	  const transformObject = opts.transformObject;
	  const hiddenTag = opts.hiddenTag;
	  const hideUntagged = opts.hideUntagged;
	  const extensions = [];

	  for (const [key, value] of Object.entries(opts.swagger)) {
	    if (key.startsWith('x-')) {
	      extensions.push([key, value]);
	    }
	  }

	  return {
	    info,
	    host,
	    schemes,
	    consumes,
	    produces,
	    definitions,
	    paths,
	    basePath,
	    securityDefinitions,
	    security,
	    tags,
	    externalDocs,
	    stripBasePath,
	    transform,
	    transformObject,
	    hiddenTag,
	    extensions,
	    hideUntagged
	  }
	}

	function prepareSwaggerObject (opts) {
	  const pkg = readPackageJson();
	  const swaggerObject = {
	    swagger: '2.0',
	    info: {
	      version: pkg.version || '1.0.0',
	      title: pkg.name || ''
	    },
	    definitions: {},
	    paths: {}
	  };

	  if (opts.info) swaggerObject.info = opts.info;
	  if (opts.host) swaggerObject.host = opts.host;
	  if (opts.schemes) swaggerObject.schemes = opts.schemes;
	  if (opts.basePath) swaggerObject.basePath = opts.basePath;
	  if (opts.consumes) swaggerObject.consumes = opts.consumes;
	  if (opts.produces) swaggerObject.produces = opts.produces;
	  if (opts.definitions) swaggerObject.definitions = opts.definitions;
	  if (opts.paths) swaggerObject.paths = opts.paths;
	  if (opts.securityDefinitions) swaggerObject.securityDefinitions = opts.securityDefinitions;
	  if (opts.security) swaggerObject.security = opts.security;
	  if (opts.tags) swaggerObject.tags = opts.tags;
	  if (opts.externalDocs) swaggerObject.externalDocs = opts.externalDocs;

	  for (const [key, value] of opts.extensions) {
	    // "x-" extension can not be typed
	    swaggerObject[key] = value;
	  }

	  return swaggerObject
	}

	function normalizeUrl (url, basePath, stripBasePath) {
	  let path;
	  if (stripBasePath && url.startsWith(basePath)) {
	    path = url.replace(basePath, '');
	  } else {
	    path = url;
	  }
	  if (!path.startsWith('/')) {
	    path = '/' + String(path);
	  }
	  return formatParamUrl(path)
	}

	// For supported keys read:
	// https://swagger.io/docs/specification/2-0/describing-parameters/
	function plainJsonObjectToSwagger2 (container, jsonSchema, externalSchemas, securityIgnores = []) {
	  const obj = resolveLocalRef(jsonSchema, externalSchemas);
	  let toSwaggerProp;
	  switch (container) {
	    case 'header':
	    case 'query':
	      toSwaggerProp = function (propertyName, jsonSchemaElement) {
	        // complex serialization is not supported by swagger
	        if (jsonSchemaElement[xConsume]) {
	          throw new Error('Complex serialization is not supported by Swagger. ' +
	            'Remove "' + xConsume + '" for "' + propertyName + '" querystring/header schema or ' +
	            'change specification to OpenAPI')
	        }
	        jsonSchemaElement.in = container;
	        jsonSchemaElement.name = propertyName;
	        return jsonSchemaElement
	      };
	      break
	    case 'formData':
	      toSwaggerProp = function (propertyName, jsonSchemaElement) {
	        delete jsonSchemaElement.$id;
	        jsonSchemaElement.in = container;
	        jsonSchemaElement.name = propertyName;

	        // https://json-schema.org/understanding-json-schema/reference/non_json_data.html#contentencoding
	        if (jsonSchemaElement.contentEncoding === 'binary') {
	          delete jsonSchemaElement.contentEncoding; // Must be removed
	          jsonSchemaElement.type = 'file';
	        }

	        return jsonSchemaElement
	      };
	      break
	    case 'path':
	      toSwaggerProp = function (propertyName, jsonSchemaElement) {
	        jsonSchemaElement.in = container;
	        jsonSchemaElement.name = propertyName;
	        jsonSchemaElement.required = true;
	        return jsonSchemaElement
	      };
	      break
	  }

	  return Object.keys(obj)
	    .filter((propKey) => (!securityIgnores.includes(propKey)))
	    .map((propKey) => {
	      return toSwaggerProp(propKey, obj[propKey])
	    })
	}

	/*
	* Map  unsupported JSON schema definitions to Swagger definitions
	*/
	function replaceUnsupported (jsonSchema) {
	  if (typeof jsonSchema === 'object' && jsonSchema !== null) {
	    // Handle patternProperties, that is not part of OpenAPI definitions
	    if (jsonSchema.patternProperties) {
	      jsonSchema.additionalProperties = { type: 'string' };
	      delete jsonSchema.patternProperties;
	    } else if (jsonSchema.const !== undefined) {
	      // Handle const, that is not part of OpenAPI definitions
	      jsonSchema.enum = [jsonSchema.const];
	      delete jsonSchema.const;
	    }

	    Object.keys(jsonSchema).forEach(function (key) {
	      jsonSchema[key] = replaceUnsupported(jsonSchema[key]);
	    });
	  }

	  return jsonSchema
	}

	function isConsumesFormOnly (schema) {
	  const consumes = schema.consumes;
	  return (
	    consumes &&
	      consumes.length === 1 &&
	      (consumes[0] === 'application/x-www-form-urlencoded' ||
	        consumes[0] === 'multipart/form-data')
	  )
	}

	function resolveBodyParams (parameters, schema, ref) {
	  const resolved = ref.resolve(schema);
	  replaceUnsupported(resolved);

	  parameters.push({
	    name: 'body',
	    in: 'body',
	    description: resolved?.description,
	    schema: resolved
	  });
	}

	function resolveCommonParams (container, parameters, schema, ref, sharedSchemas, securityIgnores) {
	  const resolved = ref.resolve(schema);
	  const arr = plainJsonObjectToSwagger2(container, resolved, sharedSchemas, securityIgnores);
	  arr.forEach(swaggerSchema => parameters.push(swaggerSchema));
	}

	function findReferenceDescription (rawSchema, ref) {
	  const resolved = resolveSchemaReference(rawSchema, ref);
	  return resolved?.description
	}

	// https://swagger.io/docs/specification/2-0/describing-responses/
	function resolveResponse (fastifyResponseJson, ref) {
	  // if the user does not provided an out schema
	  if (!fastifyResponseJson) {
	    return { 200: { description: 'Default Response' } }
	  }

	  const responsesContainer = {};

	  const statusCodes = Object.keys(fastifyResponseJson);

	  statusCodes.forEach(statusCode => {
	    const rawJsonSchema = fastifyResponseJson[statusCode];
	    const resolved = ref.resolve(rawJsonSchema);

	    delete resolved.$schema;

	    // 2xx is not supported by swagger
	    const deXXStatusCode = statusCode.toUpperCase().replace('XX', '00');
	    // conflict when we have both 2xx and 200
	    if (statusCode.toUpperCase().includes('XX') && statusCodes.includes(deXXStatusCode)) {
	      return
	    }

	    // converts statusCode to upper case only when it is not "default"
	    if (statusCode !== 'default') {
	      statusCode = deXXStatusCode;
	    }

	    const response = {
	      description: rawJsonSchema[xResponseDescription] ||
	        rawJsonSchema.description ||
	        findReferenceDescription(rawJsonSchema, ref) ||
	        'Default Response'
	    };

	    // add headers when there are any.
	    if (rawJsonSchema.headers) {
	      response.headers = rawJsonSchema.headers;
	      // remove invalid field
	      delete resolved.headers;
	    }

	    // add schema when type is not 'null'
	    if (rawJsonSchema.type !== 'null') {
	      const schema = { ...resolved };
	      replaceUnsupported(schema);
	      delete schema[xResponseDescription];
	      response.schema = schema;
	    }

	    responsesContainer[statusCode] = response;
	  });

	  return responsesContainer
	}

	function prepareSwaggerMethod (schema, ref, swaggerObject, url) {
	  const swaggerMethod = {};
	  const parameters = [];

	  // Parse out the security prop keys to ignore
	  const securityIgnores = [
	    ...(swaggerObject?.security || []),
	    ...(schema?.security || [])
	  ]
	    .reduce((acc, securitySchemeGroup) => {
	      Object.keys(securitySchemeGroup).forEach((securitySchemeLabel) => {
	        const { name, in: category } = swaggerObject.securityDefinitions[securitySchemeLabel];
	        if (!acc[category]) {
	          acc[category] = [];
	        }
	        acc[category].push(name);
	      });
	      return acc
	    }, {});

	  // All the data the user can give us, is via the schema object
	  if (schema) {
	    if (schema.operationId) swaggerMethod.operationId = schema.operationId;
	    if (schema.summary) swaggerMethod.summary = schema.summary;
	    if (schema.description) swaggerMethod.description = schema.description;
	    if (schema.externalDocs) swaggerMethod.externalDocs = schema.externalDocs;
	    if (schema.tags) swaggerMethod.tags = schema.tags;
	    if (schema.produces) swaggerMethod.produces = schema.produces;
	    if (schema.consumes) swaggerMethod.consumes = schema.consumes;
	    if (schema.querystring) resolveCommonParams('query', parameters, schema.querystring, ref, swaggerObject.definitions, securityIgnores.query);
	    if (schema.body) {
	      const isConsumesAllFormOnly = isConsumesFormOnly(schema) || isConsumesFormOnly(swaggerObject);
	      isConsumesAllFormOnly
	        ? resolveCommonParams('formData', parameters, schema.body, ref, swaggerObject.definitions)
	        : resolveBodyParams(parameters, schema.body, ref);
	    }
	    if (schema.params) resolveCommonParams('path', parameters, schema.params, ref, swaggerObject.definitions);
	    if (schema.headers) resolveCommonParams('header', parameters, schema.headers, ref, swaggerObject.definitions, securityIgnores.header);
	    if (parameters.length > 0) swaggerMethod.parameters = parameters;
	    if (schema.deprecated) swaggerMethod.deprecated = schema.deprecated;
	    if (schema.security) swaggerMethod.security = schema.security;
	    for (const key of Object.keys(schema)) {
	      if (key.startsWith('x-')) {
	        swaggerMethod[key] = schema[key];
	      }
	    }
	  }

	  // If there is no schema or schema.params, we need to generate them
	  if ((!schema || !schema.params) && hasParams(url)) {
	    const schemaGenerated = generateParamsSchema(url);
	    resolveCommonParams('path', parameters, schemaGenerated.params, ref, swaggerObject.definitions);
	    swaggerMethod.parameters = parameters;
	  }

	  swaggerMethod.responses = resolveResponse(schema ? schema.response : null, ref);

	  return swaggerMethod
	}

	function prepareSwaggerDefinitions (definitions, ref) {
	  return Object.entries(definitions)
	    .reduce((res, [name, definition]) => {
	      const _ = { ...definition };
	      const resolved = ref.resolve(_, { externalSchemas: [definitions] });

	      // Swagger doesn't accept $id on /definitions schemas.
	      // The $ids are needed by Ref() to check the URI so we need
	      // to remove them at the end of the process
	      delete resolved.$id;
	      delete resolved.definitions;

	      res[name] = resolved;
	      return res
	    }, {})
	}

	utils$1 = {
	  prepareDefaultOptions,
	  prepareSwaggerObject,
	  prepareSwaggerMethod,
	  normalizeUrl,
	  prepareSwaggerDefinitions
	};
	return utils$1;
}

var swagger;
var hasRequiredSwagger$1;

function requireSwagger$1 () {
	if (hasRequiredSwagger$1) return swagger;
	hasRequiredSwagger$1 = 1;

	const yaml = require$$1;
	const { shouldRouteHide } = requireShouldRouteHide();
	const { prepareDefaultOptions, prepareSwaggerObject, prepareSwaggerMethod, normalizeUrl, prepareSwaggerDefinitions } = requireUtils$1();

	swagger = function (opts, cache, routes, Ref, done) {
	  let ref;

	  const defOpts = prepareDefaultOptions(opts);

	  return function (opts) {
	    if (opts?.yaml) {
	      if (cache.string) return cache.string
	    } else {
	      if (cache.object) return cache.object
	    }

	    const swaggerObject = prepareSwaggerObject(defOpts, done);

	    ref = Ref();
	    swaggerObject.definitions = prepareSwaggerDefinitions({
	      ...swaggerObject.definitions,
	      ...(ref.definitions().definitions)
	    }, ref);

	    for (const route of routes) {
	      const transformResult = route.config?.swaggerTransform !== undefined
	        ? route.config.swaggerTransform
	          ? route.config.swaggerTransform({ schema: route.schema, url: route.url, route, swaggerObject })
	          : {}
	        : defOpts.transform
	          ? defOpts.transform({ schema: route.schema, url: route.url, route, swaggerObject })
	          : {};

	      const schema = transformResult.schema || route.schema;
	      const shouldRouteHideOpts = {
	        hiddenTag: defOpts.hiddenTag,
	        hideUntagged: defOpts.hideUntagged
	      };

	      if (shouldRouteHide(schema, shouldRouteHideOpts)) continue

	      let url = transformResult.url || route.url;
	      url = normalizeUrl(url, defOpts.basePath, defOpts.stripBasePath);

	      const swaggerRoute = Object.assign({}, swaggerObject.paths[url]);

	      const swaggerMethod = prepareSwaggerMethod(schema, ref, swaggerObject, url);

	      if (route.links) {
	        throw new Error('Swagger (Open API v2) does not support Links. Upgrade to OpenAPI v3 (see @fastify/swagger readme)')
	      }

	      // route.method should be either a String, like 'POST', or an Array of Strings, like ['POST','PUT','PATCH']
	      const methods = typeof route.method === 'string' ? [route.method] : route.method;

	      for (const method of methods) {
	        swaggerRoute[method.toLowerCase()] = swaggerMethod;
	      }

	      swaggerObject.paths[url] = swaggerRoute;
	    }

	    const transformObjectResult = defOpts.transformObject
	      ? defOpts.transformObject({ swaggerObject })
	      : swaggerObject;

	    if (opts?.yaml) {
	      cache.string = yaml.stringify(transformObjectResult, { strict: false });
	      return cache.string
	    }

	    cache.object = transformObjectResult;
	    return cache.object
	  }
	};
	return swagger;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	const { readPackageJson } = requireReadPackageJson();
	const { formatParamUrl } = requireFormatParamUrl();
	const { resolveLocalRef } = requireResolveLocalRef();
	const { resolveSchemaReference } = requireResolveSchemaReference();
	const { xResponseDescription, xConsume, xExamples } = requireConstants$1();
	const { rawRequired } = requireSymbols();
	const { generateParamsSchema } = requireGenerateParamsSchema();
	const { hasParams } = requireMatchParams();

	function prepareDefaultOptions (opts) {
	  const openapi = opts.openapi;
	  const info = openapi.info || null;
	  const servers = openapi.servers || null;
	  const components = openapi.components || null;
	  const security = openapi.security || null;
	  const tags = openapi.tags || null;
	  const externalDocs = openapi.externalDocs || null;
	  const stripBasePath = opts.stripBasePath;
	  const transform = opts.transform;
	  const transformObject = opts.transformObject;
	  const hiddenTag = opts.hiddenTag;
	  const hideUntagged = opts.hideUntagged;
	  const extensions = [];

	  for (const [key, value] of Object.entries(opts.openapi)) {
	    if (key.startsWith('x-')) {
	      extensions.push([key, value]);
	    }
	  }

	  return {
	    ...openapi,
	    info,
	    servers,
	    components,
	    security,
	    tags,
	    externalDocs,
	    stripBasePath,
	    transform,
	    transformObject,
	    hiddenTag,
	    extensions,
	    hideUntagged
	  }
	}

	function prepareOpenapiObject (opts) {
	  const pkg = readPackageJson();
	  const openapiObject = {
	    openapi: '3.0.3',
	    info: {
	      version: pkg.version || '1.0.0',
	      title: pkg.name || ''
	    },
	    components: { schemas: {} },
	    paths: {}
	  };

	  if (opts.openapi) openapiObject.openapi = opts.openapi;
	  if (opts.info) openapiObject.info = opts.info;
	  if (opts.servers) openapiObject.servers = opts.servers;
	  if (opts.components) openapiObject.components = Object.assign({}, opts.components, { schemas: Object.assign({}, opts.components.schemas) });
	  if (opts.paths) openapiObject.paths = opts.paths;
	  if (opts.webhooks) openapiObject.webhooks = opts.webhooks;
	  if (opts.security) openapiObject.security = opts.security;
	  if (opts.tags) openapiObject.tags = opts.tags;
	  if (opts.externalDocs) openapiObject.externalDocs = opts.externalDocs;

	  for (const [key, value] of opts.extensions) {
	    // "x-" extension can not be typed
	    openapiObject[key] = value;
	  }

	  return openapiObject
	}

	function normalizeUrl (url, serverUrls, stripBasePath) {
	  if (!stripBasePath) return formatParamUrl(url)
	  serverUrls.forEach(function (serverUrl) {
	    const basePath = serverUrl.startsWith('/') ? serverUrl : new URL(serverUrl).pathname;
	    if (url.startsWith(basePath) && basePath !== '/') {
	      url = url.replace(basePath, '');
	    }
	  });
	  return formatParamUrl(url)
	}

	function resolveServerUrls (servers) {
	  const resolvedUrls = [];
	  const findVariablesRegex = /\{([^{}]+)\}/gu; // As for OpenAPI v3 spec url variables are named in brackets, e.g. {foo}

	  servers = Array.isArray(servers) ? servers : [];
	  for (const server of servers) {
	    const originalUrl = server.url;
	    const variables = server.variables;

	    let url = originalUrl;
	    const matches = url.matchAll(findVariablesRegex);

	    for (const [nameInBrackets, name] of matches) {
	      const value = variables?.[name]?.default;

	      if (value === undefined) {
	        throw new Error(`Server URL ${originalUrl} could not be resolved. Make sure to provide a default value for each URL variable.`)
	      }

	      url = url.replace(nameInBrackets, value);
	    }

	    resolvedUrls.push(url);
	  }

	  return resolvedUrls
	}

	function convertExamplesArrayToObject (examples) {
	  return examples.reduce((examplesObject, example, index) => {
	    if (typeof example === 'object') {
	      examplesObject['example' + (index + 1)] = { value: example };
	    } else {
	      examplesObject[example] = { value: example };
	    }

	    return examplesObject
	  }, {})
	}

	// For supported keys read:
	// https://swagger.io/docs/specification/describing-parameters/
	function plainJsonObjectToOpenapi3 (container, jsonSchema, externalSchemas, securityIgnores = []) {
	  const obj = convertJsonSchemaToOpenapi3(resolveLocalRef(jsonSchema, externalSchemas));
	  let toOpenapiProp;
	  switch (container) {
	    case 'cookie':
	    case 'header':
	    case 'query':
	      toOpenapiProp = function (propertyName, jsonSchemaElement) {
	        let result = {
	          in: container,
	          name: propertyName,
	          required: jsonSchemaElement.required
	        };

	        const media = schemaToMedia(jsonSchemaElement);

	        // complex serialization in query or cookie, eg. JSON
	        // https://swagger.io/docs/specification/describing-parameters/#schema-vs-content
	        if (jsonSchemaElement[xConsume]) {
	          media.schema.required = jsonSchemaElement[rawRequired];

	          result.content = {
	            [jsonSchemaElement[xConsume]]: media
	          };

	          delete result.content[jsonSchemaElement[xConsume]].schema[xConsume];
	        } else {
	          result = { ...media, ...result };
	        }
	        // description should be optional
	        if (jsonSchemaElement.description) result.description = jsonSchemaElement.description;
	        // optionally add serialization format style
	        if (jsonSchema.style) result.style = jsonSchema.style;
	        if (jsonSchema.explode != null) result.explode = jsonSchema.explode;
	        if (jsonSchema.allowReserved === true && container === 'query') {
	          result.allowReserved = jsonSchema.allowReserved;
	        }
	        return result
	      };
	      break
	    case 'path':
	      toOpenapiProp = function (propertyName, jsonSchemaElement) {
	        const media = schemaToMedia(jsonSchemaElement);

	        const result = {
	          ...media,
	          in: container,
	          name: propertyName,
	          required: true
	        };

	        // description should be optional
	        if (jsonSchemaElement.description) result.description = jsonSchemaElement.description;
	        return result
	      };
	      break
	  }

	  return Object.keys(obj)
	    .filter((propKey) => (!securityIgnores.includes(propKey)))
	    .map((propKey) => {
	      const jsonSchema = toOpenapiProp(propKey, obj[propKey]);
	      if (jsonSchema.schema) {
	        // it is needed as required in schema is invalid prop - delete only if needed
	        if (jsonSchema.schema.required !== undefined) delete jsonSchema.schema.required;
	        // it is needed as description in schema is invalid prop - delete only if needed
	        if (jsonSchema.schema.description !== undefined) delete jsonSchema.schema.description;
	      }
	      return jsonSchema
	    })
	}

	const schemaTypeToNestedSchemas = {
	  object: (schema) => {
	    return [
	      ...Object.values(schema.properties || {}),
	      ...Object.values(schema.patternProperties || {}),
	      ...Object.values(schema.additionalProperties || {})
	    ]
	  },
	  array: (schema) => {
	    return [
	      ...(schema.items ? [schema.items] : []),
	      ...(schema.contains ? [schema.contains] : [])
	    ]
	  }
	};

	function resolveSchemaExamples (schema) {
	  const example = schema[xExamples] ?? schema.examples?.[0];
	  if (typeof example !== 'undefined') {
	    schema.example = example;
	  }
	  delete schema[xExamples];
	  delete schema.examples;
	}

	function resolveSchemaExamplesRecursive (schema) {
	  resolveSchemaExamples(schema);
	  const getNestedSchemas = schemaTypeToNestedSchemas[schema.type];
	  const nestedSchemas = getNestedSchemas?.(schema) ?? [];
	  for (const nestedSchema of nestedSchemas) {
	    resolveSchemaExamplesRecursive(nestedSchema);
	  }
	}

	function schemaToMedia (schema) {
	  const media = { schema };

	  if (schema.examples?.length === 1) {
	    media.example = schema.examples[0];
	    delete schema.examples;
	  } else if (schema.examples?.length > 1) {
	    media.examples = convertExamplesArrayToObject(schema.examples);
	    // examples is invalid property of media object schema
	    delete schema.examples;
	  }

	  if (schema[xExamples]) {
	    media.examples = schema[xExamples];
	    delete schema[xExamples];
	  }

	  return media
	}

	function schemaToMediaRecursive (schema) {
	  const media = schemaToMedia(schema);
	  resolveSchemaExamplesRecursive(schema);
	  return media
	}

	function resolveBodyParams (body, schema, consumes, ref) {
	  const resolved = convertJsonSchemaToOpenapi3(ref.resolve(schema));

	  if (resolved.content?.[Object.keys(resolved.content)[0]].schema) {
	    for (const contentType in schema.content) {
	      body.content[contentType] = schemaToMediaRecursive(resolved.content[contentType].schema);
	    }
	  } else {
	    if ((Array.isArray(consumes) && consumes.length === 0) || consumes === undefined) {
	      consumes = ['application/json'];
	    }

	    const media = schemaToMediaRecursive(resolved);
	    consumes.forEach((consume) => {
	      body.content[consume] = media;
	    });

	    if (resolved?.required?.length) {
	      body.required = true;
	    }

	    if (resolved?.description) {
	      body.description = resolved.description;
	    }
	  }
	}

	function resolveCommonParams (container, parameters, schema, ref, sharedSchemas, securityIgnores) {
	  const schemasPath = '#/components/schemas/';
	  let resolved = convertJsonSchemaToOpenapi3(ref.resolve(schema));

	  // if the resolved definition is in global schema
	  if (resolved.$ref?.startsWith(schemasPath)) {
	    const parts = resolved.$ref.split(schemasPath);
	    const pathParts = parts[1].split('/');
	    resolved = pathParts.reduce((resolved, pathPart) => resolved[pathPart], ref.definitions().definitions);
	  }

	  const arr = plainJsonObjectToOpenapi3(container, resolved, { ...sharedSchemas, ...ref.definitions().definitions }, securityIgnores);
	  arr.forEach(swaggerSchema => parameters.push(swaggerSchema));
	}

	function findReferenceDescription (rawSchema, ref) {
	  const resolved = resolveSchemaReference(rawSchema, ref);
	  return resolved?.description
	}

	// https://swagger.io/docs/specification/describing-responses/
	function resolveResponse (fastifyResponseJson, produces, ref) {
	  // if the user does not provided an out schema
	  if (!fastifyResponseJson) {
	    return { 200: { description: 'Default Response' } }
	  }

	  const responsesContainer = {};

	  const statusCodes = Object.keys(fastifyResponseJson);

	  statusCodes.forEach(statusCode => {
	    const rawJsonSchema = fastifyResponseJson[statusCode];
	    const resolved = convertJsonSchemaToOpenapi3(ref.resolve(rawJsonSchema));

	    /**
	     * 2xx require to be all upper-case
	     * converts statusCode to upper case only when it is not "default"
	     */
	    if (statusCode !== 'default') {
	      statusCode = statusCode.toUpperCase();
	    }

	    const response = {
	      description: resolved[xResponseDescription] ||
	        rawJsonSchema.description ||
	        findReferenceDescription(rawJsonSchema, ref) ||
	        'Default Response'
	    };

	    // add headers when there are any.
	    if (rawJsonSchema.headers) {
	      response.headers = {};
	      Object.keys(rawJsonSchema.headers).forEach(function (key) {
	        const header = {
	          schema: { ...rawJsonSchema.headers[key] }
	        };

	        if (rawJsonSchema.headers[key].description) {
	          header.description = rawJsonSchema.headers[key].description;
	          // remove invalid field
	          delete header.schema.description;
	        }

	        response.headers[key] = header;
	      });
	      // remove invalid field
	      delete resolved.headers;
	    }

	    // add schema when type is not 'null'
	    if (rawJsonSchema.type !== 'null') {
	      if (resolved.content?.[Object.keys(resolved.content)[0]].schema) {
	        response.content = resolved.content;
	      } else {
	        const content = {};

	        if ((Array.isArray(produces) && produces.length === 0) || produces === undefined) {
	          produces = ['application/json'];
	        }

	        delete resolved[xResponseDescription];

	        const media = schemaToMediaRecursive(resolved);

	        for (const produce of produces) {
	          content[produce] = media;
	        }

	        response.content = content;
	      }
	    }

	    responsesContainer[statusCode] = response;
	  });

	  return responsesContainer
	}

	function resolveCallbacks (schema, ref) {
	  const callbacksContainer = {};

	  // Iterate over each callback event
	  for (const eventName in schema) {
	    if (!schema[eventName]) {
	      continue
	    }

	    // Create an empty object to house the future iterations
	    callbacksContainer[eventName] = {};
	    const eventSchema = schema[eventName];

	    // Iterate over each callbackUrl for the event
	    for (const callbackUrl in eventSchema) {
	      if (!callbackUrl || !eventSchema[callbackUrl]) {
	        continue
	      }

	      // Create an empty object to house the future iterations
	      callbacksContainer[eventName][callbackUrl] = {};
	      const callbackSchema = eventSchema[callbackUrl];

	      // Iterate over each httpMethod for the callbackUrl
	      for (const httpMethodName in callbackSchema) {
	        if (!httpMethodName || !callbackSchema[httpMethodName]) {
	          continue
	        }

	        const httpMethodSchema = callbackSchema[httpMethodName];
	        const httpMethodContainer = {};

	        if (httpMethodSchema.requestBody) {
	          httpMethodContainer.requestBody = convertJsonSchemaToOpenapi3(
	            ref.resolve(httpMethodSchema.requestBody)
	          );
	        }

	        // If a response is not provided, set a 2XX default response
	        httpMethodContainer.responses = httpMethodSchema.responses
	          ? convertJsonSchemaToOpenapi3(ref.resolve(httpMethodSchema.responses))
	          : { '2XX': { description: 'Default Response' } };

	        // Set the schema at the appropriate location in the response object
	        callbacksContainer[eventName][callbackUrl][httpMethodName] = httpMethodContainer;
	      }
	    }
	  }

	  return callbacksContainer
	}

	function prepareOpenapiMethod (schema, ref, openapiObject, url) {
	  const openapiMethod = {};
	  const parameters = [];

	  // Parse out the security prop keys to ignore
	  const securityIgnores = [
	    ...(openapiObject?.security || []),
	    ...(schema?.security || [])
	  ]
	    .reduce((acc, securitySchemeGroup) => {
	      Object.keys(securitySchemeGroup).forEach((securitySchemeLabel) => {
	        const scheme = openapiObject.components.securitySchemes[securitySchemeLabel];
	        const isBearer = scheme.type === 'http' && scheme.scheme === 'bearer';
	        const category = isBearer ? 'header' : scheme.in;
	        const name = isBearer ? 'authorization' : scheme.name;
	        if (!acc[category]) {
	          acc[category] = [];
	        }
	        acc[category].push(name);
	      });
	      return acc
	    }, {});

	  // All the data the user can give us, is via the schema object
	  if (schema) {
	    if (schema.operationId) openapiMethod.operationId = schema.operationId;
	    if (schema.summary) openapiMethod.summary = schema.summary;
	    if (schema.tags) openapiMethod.tags = schema.tags;
	    if (schema.description) openapiMethod.description = schema.description;
	    if (schema.externalDocs) openapiMethod.externalDocs = schema.externalDocs;
	    if (schema.querystring) resolveCommonParams('query', parameters, schema.querystring, ref, openapiObject.definitions, securityIgnores.query);
	    if (schema.body) {
	      openapiMethod.requestBody = { content: {} };
	      resolveBodyParams(openapiMethod.requestBody, schema.body, schema.consumes, ref);
	    }
	    if (schema.params) resolveCommonParams('path', parameters, schema.params, ref, openapiObject.definitions);
	    if (schema.headers) resolveCommonParams('header', parameters, schema.headers, ref, openapiObject.definitions, securityIgnores.header);
	    // TODO: need to documentation, we treat it same as the querystring
	    // fastify do not support cookies schema in first place
	    if (schema.cookies) resolveCommonParams('cookie', parameters, schema.cookies, ref, openapiObject.definitions, securityIgnores.cookie);
	    if (parameters.length > 0) openapiMethod.parameters = parameters;
	    if (schema.deprecated) openapiMethod.deprecated = schema.deprecated;
	    if (schema.security) openapiMethod.security = schema.security;
	    if (schema.servers) openapiMethod.servers = schema.servers;
	    if (schema.callbacks) openapiMethod.callbacks = resolveCallbacks(schema.callbacks, ref);
	    for (const key of Object.keys(schema)) {
	      if (key.startsWith('x-')) {
	        openapiMethod[key] = schema[key];
	      }
	    }
	  }

	  // If there is no schema or schema.params, we need to generate them
	  if ((!schema || !schema.params) && hasParams(url)) {
	    const schemaGenerated = generateParamsSchema(url);
	    resolveCommonParams('path', parameters, schemaGenerated.params, ref, openapiObject.definitions);
	    openapiMethod.parameters = parameters;
	  }

	  openapiMethod.responses = resolveResponse(schema ? schema.response : null, schema ? schema.produces : null, ref);

	  return openapiMethod
	}

	function convertJsonSchemaToOpenapi3 (jsonSchema) {
	  if (typeof jsonSchema !== 'object' || jsonSchema === null) {
	    return jsonSchema
	  }

	  if (Array.isArray(jsonSchema)) {
	    return jsonSchema.map(convertJsonSchemaToOpenapi3)
	  }

	  const openapiSchema = { ...jsonSchema };

	  for (const key of Object.keys(openapiSchema)) {
	    const value = openapiSchema[key];

	    if (key === '$id' || key === '$schema' || key === 'definitions') {
	      // TODO: this breaks references to the definition properties
	      delete openapiSchema[key];
	      continue
	    }

	    if (key === '$ref') {
	      openapiSchema.$ref = value.replace('definitions', 'components/schemas');
	      continue
	    }

	    if (key === 'const') {
	      // OAS 3.1 supports `const` but it is not supported by `swagger-ui`
	      // https://swagger.io/docs/specification/data-models/keywords/
	      // TODO: check if enum property already exists
	      // TODO: this breaks references to the const property
	      openapiSchema.enum = [openapiSchema.const];
	      delete openapiSchema.const;
	      continue
	    }

	    if (key === 'patternProperties') {
	      // TODO: check if additionalProperties property already exists
	      // TODO: this breaks references to the additionalProperties properties
	      // TODO: patternProperties actually allowed in the openapi schema, but should
	      // always start with "x-" prefix
	      const propertyJsonSchema = Object.values(openapiSchema.patternProperties)[0];
	      const propertyOpenapiSchema = convertJsonSchemaToOpenapi3(propertyJsonSchema);
	      openapiSchema.additionalProperties = propertyOpenapiSchema;
	      delete openapiSchema.patternProperties;
	      continue
	    }

	    if (key === 'properties') {
	      openapiSchema[key] = {};
	      for (const propertyName of Object.keys(value)) {
	        const propertyJsonSchema = value[propertyName];
	        const propertyOpenapiSchema = convertJsonSchemaToOpenapi3(propertyJsonSchema);
	        openapiSchema[key][propertyName] = propertyOpenapiSchema;
	      }
	      continue
	    }

	    openapiSchema[key] = convertJsonSchemaToOpenapi3(value);
	  }

	  return openapiSchema
	}

	function prepareOpenapiSchemas (jsonSchemas, ref) {
	  const openapiSchemas = {};

	  for (const schemaName of Object.keys(jsonSchemas)) {
	    const jsonSchema = { ...jsonSchemas[schemaName] };

	    const resolvedJsonSchema = ref.resolve(jsonSchema, { externalSchemas: [jsonSchemas] });
	    const openapiSchema = convertJsonSchemaToOpenapi3(resolvedJsonSchema);
	    resolveSchemaExamplesRecursive(openapiSchema);

	    openapiSchemas[schemaName] = openapiSchema;
	  }
	  return openapiSchemas
	}

	utils = {
	  prepareDefaultOptions,
	  prepareOpenapiObject,
	  prepareOpenapiMethod,
	  prepareOpenapiSchemas,
	  resolveServerUrls,
	  normalizeUrl
	};
	return utils;
}

var openapi;
var hasRequiredOpenapi;

function requireOpenapi () {
	if (hasRequiredOpenapi) return openapi;
	hasRequiredOpenapi = 1;

	const yaml = require$$1;
	const { shouldRouteHide } = requireShouldRouteHide();
	const { prepareDefaultOptions, prepareOpenapiObject, prepareOpenapiMethod, prepareOpenapiSchemas, normalizeUrl, resolveServerUrls } = requireUtils();

	openapi = function (opts, cache, routes, Ref, done) {
	  let ref;

	  const defOpts = prepareDefaultOptions(opts);

	  return function (opts) {
	    if (opts?.yaml) {
	      if (cache.string) return cache.string
	    } else {
	      if (cache.object) return cache.object
	    }

	    // Base Openapi info
	    const openapiObject = prepareOpenapiObject(defOpts, done);

	    ref = Ref();
	    openapiObject.components.schemas = prepareOpenapiSchemas({
	      ...openapiObject.components.schemas,
	      ...(ref.definitions().definitions)
	    }, ref);

	    const serverUrls = resolveServerUrls(defOpts.servers);

	    for (const route of routes) {
	      const transformResult = route.config?.swaggerTransform !== undefined
	        ? route.config.swaggerTransform
	          ? route.config.swaggerTransform({ schema: route.schema, url: route.url, route, openapiObject })
	          : {}
	        : defOpts.transform
	          ? defOpts.transform({ schema: route.schema, url: route.url, route, openapiObject })
	          : {};

	      const schema = transformResult.schema || route.schema;
	      const shouldRouteHideOpts = {
	        hiddenTag: defOpts.hiddenTag,
	        hideUntagged: defOpts.hideUntagged
	      };

	      if (shouldRouteHide(schema, shouldRouteHideOpts)) continue

	      let url = transformResult.url || route.url;
	      url = normalizeUrl(url, serverUrls, defOpts.stripBasePath);

	      const openapiRoute = Object.assign({}, openapiObject.paths[url]);

	      const openapiMethod = prepareOpenapiMethod(schema, ref, openapiObject, url);

	      if (route.links) {
	        for (const statusCode of Object.keys(route.links)) {
	          if (!openapiMethod.responses[statusCode]) {
	            throw new Error(`missing status code ${statusCode} in route ${route.path}`)
	          }
	          openapiMethod.responses[statusCode].links = route.links[statusCode];
	        }
	      }

	      // route.method should be either a String, like 'POST', or an Array of Strings, like ['POST','PUT','PATCH']
	      const methods = typeof route.method === 'string' ? [route.method] : route.method;

	      for (const method of methods) {
	        openapiRoute[method.toLowerCase()] = openapiMethod;
	      }

	      openapiObject.paths[url] = openapiRoute;
	    }

	    const transformObjectResult = defOpts.transformObject
	      ? defOpts.transformObject({ openapiObject })
	      : openapiObject;

	    if (opts?.yaml) {
	      cache.string = yaml.stringify(transformObjectResult, { strict: false });
	      return cache.string
	    }

	    cache.object = transformObjectResult;
	    return cache.object
	  }
	};
	return openapi;
}

var resolveSwaggerFunction_1;
var hasRequiredResolveSwaggerFunction;

function requireResolveSwaggerFunction () {
	if (hasRequiredResolveSwaggerFunction) return resolveSwaggerFunction_1;
	hasRequiredResolveSwaggerFunction = 1;

	function resolveSwaggerFunction (opts, cache, routes, Ref, done) {
	  if (opts.openapi === undefined || opts.openapi === null) {
	    return requireSwagger$1()(opts, cache, routes, Ref, done)
	  } else {
	    return requireOpenapi()(opts, cache, routes, Ref, done)
	  }
	}

	resolveSwaggerFunction_1 = {
	  resolveSwaggerFunction
	};
	return resolveSwaggerFunction_1;
}

var dynamic;
var hasRequiredDynamic;

function requireDynamic () {
	if (hasRequiredDynamic) return dynamic;
	hasRequiredDynamic = 1;

	const { addHook } = requireAddHook();
	const { resolveSwaggerFunction } = requireResolveSwaggerFunction();

	dynamic = function (fastify, opts, done) {
	  opts = Object.assign({}, {
	    exposeRoute: false,
	    hiddenTag: 'X-HIDDEN',
	    hideUntagged: false,
	    stripBasePath: true,
	    openapi: null,
	    swagger: {},
	    transform: null,
	    transformObject: null,
	    decorator: 'swagger',
	    refResolver: {
	      buildLocalReference (json, _baseUri, _fragment, i) {
	        if (!json.title && json.$id) {
	          json.title = json.$id;
	        }
	        return `def-${i}`
	      }
	    }
	  }, opts);

	  const { routes, Ref } = addHook(fastify, opts);

	  const cache = {
	    object: null,
	    string: null
	  };

	  const swagger = resolveSwaggerFunction(opts, cache, routes, Ref, done);
	  fastify.decorate(opts.decorator, swagger);

	  done();
	};
	return dynamic;
}

var hasRequiredSwagger;

function requireSwagger () {
	if (hasRequiredSwagger) return swagger$1.exports;
	hasRequiredSwagger = 1;

	const fp = requirePlugin();
	const { formatParamUrl } = requireFormatParamUrl();

	function fastifySwagger (fastify, opts, next) {
	  // by default the mode is dynamic, as plugin initially was developed
	  opts.mode = opts.mode || 'dynamic';

	  switch (opts.mode) {
	    case 'static': {
	      const setup = require_static$1();
	      setup(fastify, opts, next);
	      break
	    }
	    case 'dynamic': {
	      const setup = requireDynamic();
	      setup(fastify, opts, next);
	      break
	    }
	    default: {
	      return next(new Error("unsupported mode, should be one of ['static', 'dynamic']"))
	    }
	  }
	}

	swagger$1.exports = fp(fastifySwagger, {
	  fastify: '5.x',
	  name: '@fastify/swagger'
	});
	swagger$1.exports.fastifySwagger = fastifySwagger;
	swagger$1.exports.default = fastifySwagger;

	swagger$1.exports.formatParamUrl = formatParamUrl;
	return swagger$1.exports;
}

var swaggerExports = requireSwagger();
var fastifySwagger = /*@__PURE__*/getDefaultExportFromCjs(swaggerExports);

var swaggerUi = {exports: {}};

var script = [
];
var style = [
];
var require$$3 = {
	script: script,
	style: style
};

var _static = {exports: {}};

var commonjs$6 = {};

var commonjs$5 = {};

var commonjs$4 = {};

var commonjs$3 = {};

var hasRequiredCommonjs$6;

function requireCommonjs$6 () {
	if (hasRequiredCommonjs$6) return commonjs$3;
	hasRequiredCommonjs$6 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.range = exports.balanced = void 0;
		const balanced = (a, b, str) => {
		    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
		    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
		    const r = ma !== null && mb != null && (0, exports.range)(ma, mb, str);
		    return (r && {
		        start: r[0],
		        end: r[1],
		        pre: str.slice(0, r[0]),
		        body: str.slice(r[0] + ma.length, r[1]),
		        post: str.slice(r[1] + mb.length),
		    });
		};
		exports.balanced = balanced;
		const maybeMatch = (reg, str) => {
		    const m = str.match(reg);
		    return m ? m[0] : null;
		};
		const range = (a, b, str) => {
		    let begs, beg, left, right = undefined, result;
		    let ai = str.indexOf(a);
		    let bi = str.indexOf(b, ai + 1);
		    let i = ai;
		    if (ai >= 0 && bi > 0) {
		        if (a === b) {
		            return [ai, bi];
		        }
		        begs = [];
		        left = str.length;
		        while (i >= 0 && !result) {
		            if (i === ai) {
		                begs.push(i);
		                ai = str.indexOf(a, i + 1);
		            }
		            else if (begs.length === 1) {
		                const r = begs.pop();
		                if (r !== undefined)
		                    result = [r, bi];
		            }
		            else {
		                beg = begs.pop();
		                if (beg !== undefined && beg < left) {
		                    left = beg;
		                    right = bi;
		                }
		                bi = str.indexOf(b, i + 1);
		            }
		            i = ai < bi && ai >= 0 ? ai : bi;
		        }
		        if (begs.length && right !== undefined) {
		            result = [left, right];
		        }
		    }
		    return result;
		};
		exports.range = range;
		
	} (commonjs$3));
	return commonjs$3;
}

var hasRequiredCommonjs$5;

function requireCommonjs$5 () {
	if (hasRequiredCommonjs$5) return commonjs$4;
	hasRequiredCommonjs$5 = 1;
	Object.defineProperty(commonjs$4, "__esModule", { value: true });
	commonjs$4.expand = expand;
	const balanced_match_1 = requireCommonjs$6();
	const escSlash = '\0SLASH' + Math.random() + '\0';
	const escOpen = '\0OPEN' + Math.random() + '\0';
	const escClose = '\0CLOSE' + Math.random() + '\0';
	const escComma = '\0COMMA' + Math.random() + '\0';
	const escPeriod = '\0PERIOD' + Math.random() + '\0';
	const escSlashPattern = new RegExp(escSlash, 'g');
	const escOpenPattern = new RegExp(escOpen, 'g');
	const escClosePattern = new RegExp(escClose, 'g');
	const escCommaPattern = new RegExp(escComma, 'g');
	const escPeriodPattern = new RegExp(escPeriod, 'g');
	const slashPattern = /\\\\/g;
	const openPattern = /\\{/g;
	const closePattern = /\\}/g;
	const commaPattern = /\\,/g;
	const periodPattern = /\\./g;
	function numeric(str) {
	    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
	}
	function escapeBraces(str) {
	    return str
	        .replace(slashPattern, escSlash)
	        .replace(openPattern, escOpen)
	        .replace(closePattern, escClose)
	        .replace(commaPattern, escComma)
	        .replace(periodPattern, escPeriod);
	}
	function unescapeBraces(str) {
	    return str
	        .replace(escSlashPattern, '\\')
	        .replace(escOpenPattern, '{')
	        .replace(escClosePattern, '}')
	        .replace(escCommaPattern, ',')
	        .replace(escPeriodPattern, '.');
	}
	/**
	 * Basically just str.split(","), but handling cases
	 * where we have nested braced sections, which should be
	 * treated as individual members, like {a,{b,c},d}
	 */
	function parseCommaParts(str) {
	    if (!str) {
	        return [''];
	    }
	    const parts = [];
	    const m = (0, balanced_match_1.balanced)('{', '}', str);
	    if (!m) {
	        return str.split(',');
	    }
	    const { pre, body, post } = m;
	    const p = pre.split(',');
	    p[p.length - 1] += '{' + body + '}';
	    const postParts = parseCommaParts(post);
	    if (post.length) {
	        p[p.length - 1] += postParts.shift();
	        p.push.apply(p, postParts);
	    }
	    parts.push.apply(parts, p);
	    return parts;
	}
	function expand(str) {
	    if (!str) {
	        return [];
	    }
	    // I don't know why Bash 4.3 does this, but it does.
	    // Anything starting with {} will have the first two bytes preserved
	    // but *only* at the top level, so {},a}b will not expand to anything,
	    // but a{},b}c will be expanded to [a}c,abc].
	    // One could argue that this is a bug in Bash, but since the goal of
	    // this module is to match Bash's rules, we escape a leading {}
	    if (str.slice(0, 2) === '{}') {
	        str = '\\{\\}' + str.slice(2);
	    }
	    return expand_(escapeBraces(str), true).map(unescapeBraces);
	}
	function embrace(str) {
	    return '{' + str + '}';
	}
	function isPadded(el) {
	    return /^-?0\d/.test(el);
	}
	function lte(i, y) {
	    return i <= y;
	}
	function gte(i, y) {
	    return i >= y;
	}
	function expand_(str, isTop) {
	    /** @type {string[]} */
	    const expansions = [];
	    const m = (0, balanced_match_1.balanced)('{', '}', str);
	    if (!m)
	        return [str];
	    // no need to expand pre, since it is guaranteed to be free of brace-sets
	    const pre = m.pre;
	    const post = m.post.length ? expand_(m.post, false) : [''];
	    if (/\$$/.test(m.pre)) {
	        for (let k = 0; k < post.length; k++) {
	            const expansion = pre + '{' + m.body + '}' + post[k];
	            expansions.push(expansion);
	        }
	    }
	    else {
	        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	        const isSequence = isNumericSequence || isAlphaSequence;
	        const isOptions = m.body.indexOf(',') >= 0;
	        if (!isSequence && !isOptions) {
	            // {a},b}
	            if (m.post.match(/,(?!,).*\}/)) {
	                str = m.pre + '{' + m.body + escClose + m.post;
	                return expand_(str);
	            }
	            return [str];
	        }
	        let n;
	        if (isSequence) {
	            n = m.body.split(/\.\./);
	        }
	        else {
	            n = parseCommaParts(m.body);
	            if (n.length === 1 && n[0] !== undefined) {
	                // x{{a,b}}y ==> x{a}y x{b}y
	                n = expand_(n[0], false).map(embrace);
	                //XXX is this necessary? Can't seem to hit it in tests.
	                /* c8 ignore start */
	                if (n.length === 1) {
	                    return post.map(p => m.pre + n[0] + p);
	                }
	                /* c8 ignore stop */
	            }
	        }
	        // at this point, n is the parts, and we know it's not a comma set
	        // with a single entry.
	        let N;
	        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
	            const x = numeric(n[0]);
	            const y = numeric(n[1]);
	            const width = Math.max(n[0].length, n[1].length);
	            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
	            let test = lte;
	            const reverse = y < x;
	            if (reverse) {
	                incr *= -1;
	                test = gte;
	            }
	            const pad = n.some(isPadded);
	            N = [];
	            for (let i = x; test(i, y); i += incr) {
	                let c;
	                if (isAlphaSequence) {
	                    c = String.fromCharCode(i);
	                    if (c === '\\') {
	                        c = '';
	                    }
	                }
	                else {
	                    c = String(i);
	                    if (pad) {
	                        const need = width - c.length;
	                        if (need > 0) {
	                            const z = new Array(need + 1).join('0');
	                            if (i < 0) {
	                                c = '-' + z + c.slice(1);
	                            }
	                            else {
	                                c = z + c;
	                            }
	                        }
	                    }
	                }
	                N.push(c);
	            }
	        }
	        else {
	            N = [];
	            for (let j = 0; j < n.length; j++) {
	                N.push.apply(N, expand_(n[j], false));
	            }
	        }
	        for (let j = 0; j < N.length; j++) {
	            for (let k = 0; k < post.length; k++) {
	                const expansion = pre + N[j] + post[k];
	                if (!isTop || isSequence || expansion) {
	                    expansions.push(expansion);
	                }
	            }
	        }
	    }
	    return expansions;
	}
	
	return commonjs$4;
}

var assertValidPattern = {};

var hasRequiredAssertValidPattern;

function requireAssertValidPattern () {
	if (hasRequiredAssertValidPattern) return assertValidPattern;
	hasRequiredAssertValidPattern = 1;
	Object.defineProperty(assertValidPattern, "__esModule", { value: true });
	assertValidPattern.assertValidPattern = void 0;
	const MAX_PATTERN_LENGTH = 1024 * 64;
	const assertValidPattern$1 = (pattern) => {
	    if (typeof pattern !== 'string') {
	        throw new TypeError('invalid pattern');
	    }
	    if (pattern.length > MAX_PATTERN_LENGTH) {
	        throw new TypeError('pattern is too long');
	    }
	};
	assertValidPattern.assertValidPattern = assertValidPattern$1;
	
	return assertValidPattern;
}

var ast = {};

var braceExpressions = {};

var hasRequiredBraceExpressions;

function requireBraceExpressions () {
	if (hasRequiredBraceExpressions) return braceExpressions;
	hasRequiredBraceExpressions = 1;
	// translate the various posix character classes into unicode properties
	// this works across all unicode locales
	Object.defineProperty(braceExpressions, "__esModule", { value: true });
	braceExpressions.parseClass = void 0;
	// { <posix class>: [<translation>, /u flag required, negated]
	const posixClasses = {
	    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
	    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
	    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
	    '[:blank:]': ['\\p{Zs}\\t', true],
	    '[:cntrl:]': ['\\p{Cc}', true],
	    '[:digit:]': ['\\p{Nd}', true],
	    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
	    '[:lower:]': ['\\p{Ll}', true],
	    '[:print:]': ['\\p{C}', true],
	    '[:punct:]': ['\\p{P}', true],
	    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
	    '[:upper:]': ['\\p{Lu}', true],
	    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
	    '[:xdigit:]': ['A-Fa-f0-9', false],
	};
	// only need to escape a few things inside of brace expressions
	// escapes: [ \ ] -
	const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
	// escape all regexp magic characters
	const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
	// everything has already been escaped, we just have to join
	const rangesToString = (ranges) => ranges.join('');
	// takes a glob string at a posix brace expression, and returns
	// an equivalent regular expression source, and boolean indicating
	// whether the /u flag needs to be applied, and the number of chars
	// consumed to parse the character class.
	// This also removes out of order ranges, and returns ($.) if the
	// entire class just no good.
	const parseClass = (glob, position) => {
	    const pos = position;
	    /* c8 ignore start */
	    if (glob.charAt(pos) !== '[') {
	        throw new Error('not in a brace expression');
	    }
	    /* c8 ignore stop */
	    const ranges = [];
	    const negs = [];
	    let i = pos + 1;
	    let sawStart = false;
	    let uflag = false;
	    let escaping = false;
	    let negate = false;
	    let endPos = pos;
	    let rangeStart = '';
	    WHILE: while (i < glob.length) {
	        const c = glob.charAt(i);
	        if ((c === '!' || c === '^') && i === pos + 1) {
	            negate = true;
	            i++;
	            continue;
	        }
	        if (c === ']' && sawStart && !escaping) {
	            endPos = i + 1;
	            break;
	        }
	        sawStart = true;
	        if (c === '\\') {
	            if (!escaping) {
	                escaping = true;
	                i++;
	                continue;
	            }
	            // escaped \ char, fall through and treat like normal char
	        }
	        if (c === '[' && !escaping) {
	            // either a posix class, a collation equivalent, or just a [
	            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
	                if (glob.startsWith(cls, i)) {
	                    // invalid, [a-[] is fine, but not [a-[:alpha]]
	                    if (rangeStart) {
	                        return ['$.', false, glob.length - pos, true];
	                    }
	                    i += cls.length;
	                    if (neg)
	                        negs.push(unip);
	                    else
	                        ranges.push(unip);
	                    uflag = uflag || u;
	                    continue WHILE;
	                }
	            }
	        }
	        // now it's just a normal character, effectively
	        escaping = false;
	        if (rangeStart) {
	            // throw this range away if it's not valid, but others
	            // can still match.
	            if (c > rangeStart) {
	                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
	            }
	            else if (c === rangeStart) {
	                ranges.push(braceEscape(c));
	            }
	            rangeStart = '';
	            i++;
	            continue;
	        }
	        // now might be the start of a range.
	        // can be either c-d or c-] or c<more...>] or c] at this point
	        if (glob.startsWith('-]', i + 1)) {
	            ranges.push(braceEscape(c + '-'));
	            i += 2;
	            continue;
	        }
	        if (glob.startsWith('-', i + 1)) {
	            rangeStart = c;
	            i += 2;
	            continue;
	        }
	        // not the start of a range, just a single character
	        ranges.push(braceEscape(c));
	        i++;
	    }
	    if (endPos < i) {
	        // didn't see the end of the class, not a valid class,
	        // but might still be valid as a literal match.
	        return ['', false, 0, false];
	    }
	    // if we got no ranges and no negates, then we have a range that
	    // cannot possibly match anything, and that poisons the whole glob
	    if (!ranges.length && !negs.length) {
	        return ['$.', false, glob.length - pos, true];
	    }
	    // if we got one positive range, and it's a single character, then that's
	    // not actually a magic pattern, it's just that one literal character.
	    // we should not treat that as "magic", we should just return the literal
	    // character. [_] is a perfectly valid way to escape glob magic chars.
	    if (negs.length === 0 &&
	        ranges.length === 1 &&
	        /^\\?.$/.test(ranges[0]) &&
	        !negate) {
	        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
	        return [regexpEscape(r), false, endPos - pos, false];
	    }
	    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
	    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
	    const comb = ranges.length && negs.length
	        ? '(' + sranges + '|' + snegs + ')'
	        : ranges.length
	            ? sranges
	            : snegs;
	    return [comb, uflag, endPos - pos, true];
	};
	braceExpressions.parseClass = parseClass;
	
	return braceExpressions;
}

var _unescape = {};

var hasRequired_unescape;

function require_unescape () {
	if (hasRequired_unescape) return _unescape;
	hasRequired_unescape = 1;
	Object.defineProperty(_unescape, "__esModule", { value: true });
	_unescape.unescape = void 0;
	/**
	 * Un-escape a string that has been escaped with {@link escape}.
	 *
	 * If the {@link windowsPathsNoEscape} option is used, then square-brace
	 * escapes are removed, but not backslash escapes.  For example, it will turn
	 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
	 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
	 *
	 * When `windowsPathsNoEscape` is not set, then both brace escapes and
	 * backslash escapes are removed.
	 *
	 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
	 * or unescaped.
	 */
	const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
	    return windowsPathsNoEscape
	        ? s.replace(/\[([^\/\\])\]/g, '$1')
	        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
	};
	_unescape.unescape = unescape;
	
	return _unescape;
}

var hasRequiredAst;

function requireAst () {
	if (hasRequiredAst) return ast;
	hasRequiredAst = 1;
	// parse a single path portion
	Object.defineProperty(ast, "__esModule", { value: true });
	ast.AST = void 0;
	const brace_expressions_js_1 = requireBraceExpressions();
	const unescape_js_1 = require_unescape();
	const types = new Set(['!', '?', '+', '*', '@']);
	const isExtglobType = (c) => types.has(c);
	// Patterns that get prepended to bind to the start of either the
	// entire string, or just a single path portion, to prevent dots
	// and/or traversal patterns, when needed.
	// Exts don't need the ^ or / bit, because the root binds that already.
	const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
	const startNoDot = '(?!\\.)';
	// characters that indicate a start of pattern needs the "no dots" bit,
	// because a dot *might* be matched. ( is not in the list, because in
	// the case of a child extglob, it will handle the prevention itself.
	const addPatternStart = new Set(['[', '.']);
	// cases where traversal is A-OK, no dot prevention needed
	const justDots = new Set(['..', '.']);
	const reSpecials = new Set('().*{}+?[]^$\\!');
	const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
	// any single thing other than /
	const qmark = '[^/]';
	// * => any number of characters
	const star = qmark + '*?';
	// use + when we need to ensure that *something* matches, because the * is
	// the only thing in the path portion.
	const starNoEmpty = qmark + '+?';
	// remove the \ chars that we added if we end up doing a nonmagic compare
	// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
	class AST {
	    type;
	    #root;
	    #hasMagic;
	    #uflag = false;
	    #parts = [];
	    #parent;
	    #parentIndex;
	    #negs;
	    #filledNegs = false;
	    #options;
	    #toString;
	    // set to true if it's an extglob with no children
	    // (which really means one child of '')
	    #emptyExt = false;
	    constructor(type, parent, options = {}) {
	        this.type = type;
	        // extglobs are inherently magical
	        if (type)
	            this.#hasMagic = true;
	        this.#parent = parent;
	        this.#root = this.#parent ? this.#parent.#root : this;
	        this.#options = this.#root === this ? options : this.#root.#options;
	        this.#negs = this.#root === this ? [] : this.#root.#negs;
	        if (type === '!' && !this.#root.#filledNegs)
	            this.#negs.push(this);
	        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
	    }
	    get hasMagic() {
	        /* c8 ignore start */
	        if (this.#hasMagic !== undefined)
	            return this.#hasMagic;
	        /* c8 ignore stop */
	        for (const p of this.#parts) {
	            if (typeof p === 'string')
	                continue;
	            if (p.type || p.hasMagic)
	                return (this.#hasMagic = true);
	        }
	        // note: will be undefined until we generate the regexp src and find out
	        return this.#hasMagic;
	    }
	    // reconstructs the pattern
	    toString() {
	        if (this.#toString !== undefined)
	            return this.#toString;
	        if (!this.type) {
	            return (this.#toString = this.#parts.map(p => String(p)).join(''));
	        }
	        else {
	            return (this.#toString =
	                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
	        }
	    }
	    #fillNegs() {
	        /* c8 ignore start */
	        if (this !== this.#root)
	            throw new Error('should only call on root');
	        if (this.#filledNegs)
	            return this;
	        /* c8 ignore stop */
	        // call toString() once to fill this out
	        this.toString();
	        this.#filledNegs = true;
	        let n;
	        while ((n = this.#negs.pop())) {
	            if (n.type !== '!')
	                continue;
	            // walk up the tree, appending everthing that comes AFTER parentIndex
	            let p = n;
	            let pp = p.#parent;
	            while (pp) {
	                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
	                    for (const part of n.#parts) {
	                        /* c8 ignore start */
	                        if (typeof part === 'string') {
	                            throw new Error('string part in extglob AST??');
	                        }
	                        /* c8 ignore stop */
	                        part.copyIn(pp.#parts[i]);
	                    }
	                }
	                p = pp;
	                pp = p.#parent;
	            }
	        }
	        return this;
	    }
	    push(...parts) {
	        for (const p of parts) {
	            if (p === '')
	                continue;
	            /* c8 ignore start */
	            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
	                throw new Error('invalid part: ' + p);
	            }
	            /* c8 ignore stop */
	            this.#parts.push(p);
	        }
	    }
	    toJSON() {
	        const ret = this.type === null
	            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
	            : [this.type, ...this.#parts.map(p => p.toJSON())];
	        if (this.isStart() && !this.type)
	            ret.unshift([]);
	        if (this.isEnd() &&
	            (this === this.#root ||
	                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
	            ret.push({});
	        }
	        return ret;
	    }
	    isStart() {
	        if (this.#root === this)
	            return true;
	        // if (this.type) return !!this.#parent?.isStart()
	        if (!this.#parent?.isStart())
	            return false;
	        if (this.#parentIndex === 0)
	            return true;
	        // if everything AHEAD of this is a negation, then it's still the "start"
	        const p = this.#parent;
	        for (let i = 0; i < this.#parentIndex; i++) {
	            const pp = p.#parts[i];
	            if (!(pp instanceof AST && pp.type === '!')) {
	                return false;
	            }
	        }
	        return true;
	    }
	    isEnd() {
	        if (this.#root === this)
	            return true;
	        if (this.#parent?.type === '!')
	            return true;
	        if (!this.#parent?.isEnd())
	            return false;
	        if (!this.type)
	            return this.#parent?.isEnd();
	        // if not root, it'll always have a parent
	        /* c8 ignore start */
	        const pl = this.#parent ? this.#parent.#parts.length : 0;
	        /* c8 ignore stop */
	        return this.#parentIndex === pl - 1;
	    }
	    copyIn(part) {
	        if (typeof part === 'string')
	            this.push(part);
	        else
	            this.push(part.clone(this));
	    }
	    clone(parent) {
	        const c = new AST(this.type, parent);
	        for (const p of this.#parts) {
	            c.copyIn(p);
	        }
	        return c;
	    }
	    static #parseAST(str, ast, pos, opt) {
	        let escaping = false;
	        let inBrace = false;
	        let braceStart = -1;
	        let braceNeg = false;
	        if (ast.type === null) {
	            // outside of a extglob, append until we find a start
	            let i = pos;
	            let acc = '';
	            while (i < str.length) {
	                const c = str.charAt(i++);
	                // still accumulate escapes at this point, but we do ignore
	                // starts that are escaped
	                if (escaping || c === '\\') {
	                    escaping = !escaping;
	                    acc += c;
	                    continue;
	                }
	                if (inBrace) {
	                    if (i === braceStart + 1) {
	                        if (c === '^' || c === '!') {
	                            braceNeg = true;
	                        }
	                    }
	                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
	                        inBrace = false;
	                    }
	                    acc += c;
	                    continue;
	                }
	                else if (c === '[') {
	                    inBrace = true;
	                    braceStart = i;
	                    braceNeg = false;
	                    acc += c;
	                    continue;
	                }
	                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
	                    ast.push(acc);
	                    acc = '';
	                    const ext = new AST(c, ast);
	                    i = AST.#parseAST(str, ext, i, opt);
	                    ast.push(ext);
	                    continue;
	                }
	                acc += c;
	            }
	            ast.push(acc);
	            return i;
	        }
	        // some kind of extglob, pos is at the (
	        // find the next | or )
	        let i = pos + 1;
	        let part = new AST(null, ast);
	        const parts = [];
	        let acc = '';
	        while (i < str.length) {
	            const c = str.charAt(i++);
	            // still accumulate escapes at this point, but we do ignore
	            // starts that are escaped
	            if (escaping || c === '\\') {
	                escaping = !escaping;
	                acc += c;
	                continue;
	            }
	            if (inBrace) {
	                if (i === braceStart + 1) {
	                    if (c === '^' || c === '!') {
	                        braceNeg = true;
	                    }
	                }
	                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
	                    inBrace = false;
	                }
	                acc += c;
	                continue;
	            }
	            else if (c === '[') {
	                inBrace = true;
	                braceStart = i;
	                braceNeg = false;
	                acc += c;
	                continue;
	            }
	            if (isExtglobType(c) && str.charAt(i) === '(') {
	                part.push(acc);
	                acc = '';
	                const ext = new AST(c, part);
	                part.push(ext);
	                i = AST.#parseAST(str, ext, i, opt);
	                continue;
	            }
	            if (c === '|') {
	                part.push(acc);
	                acc = '';
	                parts.push(part);
	                part = new AST(null, ast);
	                continue;
	            }
	            if (c === ')') {
	                if (acc === '' && ast.#parts.length === 0) {
	                    ast.#emptyExt = true;
	                }
	                part.push(acc);
	                acc = '';
	                ast.push(...parts, part);
	                return i;
	            }
	            acc += c;
	        }
	        // unfinished extglob
	        // if we got here, it was a malformed extglob! not an extglob, but
	        // maybe something else in there.
	        ast.type = null;
	        ast.#hasMagic = undefined;
	        ast.#parts = [str.substring(pos - 1)];
	        return i;
	    }
	    static fromGlob(pattern, options = {}) {
	        const ast = new AST(null, undefined, options);
	        AST.#parseAST(pattern, ast, 0, options);
	        return ast;
	    }
	    // returns the regular expression if there's magic, or the unescaped
	    // string if not.
	    toMMPattern() {
	        // should only be called on root
	        /* c8 ignore start */
	        if (this !== this.#root)
	            return this.#root.toMMPattern();
	        /* c8 ignore stop */
	        const glob = this.toString();
	        const [re, body, hasMagic, uflag] = this.toRegExpSource();
	        // if we're in nocase mode, and not nocaseMagicOnly, then we do
	        // still need a regular expression if we have to case-insensitively
	        // match capital/lowercase characters.
	        const anyMagic = hasMagic ||
	            this.#hasMagic ||
	            (this.#options.nocase &&
	                !this.#options.nocaseMagicOnly &&
	                glob.toUpperCase() !== glob.toLowerCase());
	        if (!anyMagic) {
	            return body;
	        }
	        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
	        return Object.assign(new RegExp(`^${re}$`, flags), {
	            _src: re,
	            _glob: glob,
	        });
	    }
	    get options() {
	        return this.#options;
	    }
	    // returns the string match, the regexp source, whether there's magic
	    // in the regexp (so a regular expression is required) and whether or
	    // not the uflag is needed for the regular expression (for posix classes)
	    // TODO: instead of injecting the start/end at this point, just return
	    // the BODY of the regexp, along with the start/end portions suitable
	    // for binding the start/end in either a joined full-path makeRe context
	    // (where we bind to (^|/), or a standalone matchPart context (where
	    // we bind to ^, and not /).  Otherwise slashes get duped!
	    //
	    // In part-matching mode, the start is:
	    // - if not isStart: nothing
	    // - if traversal possible, but not allowed: ^(?!\.\.?$)
	    // - if dots allowed or not possible: ^
	    // - if dots possible and not allowed: ^(?!\.)
	    // end is:
	    // - if not isEnd(): nothing
	    // - else: $
	    //
	    // In full-path matching mode, we put the slash at the START of the
	    // pattern, so start is:
	    // - if first pattern: same as part-matching mode
	    // - if not isStart(): nothing
	    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
	    // - if dots allowed or not possible: /
	    // - if dots possible and not allowed: /(?!\.)
	    // end is:
	    // - if last pattern, same as part-matching mode
	    // - else nothing
	    //
	    // Always put the (?:$|/) on negated tails, though, because that has to be
	    // there to bind the end of the negated pattern portion, and it's easier to
	    // just stick it in now rather than try to inject it later in the middle of
	    // the pattern.
	    //
	    // We can just always return the same end, and leave it up to the caller
	    // to know whether it's going to be used joined or in parts.
	    // And, if the start is adjusted slightly, can do the same there:
	    // - if not isStart: nothing
	    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
	    // - if dots allowed or not possible: (?:/|^)
	    // - if dots possible and not allowed: (?:/|^)(?!\.)
	    //
	    // But it's better to have a simpler binding without a conditional, for
	    // performance, so probably better to return both start options.
	    //
	    // Then the caller just ignores the end if it's not the first pattern,
	    // and the start always gets applied.
	    //
	    // But that's always going to be $ if it's the ending pattern, or nothing,
	    // so the caller can just attach $ at the end of the pattern when building.
	    //
	    // So the todo is:
	    // - better detect what kind of start is needed
	    // - return both flavors of starting pattern
	    // - attach $ at the end of the pattern when creating the actual RegExp
	    //
	    // Ah, but wait, no, that all only applies to the root when the first pattern
	    // is not an extglob. If the first pattern IS an extglob, then we need all
	    // that dot prevention biz to live in the extglob portions, because eg
	    // +(*|.x*) can match .xy but not .yx.
	    //
	    // So, return the two flavors if it's #root and the first child is not an
	    // AST, otherwise leave it to the child AST to handle it, and there,
	    // use the (?:^|/) style of start binding.
	    //
	    // Even simplified further:
	    // - Since the start for a join is eg /(?!\.) and the start for a part
	    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
	    // or start or whatever) and prepend ^ or / at the Regexp construction.
	    toRegExpSource(allowDot) {
	        const dot = allowDot ?? !!this.#options.dot;
	        if (this.#root === this)
	            this.#fillNegs();
	        if (!this.type) {
	            const noEmpty = this.isStart() && this.isEnd();
	            const src = this.#parts
	                .map(p => {
	                const [re, _, hasMagic, uflag] = typeof p === 'string'
	                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
	                    : p.toRegExpSource(allowDot);
	                this.#hasMagic = this.#hasMagic || hasMagic;
	                this.#uflag = this.#uflag || uflag;
	                return re;
	            })
	                .join('');
	            let start = '';
	            if (this.isStart()) {
	                if (typeof this.#parts[0] === 'string') {
	                    // this is the string that will match the start of the pattern,
	                    // so we need to protect against dots and such.
	                    // '.' and '..' cannot match unless the pattern is that exactly,
	                    // even if it starts with . or dot:true is set.
	                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
	                    if (!dotTravAllowed) {
	                        const aps = addPatternStart;
	                        // check if we have a possibility of matching . or ..,
	                        // and prevent that.
	                        const needNoTrav = 
	                        // dots are allowed, and the pattern starts with [ or .
	                        (dot && aps.has(src.charAt(0))) ||
	                            // the pattern starts with \., and then [ or .
	                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
	                            // the pattern starts with \.\., and then [ or .
	                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
	                        // no need to prevent dots if it can't match a dot, or if a
	                        // sub-pattern will be preventing it anyway.
	                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
	                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
	                    }
	                }
	            }
	            // append the "end of path portion" pattern to negation tails
	            let end = '';
	            if (this.isEnd() &&
	                this.#root.#filledNegs &&
	                this.#parent?.type === '!') {
	                end = '(?:$|\\/)';
	            }
	            const final = start + src + end;
	            return [
	                final,
	                (0, unescape_js_1.unescape)(src),
	                (this.#hasMagic = !!this.#hasMagic),
	                this.#uflag,
	            ];
	        }
	        // We need to calculate the body *twice* if it's a repeat pattern
	        // at the start, once in nodot mode, then again in dot mode, so a
	        // pattern like *(?) can match 'x.y'
	        const repeated = this.type === '*' || this.type === '+';
	        // some kind of extglob
	        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
	        let body = this.#partsToRegExp(dot);
	        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
	            // invalid extglob, has to at least be *something* present, if it's
	            // the entire path portion.
	            const s = this.toString();
	            this.#parts = [s];
	            this.type = null;
	            this.#hasMagic = undefined;
	            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
	        }
	        // XXX abstract out this map method
	        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
	            ? ''
	            : this.#partsToRegExp(true);
	        if (bodyDotAllowed === body) {
	            bodyDotAllowed = '';
	        }
	        if (bodyDotAllowed) {
	            body = `(?:${body})(?:${bodyDotAllowed})*?`;
	        }
	        // an empty !() is exactly equivalent to a starNoEmpty
	        let final = '';
	        if (this.type === '!' && this.#emptyExt) {
	            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
	        }
	        else {
	            const close = this.type === '!'
	                ? // !() must match something,but !(x) can match ''
	                    '))' +
	                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
	                        star +
	                        ')'
	                : this.type === '@'
	                    ? ')'
	                    : this.type === '?'
	                        ? ')?'
	                        : this.type === '+' && bodyDotAllowed
	                            ? ')'
	                            : this.type === '*' && bodyDotAllowed
	                                ? `)?`
	                                : `)${this.type}`;
	            final = start + body + close;
	        }
	        return [
	            final,
	            (0, unescape_js_1.unescape)(body),
	            (this.#hasMagic = !!this.#hasMagic),
	            this.#uflag,
	        ];
	    }
	    #partsToRegExp(dot) {
	        return this.#parts
	            .map(p => {
	            // extglob ASTs should only contain parent ASTs
	            /* c8 ignore start */
	            if (typeof p === 'string') {
	                throw new Error('string type in extglob ast??');
	            }
	            /* c8 ignore stop */
	            // can ignore hasMagic, because extglobs are already always magic
	            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
	            this.#uflag = this.#uflag || uflag;
	            return re;
	        })
	            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
	            .join('|');
	    }
	    static #parseGlob(glob, hasMagic, noEmpty = false) {
	        let escaping = false;
	        let re = '';
	        let uflag = false;
	        for (let i = 0; i < glob.length; i++) {
	            const c = glob.charAt(i);
	            if (escaping) {
	                escaping = false;
	                re += (reSpecials.has(c) ? '\\' : '') + c;
	                continue;
	            }
	            if (c === '\\') {
	                if (i === glob.length - 1) {
	                    re += '\\\\';
	                }
	                else {
	                    escaping = true;
	                }
	                continue;
	            }
	            if (c === '[') {
	                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
	                if (consumed) {
	                    re += src;
	                    uflag = uflag || needUflag;
	                    i += consumed - 1;
	                    hasMagic = hasMagic || magic;
	                    continue;
	                }
	            }
	            if (c === '*') {
	                if (noEmpty && glob === '*')
	                    re += starNoEmpty;
	                else
	                    re += star;
	                hasMagic = true;
	                continue;
	            }
	            if (c === '?') {
	                re += qmark;
	                hasMagic = true;
	                continue;
	            }
	            re += regExpEscape(c);
	        }
	        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
	    }
	}
	ast.AST = AST;
	
	return ast;
}

var _escape = {};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;
	Object.defineProperty(_escape, "__esModule", { value: true });
	_escape.escape = void 0;
	/**
	 * Escape all magic characters in a glob pattern.
	 *
	 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
	 * option is used, then characters are escaped by wrapping in `[]`, because
	 * a magic character wrapped in a character class can only be satisfied by
	 * that exact character.  In this mode, `\` is _not_ escaped, because it is
	 * not interpreted as a magic character, but instead as a path separator.
	 */
	const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
	    // don't need to escape +@! because we escape the parens
	    // that make those magic, and escaping ! as [!] isn't valid,
	    // because [!]] is a valid glob class meaning not ']'.
	    return windowsPathsNoEscape
	        ? s.replace(/[?*()[\]]/g, '[$&]')
	        : s.replace(/[?*()[\]\\]/g, '\\$&');
	};
	_escape.escape = escape;
	
	return _escape;
}

var hasRequiredCommonjs$4;

function requireCommonjs$4 () {
	if (hasRequiredCommonjs$4) return commonjs$5;
	hasRequiredCommonjs$4 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
		const brace_expansion_1 = requireCommonjs$5();
		const assert_valid_pattern_js_1 = requireAssertValidPattern();
		const ast_js_1 = requireAst();
		const escape_js_1 = require_escape();
		const unescape_js_1 = require_unescape();
		const minimatch = (p, pattern, options = {}) => {
		    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		    // shortcut: comments match nothing.
		    if (!options.nocomment && pattern.charAt(0) === '#') {
		        return false;
		    }
		    return new Minimatch(pattern, options).match(p);
		};
		exports.minimatch = minimatch;
		// Optimized checking for the most common glob patterns.
		const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
		const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
		const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
		const starDotExtTestNocase = (ext) => {
		    ext = ext.toLowerCase();
		    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
		};
		const starDotExtTestNocaseDot = (ext) => {
		    ext = ext.toLowerCase();
		    return (f) => f.toLowerCase().endsWith(ext);
		};
		const starDotStarRE = /^\*+\.\*+$/;
		const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
		const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
		const dotStarRE = /^\.\*+$/;
		const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
		const starRE = /^\*+$/;
		const starTest = (f) => f.length !== 0 && !f.startsWith('.');
		const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
		const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
		const qmarksTestNocase = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExt([$0]);
		    if (!ext)
		        return noext;
		    ext = ext.toLowerCase();
		    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
		};
		const qmarksTestNocaseDot = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExtDot([$0]);
		    if (!ext)
		        return noext;
		    ext = ext.toLowerCase();
		    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
		};
		const qmarksTestDot = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExtDot([$0]);
		    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
		};
		const qmarksTest = ([$0, ext = '']) => {
		    const noext = qmarksTestNoExt([$0]);
		    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
		};
		const qmarksTestNoExt = ([$0]) => {
		    const len = $0.length;
		    return (f) => f.length === len && !f.startsWith('.');
		};
		const qmarksTestNoExtDot = ([$0]) => {
		    const len = $0.length;
		    return (f) => f.length === len && f !== '.' && f !== '..';
		};
		/* c8 ignore start */
		const defaultPlatform = (typeof process === 'object' && process
		    ? (typeof process.env === 'object' &&
		        process.env &&
		        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
		        process.platform
		    : 'posix');
		const path = {
		    win32: { sep: '\\' },
		    posix: { sep: '/' },
		};
		/* c8 ignore stop */
		exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
		exports.minimatch.sep = exports.sep;
		exports.GLOBSTAR = Symbol('globstar **');
		exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
		// any single thing other than /
		// don't need to escape / when using new RegExp()
		const qmark = '[^/]';
		// * => any number of characters
		const star = qmark + '*?';
		// ** when dots are allowed.  Anything goes, except .. and .
		// not (^ or / followed by one or two dots followed by $ or /),
		// followed by anything, any number of times.
		const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
		// not a ^ or / followed by a dot,
		// followed by anything, any number of times.
		const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
		const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
		exports.filter = filter;
		exports.minimatch.filter = exports.filter;
		const ext = (a, b = {}) => Object.assign({}, a, b);
		const defaults = (def) => {
		    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
		        return exports.minimatch;
		    }
		    const orig = exports.minimatch;
		    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
		    return Object.assign(m, {
		        Minimatch: class Minimatch extends orig.Minimatch {
		            constructor(pattern, options = {}) {
		                super(pattern, ext(def, options));
		            }
		            static defaults(options) {
		                return orig.defaults(ext(def, options)).Minimatch;
		            }
		        },
		        AST: class AST extends orig.AST {
		            /* c8 ignore start */
		            constructor(type, parent, options = {}) {
		                super(type, parent, ext(def, options));
		            }
		            /* c8 ignore stop */
		            static fromGlob(pattern, options = {}) {
		                return orig.AST.fromGlob(pattern, ext(def, options));
		            }
		        },
		        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
		        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
		        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
		        defaults: (options) => orig.defaults(ext(def, options)),
		        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
		        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
		        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
		        sep: orig.sep,
		        GLOBSTAR: exports.GLOBSTAR,
		    });
		};
		exports.defaults = defaults;
		exports.minimatch.defaults = exports.defaults;
		// Brace expansion:
		// a{b,c}d -> abd acd
		// a{b,}c -> abc ac
		// a{0..3}d -> a0d a1d a2d a3d
		// a{b,c{d,e}f}g -> abg acdfg acefg
		// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
		//
		// Invalid sets are not expanded.
		// a{2..}b -> a{2..}b
		// a{b}c -> a{b}c
		const braceExpand = (pattern, options = {}) => {
		    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		    // Thanks to Yeting Li <https://github.com/yetingli> for
		    // improving this regexp to avoid a ReDOS vulnerability.
		    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
		        // shortcut. no need to expand.
		        return [pattern];
		    }
		    return (0, brace_expansion_1.expand)(pattern);
		};
		exports.braceExpand = braceExpand;
		exports.minimatch.braceExpand = exports.braceExpand;
		// parse a component of the expanded set.
		// At this point, no pattern may contain "/" in it
		// so we're going to return a 2d array, where each entry is the full
		// pattern, split on '/', and then turned into a regular expression.
		// A regexp is made at the end which joins each array with an
		// escaped /, and another full one which joins each regexp with |.
		//
		// Following the lead of Bash 4.1, note that "**" only has special meaning
		// when it is the *only* thing in a path portion.  Otherwise, any series
		// of * is equivalent to a single *.  Globstar behavior is enabled by
		// default, and can be disabled by setting options.noglobstar.
		const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
		exports.makeRe = makeRe;
		exports.minimatch.makeRe = exports.makeRe;
		const match = (list, pattern, options = {}) => {
		    const mm = new Minimatch(pattern, options);
		    list = list.filter(f => mm.match(f));
		    if (mm.options.nonull && !list.length) {
		        list.push(pattern);
		    }
		    return list;
		};
		exports.match = match;
		exports.minimatch.match = exports.match;
		// replace stuff like \* with *
		const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
		const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
		class Minimatch {
		    options;
		    set;
		    pattern;
		    windowsPathsNoEscape;
		    nonegate;
		    negate;
		    comment;
		    empty;
		    preserveMultipleSlashes;
		    partial;
		    globSet;
		    globParts;
		    nocase;
		    isWindows;
		    platform;
		    windowsNoMagicRoot;
		    regexp;
		    constructor(pattern, options = {}) {
		        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		        options = options || {};
		        this.options = options;
		        this.pattern = pattern;
		        this.platform = options.platform || defaultPlatform;
		        this.isWindows = this.platform === 'win32';
		        this.windowsPathsNoEscape =
		            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
		        if (this.windowsPathsNoEscape) {
		            this.pattern = this.pattern.replace(/\\/g, '/');
		        }
		        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
		        this.regexp = null;
		        this.negate = false;
		        this.nonegate = !!options.nonegate;
		        this.comment = false;
		        this.empty = false;
		        this.partial = !!options.partial;
		        this.nocase = !!this.options.nocase;
		        this.windowsNoMagicRoot =
		            options.windowsNoMagicRoot !== undefined
		                ? options.windowsNoMagicRoot
		                : !!(this.isWindows && this.nocase);
		        this.globSet = [];
		        this.globParts = [];
		        this.set = [];
		        // make the set of regexps etc.
		        this.make();
		    }
		    hasMagic() {
		        if (this.options.magicalBraces && this.set.length > 1) {
		            return true;
		        }
		        for (const pattern of this.set) {
		            for (const part of pattern) {
		                if (typeof part !== 'string')
		                    return true;
		            }
		        }
		        return false;
		    }
		    debug(..._) { }
		    make() {
		        const pattern = this.pattern;
		        const options = this.options;
		        // empty patterns and comments match nothing.
		        if (!options.nocomment && pattern.charAt(0) === '#') {
		            this.comment = true;
		            return;
		        }
		        if (!pattern) {
		            this.empty = true;
		            return;
		        }
		        // step 1: figure out negation, etc.
		        this.parseNegate();
		        // step 2: expand braces
		        this.globSet = [...new Set(this.braceExpand())];
		        if (options.debug) {
		            this.debug = (...args) => console.error(...args);
		        }
		        this.debug(this.pattern, this.globSet);
		        // step 3: now we have a set, so turn each one into a series of
		        // path-portion matching patterns.
		        // These will be regexps, except in the case of "**", which is
		        // set to the GLOBSTAR object for globstar behavior,
		        // and will not contain any / characters
		        //
		        // First, we preprocess to make the glob pattern sets a bit simpler
		        // and deduped.  There are some perf-killing patterns that can cause
		        // problems with a glob walk, but we can simplify them down a bit.
		        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
		        this.globParts = this.preprocess(rawGlobParts);
		        this.debug(this.pattern, this.globParts);
		        // glob --> regexps
		        let set = this.globParts.map((s, _, __) => {
		            if (this.isWindows && this.windowsNoMagicRoot) {
		                // check if it's a drive or unc path.
		                const isUNC = s[0] === '' &&
		                    s[1] === '' &&
		                    (s[2] === '?' || !globMagic.test(s[2])) &&
		                    !globMagic.test(s[3]);
		                const isDrive = /^[a-z]:/i.test(s[0]);
		                if (isUNC) {
		                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
		                }
		                else if (isDrive) {
		                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
		                }
		            }
		            return s.map(ss => this.parse(ss));
		        });
		        this.debug(this.pattern, set);
		        // filter out everything that didn't compile properly.
		        this.set = set.filter(s => s.indexOf(false) === -1);
		        // do not treat the ? in UNC paths as magic
		        if (this.isWindows) {
		            for (let i = 0; i < this.set.length; i++) {
		                const p = this.set[i];
		                if (p[0] === '' &&
		                    p[1] === '' &&
		                    this.globParts[i][2] === '?' &&
		                    typeof p[3] === 'string' &&
		                    /^[a-z]:$/i.test(p[3])) {
		                    p[2] = '?';
		                }
		            }
		        }
		        this.debug(this.pattern, this.set);
		    }
		    // various transforms to equivalent pattern sets that are
		    // faster to process in a filesystem walk.  The goal is to
		    // eliminate what we can, and push all ** patterns as far
		    // to the right as possible, even if it increases the number
		    // of patterns that we have to process.
		    preprocess(globParts) {
		        // if we're not in globstar mode, then turn all ** into *
		        if (this.options.noglobstar) {
		            for (let i = 0; i < globParts.length; i++) {
		                for (let j = 0; j < globParts[i].length; j++) {
		                    if (globParts[i][j] === '**') {
		                        globParts[i][j] = '*';
		                    }
		                }
		            }
		        }
		        const { optimizationLevel = 1 } = this.options;
		        if (optimizationLevel >= 2) {
		            // aggressive optimization for the purpose of fs walking
		            globParts = this.firstPhasePreProcess(globParts);
		            globParts = this.secondPhasePreProcess(globParts);
		        }
		        else if (optimizationLevel >= 1) {
		            // just basic optimizations to remove some .. parts
		            globParts = this.levelOneOptimize(globParts);
		        }
		        else {
		            // just collapse multiple ** portions into one
		            globParts = this.adjascentGlobstarOptimize(globParts);
		        }
		        return globParts;
		    }
		    // just get rid of adjascent ** portions
		    adjascentGlobstarOptimize(globParts) {
		        return globParts.map(parts => {
		            let gs = -1;
		            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
		                let i = gs;
		                while (parts[i + 1] === '**') {
		                    i++;
		                }
		                if (i !== gs) {
		                    parts.splice(gs, i - gs);
		                }
		            }
		            return parts;
		        });
		    }
		    // get rid of adjascent ** and resolve .. portions
		    levelOneOptimize(globParts) {
		        return globParts.map(parts => {
		            parts = parts.reduce((set, part) => {
		                const prev = set[set.length - 1];
		                if (part === '**' && prev === '**') {
		                    return set;
		                }
		                if (part === '..') {
		                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
		                        set.pop();
		                        return set;
		                    }
		                }
		                set.push(part);
		                return set;
		            }, []);
		            return parts.length === 0 ? [''] : parts;
		        });
		    }
		    levelTwoFileOptimize(parts) {
		        if (!Array.isArray(parts)) {
		            parts = this.slashSplit(parts);
		        }
		        let didSomething = false;
		        do {
		            didSomething = false;
		            // <pre>/<e>/<rest> -> <pre>/<rest>
		            if (!this.preserveMultipleSlashes) {
		                for (let i = 1; i < parts.length - 1; i++) {
		                    const p = parts[i];
		                    // don't squeeze out UNC patterns
		                    if (i === 1 && p === '' && parts[0] === '')
		                        continue;
		                    if (p === '.' || p === '') {
		                        didSomething = true;
		                        parts.splice(i, 1);
		                        i--;
		                    }
		                }
		                if (parts[0] === '.' &&
		                    parts.length === 2 &&
		                    (parts[1] === '.' || parts[1] === '')) {
		                    didSomething = true;
		                    parts.pop();
		                }
		            }
		            // <pre>/<p>/../<rest> -> <pre>/<rest>
		            let dd = 0;
		            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
		                const p = parts[dd - 1];
		                if (p && p !== '.' && p !== '..' && p !== '**') {
		                    didSomething = true;
		                    parts.splice(dd - 1, 2);
		                    dd -= 2;
		                }
		            }
		        } while (didSomething);
		        return parts.length === 0 ? [''] : parts;
		    }
		    // First phase: single-pattern processing
		    // <pre> is 1 or more portions
		    // <rest> is 1 or more portions
		    // <p> is any portion other than ., .., '', or **
		    // <e> is . or ''
		    //
		    // **/.. is *brutal* for filesystem walking performance, because
		    // it effectively resets the recursive walk each time it occurs,
		    // and ** cannot be reduced out by a .. pattern part like a regexp
		    // or most strings (other than .., ., and '') can be.
		    //
		    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
		    // <pre>/<e>/<rest> -> <pre>/<rest>
		    // <pre>/<p>/../<rest> -> <pre>/<rest>
		    // **/**/<rest> -> **/<rest>
		    //
		    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
		    // this WOULD be allowed if ** did follow symlinks, or * didn't
		    firstPhasePreProcess(globParts) {
		        let didSomething = false;
		        do {
		            didSomething = false;
		            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
		            for (let parts of globParts) {
		                let gs = -1;
		                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
		                    let gss = gs;
		                    while (parts[gss + 1] === '**') {
		                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
		                        gss++;
		                    }
		                    // eg, if gs is 2 and gss is 4, that means we have 3 **
		                    // parts, and can remove 2 of them.
		                    if (gss > gs) {
		                        parts.splice(gs + 1, gss - gs);
		                    }
		                    let next = parts[gs + 1];
		                    const p = parts[gs + 2];
		                    const p2 = parts[gs + 3];
		                    if (next !== '..')
		                        continue;
		                    if (!p ||
		                        p === '.' ||
		                        p === '..' ||
		                        !p2 ||
		                        p2 === '.' ||
		                        p2 === '..') {
		                        continue;
		                    }
		                    didSomething = true;
		                    // edit parts in place, and push the new one
		                    parts.splice(gs, 1);
		                    const other = parts.slice(0);
		                    other[gs] = '**';
		                    globParts.push(other);
		                    gs--;
		                }
		                // <pre>/<e>/<rest> -> <pre>/<rest>
		                if (!this.preserveMultipleSlashes) {
		                    for (let i = 1; i < parts.length - 1; i++) {
		                        const p = parts[i];
		                        // don't squeeze out UNC patterns
		                        if (i === 1 && p === '' && parts[0] === '')
		                            continue;
		                        if (p === '.' || p === '') {
		                            didSomething = true;
		                            parts.splice(i, 1);
		                            i--;
		                        }
		                    }
		                    if (parts[0] === '.' &&
		                        parts.length === 2 &&
		                        (parts[1] === '.' || parts[1] === '')) {
		                        didSomething = true;
		                        parts.pop();
		                    }
		                }
		                // <pre>/<p>/../<rest> -> <pre>/<rest>
		                let dd = 0;
		                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
		                    const p = parts[dd - 1];
		                    if (p && p !== '.' && p !== '..' && p !== '**') {
		                        didSomething = true;
		                        const needDot = dd === 1 && parts[dd + 1] === '**';
		                        const splin = needDot ? ['.'] : [];
		                        parts.splice(dd - 1, 2, ...splin);
		                        if (parts.length === 0)
		                            parts.push('');
		                        dd -= 2;
		                    }
		                }
		            }
		        } while (didSomething);
		        return globParts;
		    }
		    // second phase: multi-pattern dedupes
		    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
		    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
		    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
		    //
		    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
		    // ^-- not valid because ** doens't follow symlinks
		    secondPhasePreProcess(globParts) {
		        for (let i = 0; i < globParts.length - 1; i++) {
		            for (let j = i + 1; j < globParts.length; j++) {
		                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
		                if (matched) {
		                    globParts[i] = [];
		                    globParts[j] = matched;
		                    break;
		                }
		            }
		        }
		        return globParts.filter(gs => gs.length);
		    }
		    partsMatch(a, b, emptyGSMatch = false) {
		        let ai = 0;
		        let bi = 0;
		        let result = [];
		        let which = '';
		        while (ai < a.length && bi < b.length) {
		            if (a[ai] === b[bi]) {
		                result.push(which === 'b' ? b[bi] : a[ai]);
		                ai++;
		                bi++;
		            }
		            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
		                result.push(a[ai]);
		                ai++;
		            }
		            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
		                result.push(b[bi]);
		                bi++;
		            }
		            else if (a[ai] === '*' &&
		                b[bi] &&
		                (this.options.dot || !b[bi].startsWith('.')) &&
		                b[bi] !== '**') {
		                if (which === 'b')
		                    return false;
		                which = 'a';
		                result.push(a[ai]);
		                ai++;
		                bi++;
		            }
		            else if (b[bi] === '*' &&
		                a[ai] &&
		                (this.options.dot || !a[ai].startsWith('.')) &&
		                a[ai] !== '**') {
		                if (which === 'a')
		                    return false;
		                which = 'b';
		                result.push(b[bi]);
		                ai++;
		                bi++;
		            }
		            else {
		                return false;
		            }
		        }
		        // if we fall out of the loop, it means they two are identical
		        // as long as their lengths match
		        return a.length === b.length && result;
		    }
		    parseNegate() {
		        if (this.nonegate)
		            return;
		        const pattern = this.pattern;
		        let negate = false;
		        let negateOffset = 0;
		        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
		            negate = !negate;
		            negateOffset++;
		        }
		        if (negateOffset)
		            this.pattern = pattern.slice(negateOffset);
		        this.negate = negate;
		    }
		    // set partial to true to test if, for example,
		    // "/a/b" matches the start of "/*/b/*/d"
		    // Partial means, if you run out of file before you run
		    // out of pattern, then that's fine, as long as all
		    // the parts match.
		    matchOne(file, pattern, partial = false) {
		        const options = this.options;
		        // UNC paths like //?/X:/... can match X:/... and vice versa
		        // Drive letters in absolute drive or unc paths are always compared
		        // case-insensitively.
		        if (this.isWindows) {
		            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
		            const fileUNC = !fileDrive &&
		                file[0] === '' &&
		                file[1] === '' &&
		                file[2] === '?' &&
		                /^[a-z]:$/i.test(file[3]);
		            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
		            const patternUNC = !patternDrive &&
		                pattern[0] === '' &&
		                pattern[1] === '' &&
		                pattern[2] === '?' &&
		                typeof pattern[3] === 'string' &&
		                /^[a-z]:$/i.test(pattern[3]);
		            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
		            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
		            if (typeof fdi === 'number' && typeof pdi === 'number') {
		                const [fd, pd] = [file[fdi], pattern[pdi]];
		                if (fd.toLowerCase() === pd.toLowerCase()) {
		                    pattern[pdi] = fd;
		                    if (pdi > fdi) {
		                        pattern = pattern.slice(pdi);
		                    }
		                    else if (fdi > pdi) {
		                        file = file.slice(fdi);
		                    }
		                }
		            }
		        }
		        // resolve and reduce . and .. portions in the file as well.
		        // dont' need to do the second phase, because it's only one string[]
		        const { optimizationLevel = 1 } = this.options;
		        if (optimizationLevel >= 2) {
		            file = this.levelTwoFileOptimize(file);
		        }
		        this.debug('matchOne', this, { file, pattern });
		        this.debug('matchOne', file.length, pattern.length);
		        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
		            this.debug('matchOne loop');
		            var p = pattern[pi];
		            var f = file[fi];
		            this.debug(pattern, p, f);
		            // should be impossible.
		            // some invalid regexp stuff in the set.
		            /* c8 ignore start */
		            if (p === false) {
		                return false;
		            }
		            /* c8 ignore stop */
		            if (p === exports.GLOBSTAR) {
		                this.debug('GLOBSTAR', [pattern, p, f]);
		                // "**"
		                // a/**/b/**/c would match the following:
		                // a/b/x/y/z/c
		                // a/x/y/z/b/c
		                // a/b/x/b/x/c
		                // a/b/c
		                // To do this, take the rest of the pattern after
		                // the **, and see if it would match the file remainder.
		                // If so, return success.
		                // If not, the ** "swallows" a segment, and try again.
		                // This is recursively awful.
		                //
		                // a/**/b/**/c matching a/b/x/y/z/c
		                // - a matches a
		                // - doublestar
		                //   - matchOne(b/x/y/z/c, b/**/c)
		                //     - b matches b
		                //     - doublestar
		                //       - matchOne(x/y/z/c, c) -> no
		                //       - matchOne(y/z/c, c) -> no
		                //       - matchOne(z/c, c) -> no
		                //       - matchOne(c, c) yes, hit
		                var fr = fi;
		                var pr = pi + 1;
		                if (pr === pl) {
		                    this.debug('** at the end');
		                    // a ** at the end will just swallow the rest.
		                    // We have found a match.
		                    // however, it will not swallow /.x, unless
		                    // options.dot is set.
		                    // . and .. are *never* matched by **, for explosively
		                    // exponential reasons.
		                    for (; fi < fl; fi++) {
		                        if (file[fi] === '.' ||
		                            file[fi] === '..' ||
		                            (!options.dot && file[fi].charAt(0) === '.'))
		                            return false;
		                    }
		                    return true;
		                }
		                // ok, let's see if we can swallow whatever we can.
		                while (fr < fl) {
		                    var swallowee = file[fr];
		                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
		                    // XXX remove this slice.  Just pass the start index.
		                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
		                        this.debug('globstar found match!', fr, fl, swallowee);
		                        // found a match.
		                        return true;
		                    }
		                    else {
		                        // can't swallow "." or ".." ever.
		                        // can only swallow ".foo" when explicitly asked.
		                        if (swallowee === '.' ||
		                            swallowee === '..' ||
		                            (!options.dot && swallowee.charAt(0) === '.')) {
		                            this.debug('dot detected!', file, fr, pattern, pr);
		                            break;
		                        }
		                        // ** swallows a segment, and continue.
		                        this.debug('globstar swallow a segment, and continue');
		                        fr++;
		                    }
		                }
		                // no match was found.
		                // However, in partial mode, we can't say this is necessarily over.
		                /* c8 ignore start */
		                if (partial) {
		                    // ran out of file
		                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
		                    if (fr === fl) {
		                        return true;
		                    }
		                }
		                /* c8 ignore stop */
		                return false;
		            }
		            // something other than **
		            // non-magic patterns just have to match exactly
		            // patterns with magic have been turned into regexps.
		            let hit;
		            if (typeof p === 'string') {
		                hit = f === p;
		                this.debug('string match', p, f, hit);
		            }
		            else {
		                hit = p.test(f);
		                this.debug('pattern match', p, f, hit);
		            }
		            if (!hit)
		                return false;
		        }
		        // Note: ending in / means that we'll get a final ""
		        // at the end of the pattern.  This can only match a
		        // corresponding "" at the end of the file.
		        // If the file ends in /, then it can only match a
		        // a pattern that ends in /, unless the pattern just
		        // doesn't have any more for it. But, a/b/ should *not*
		        // match "a/b/*", even though "" matches against the
		        // [^/]*? pattern, except in partial mode, where it might
		        // simply not be reached yet.
		        // However, a/b/ should still satisfy a/*
		        // now either we fell off the end of the pattern, or we're done.
		        if (fi === fl && pi === pl) {
		            // ran out of pattern and filename at the same time.
		            // an exact hit!
		            return true;
		        }
		        else if (fi === fl) {
		            // ran out of file, but still had pattern left.
		            // this is ok if we're doing the match as part of
		            // a glob fs traversal.
		            return partial;
		        }
		        else if (pi === pl) {
		            // ran out of pattern, still have file left.
		            // this is only acceptable if we're on the very last
		            // empty segment of a file with a trailing slash.
		            // a/* should match a/b/
		            return fi === fl - 1 && file[fi] === '';
		            /* c8 ignore start */
		        }
		        else {
		            // should be unreachable.
		            throw new Error('wtf?');
		        }
		        /* c8 ignore stop */
		    }
		    braceExpand() {
		        return (0, exports.braceExpand)(this.pattern, this.options);
		    }
		    parse(pattern) {
		        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
		        const options = this.options;
		        // shortcuts
		        if (pattern === '**')
		            return exports.GLOBSTAR;
		        if (pattern === '')
		            return '';
		        // far and away, the most common glob pattern parts are
		        // *, *.*, and *.<ext>  Add a fast check method for those.
		        let m;
		        let fastTest = null;
		        if ((m = pattern.match(starRE))) {
		            fastTest = options.dot ? starTestDot : starTest;
		        }
		        else if ((m = pattern.match(starDotExtRE))) {
		            fastTest = (options.nocase
		                ? options.dot
		                    ? starDotExtTestNocaseDot
		                    : starDotExtTestNocase
		                : options.dot
		                    ? starDotExtTestDot
		                    : starDotExtTest)(m[1]);
		        }
		        else if ((m = pattern.match(qmarksRE))) {
		            fastTest = (options.nocase
		                ? options.dot
		                    ? qmarksTestNocaseDot
		                    : qmarksTestNocase
		                : options.dot
		                    ? qmarksTestDot
		                    : qmarksTest)(m);
		        }
		        else if ((m = pattern.match(starDotStarRE))) {
		            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
		        }
		        else if ((m = pattern.match(dotStarRE))) {
		            fastTest = dotStarTest;
		        }
		        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
		        if (fastTest && typeof re === 'object') {
		            // Avoids overriding in frozen environments
		            Reflect.defineProperty(re, 'test', { value: fastTest });
		        }
		        return re;
		    }
		    makeRe() {
		        if (this.regexp || this.regexp === false)
		            return this.regexp;
		        // at this point, this.set is a 2d array of partial
		        // pattern strings, or "**".
		        //
		        // It's better to use .match().  This function shouldn't
		        // be used, really, but it's pretty convenient sometimes,
		        // when you just want to work with a regex.
		        const set = this.set;
		        if (!set.length) {
		            this.regexp = false;
		            return this.regexp;
		        }
		        const options = this.options;
		        const twoStar = options.noglobstar
		            ? star
		            : options.dot
		                ? twoStarDot
		                : twoStarNoDot;
		        const flags = new Set(options.nocase ? ['i'] : []);
		        // regexpify non-globstar patterns
		        // if ** is only item, then we just do one twoStar
		        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
		        // if ** is last, append (\/twoStar|) to previous
		        // if ** is in the middle, append (\/|\/twoStar\/) to previous
		        // then filter out GLOBSTAR symbols
		        let re = set
		            .map(pattern => {
		            const pp = pattern.map(p => {
		                if (p instanceof RegExp) {
		                    for (const f of p.flags.split(''))
		                        flags.add(f);
		                }
		                return typeof p === 'string'
		                    ? regExpEscape(p)
		                    : p === exports.GLOBSTAR
		                        ? exports.GLOBSTAR
		                        : p._src;
		            });
		            pp.forEach((p, i) => {
		                const next = pp[i + 1];
		                const prev = pp[i - 1];
		                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
		                    return;
		                }
		                if (prev === undefined) {
		                    if (next !== undefined && next !== exports.GLOBSTAR) {
		                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
		                    }
		                    else {
		                        pp[i] = twoStar;
		                    }
		                }
		                else if (next === undefined) {
		                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
		                }
		                else if (next !== exports.GLOBSTAR) {
		                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
		                    pp[i + 1] = exports.GLOBSTAR;
		                }
		            });
		            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
		        })
		            .join('|');
		        // need to wrap in parens if we had more than one thing with |,
		        // otherwise only the first will be anchored to ^ and the last to $
		        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
		        // must match entire pattern
		        // ending in a * or ** will make it less strict.
		        re = '^' + open + re + close + '$';
		        // can match anything, as long as it's not this.
		        if (this.negate)
		            re = '^(?!' + re + ').+$';
		        try {
		            this.regexp = new RegExp(re, [...flags].join(''));
		            /* c8 ignore start */
		        }
		        catch (ex) {
		            // should be impossible
		            this.regexp = false;
		        }
		        /* c8 ignore stop */
		        return this.regexp;
		    }
		    slashSplit(p) {
		        // if p starts with // on windows, we preserve that
		        // so that UNC paths aren't broken.  Otherwise, any number of
		        // / characters are coalesced into one, unless
		        // preserveMultipleSlashes is set to true.
		        if (this.preserveMultipleSlashes) {
		            return p.split('/');
		        }
		        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
		            // add an extra '' for the one we lose
		            return ['', ...p.split(/\/+/)];
		        }
		        else {
		            return p.split(/\/+/);
		        }
		    }
		    match(f, partial = this.partial) {
		        this.debug('match', f, this.pattern);
		        // short-circuit in the case of busted things.
		        // comments, etc.
		        if (this.comment) {
		            return false;
		        }
		        if (this.empty) {
		            return f === '';
		        }
		        if (f === '/' && partial) {
		            return true;
		        }
		        const options = this.options;
		        // windows: need to use /, not \
		        if (this.isWindows) {
		            f = f.split('\\').join('/');
		        }
		        // treat the test path as a set of pathparts.
		        const ff = this.slashSplit(f);
		        this.debug(this.pattern, 'split', ff);
		        // just ONE of the pattern sets in this.set needs to match
		        // in order for it to be valid.  If negating, then just one
		        // match means that we have failed.
		        // Either way, return on the first hit.
		        const set = this.set;
		        this.debug(this.pattern, 'set', set);
		        // Find the basename of the path by looking for the last non-empty segment
		        let filename = ff[ff.length - 1];
		        if (!filename) {
		            for (let i = ff.length - 2; !filename && i >= 0; i--) {
		                filename = ff[i];
		            }
		        }
		        for (let i = 0; i < set.length; i++) {
		            const pattern = set[i];
		            let file = ff;
		            if (options.matchBase && pattern.length === 1) {
		                file = [filename];
		            }
		            const hit = this.matchOne(file, pattern, partial);
		            if (hit) {
		                if (options.flipNegate) {
		                    return true;
		                }
		                return !this.negate;
		            }
		        }
		        // didn't get any hits.  this is success if it's a negative
		        // pattern, failure otherwise.
		        if (options.flipNegate) {
		            return false;
		        }
		        return this.negate;
		    }
		    static defaults(def) {
		        return exports.minimatch.defaults(def).Minimatch;
		    }
		}
		exports.Minimatch = Minimatch;
		/* c8 ignore start */
		var ast_js_2 = requireAst();
		Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
		var escape_js_2 = require_escape();
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
		var unescape_js_2 = require_unescape();
		Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
		/* c8 ignore stop */
		exports.minimatch.AST = ast_js_1.AST;
		exports.minimatch.Minimatch = Minimatch;
		exports.minimatch.escape = escape_js_1.escape;
		exports.minimatch.unescape = unescape_js_1.unescape;
		
	} (commonjs$5));
	return commonjs$5;
}

var glob = {};

var commonjs$2 = {};

var commonjs$1 = {};

var hasRequiredCommonjs$3;

function requireCommonjs$3 () {
	if (hasRequiredCommonjs$3) return commonjs$1;
	hasRequiredCommonjs$3 = 1;
	/**
	 * @module LRUCache
	 */
	Object.defineProperty(commonjs$1, "__esModule", { value: true });
	commonjs$1.LRUCache = void 0;
	const perf = typeof performance === 'object' &&
	    performance &&
	    typeof performance.now === 'function'
	    ? performance
	    : Date;
	const warned = new Set();
	/* c8 ignore start */
	const PROCESS = (typeof process === 'object' && !!process ? process : {});
	/* c8 ignore start */
	const emitWarning = (msg, type, code, fn) => {
	    typeof PROCESS.emitWarning === 'function'
	        ? PROCESS.emitWarning(msg, type, code, fn)
	        : console.error(`[${code}] ${type}: ${msg}`);
	};
	let AC = globalThis.AbortController;
	let AS = globalThis.AbortSignal;
	/* c8 ignore start */
	if (typeof AC === 'undefined') {
	    //@ts-ignore
	    AS = class AbortSignal {
	        onabort;
	        _onabort = [];
	        reason;
	        aborted = false;
	        addEventListener(_, fn) {
	            this._onabort.push(fn);
	        }
	    };
	    //@ts-ignore
	    AC = class AbortController {
	        constructor() {
	            warnACPolyfill();
	        }
	        signal = new AS();
	        abort(reason) {
	            if (this.signal.aborted)
	                return;
	            //@ts-ignore
	            this.signal.reason = reason;
	            //@ts-ignore
	            this.signal.aborted = true;
	            //@ts-ignore
	            for (const fn of this.signal._onabort) {
	                fn(reason);
	            }
	            this.signal.onabort?.(reason);
	        }
	    };
	    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
	    const warnACPolyfill = () => {
	        if (!printACPolyfillWarning)
	            return;
	        printACPolyfillWarning = false;
	        emitWarning('AbortController is not defined. If using lru-cache in ' +
	            'node 14, load an AbortController polyfill from the ' +
	            '`node-abort-controller` package. A minimal polyfill is ' +
	            'provided for use by LRUCache.fetch(), but it should not be ' +
	            'relied upon in other contexts (eg, passing it to other APIs that ' +
	            'use AbortController/AbortSignal might have undesirable effects). ' +
	            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
	    };
	}
	/* c8 ignore stop */
	const shouldWarn = (code) => !warned.has(code);
	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
	/* c8 ignore start */
	// This is a little bit ridiculous, tbh.
	// The maximum array length is 2^32-1 or thereabouts on most JS impls.
	// And well before that point, you're caching the entire world, I mean,
	// that's ~32GB of just integers for the next/prev links, plus whatever
	// else to hold that many keys and values.  Just filling the memory with
	// zeroes at init time is brutal when you get that big.
	// But why not be complete?
	// Maybe in the future, these limits will have expanded.
	const getUintArray = (max) => !isPosInt(max)
	    ? null
	    : max <= Math.pow(2, 8)
	        ? Uint8Array
	        : max <= Math.pow(2, 16)
	            ? Uint16Array
	            : max <= Math.pow(2, 32)
	                ? Uint32Array
	                : max <= Number.MAX_SAFE_INTEGER
	                    ? ZeroArray
	                    : null;
	/* c8 ignore stop */
	class ZeroArray extends Array {
	    constructor(size) {
	        super(size);
	        this.fill(0);
	    }
	}
	class Stack {
	    heap;
	    length;
	    // private constructor
	    static #constructing = false;
	    static create(max) {
	        const HeapCls = getUintArray(max);
	        if (!HeapCls)
	            return [];
	        Stack.#constructing = true;
	        const s = new Stack(max, HeapCls);
	        Stack.#constructing = false;
	        return s;
	    }
	    constructor(max, HeapCls) {
	        /* c8 ignore start */
	        if (!Stack.#constructing) {
	            throw new TypeError('instantiate Stack using Stack.create(n)');
	        }
	        /* c8 ignore stop */
	        this.heap = new HeapCls(max);
	        this.length = 0;
	    }
	    push(n) {
	        this.heap[this.length++] = n;
	    }
	    pop() {
	        return this.heap[--this.length];
	    }
	}
	/**
	 * Default export, the thing you're using this module to get.
	 *
	 * The `K` and `V` types define the key and value types, respectively. The
	 * optional `FC` type defines the type of the `context` object passed to
	 * `cache.fetch()` and `cache.memo()`.
	 *
	 * Keys and values **must not** be `null` or `undefined`.
	 *
	 * All properties from the options object (with the exception of `max`,
	 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
	 * added as normal public members. (The listed options are read-only getters.)
	 *
	 * Changing any of these will alter the defaults for subsequent method calls.
	 */
	class LRUCache {
	    // options that cannot be changed without disaster
	    #max;
	    #maxSize;
	    #dispose;
	    #onInsert;
	    #disposeAfter;
	    #fetchMethod;
	    #memoMethod;
	    /**
	     * {@link LRUCache.OptionsBase.ttl}
	     */
	    ttl;
	    /**
	     * {@link LRUCache.OptionsBase.ttlResolution}
	     */
	    ttlResolution;
	    /**
	     * {@link LRUCache.OptionsBase.ttlAutopurge}
	     */
	    ttlAutopurge;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnGet}
	     */
	    updateAgeOnGet;
	    /**
	     * {@link LRUCache.OptionsBase.updateAgeOnHas}
	     */
	    updateAgeOnHas;
	    /**
	     * {@link LRUCache.OptionsBase.allowStale}
	     */
	    allowStale;
	    /**
	     * {@link LRUCache.OptionsBase.noDisposeOnSet}
	     */
	    noDisposeOnSet;
	    /**
	     * {@link LRUCache.OptionsBase.noUpdateTTL}
	     */
	    noUpdateTTL;
	    /**
	     * {@link LRUCache.OptionsBase.maxEntrySize}
	     */
	    maxEntrySize;
	    /**
	     * {@link LRUCache.OptionsBase.sizeCalculation}
	     */
	    sizeCalculation;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
	     */
	    noDeleteOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
	     */
	    noDeleteOnStaleGet;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
	     */
	    allowStaleOnFetchAbort;
	    /**
	     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
	     */
	    allowStaleOnFetchRejection;
	    /**
	     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
	     */
	    ignoreFetchAbort;
	    // computed properties
	    #size;
	    #calculatedSize;
	    #keyMap;
	    #keyList;
	    #valList;
	    #next;
	    #prev;
	    #head;
	    #tail;
	    #free;
	    #disposed;
	    #sizes;
	    #starts;
	    #ttls;
	    #hasDispose;
	    #hasFetchMethod;
	    #hasDisposeAfter;
	    #hasOnInsert;
	    /**
	     * Do not call this method unless you need to inspect the
	     * inner workings of the cache.  If anything returned by this
	     * object is modified in any way, strange breakage may occur.
	     *
	     * These fields are private for a reason!
	     *
	     * @internal
	     */
	    static unsafeExposeInternals(c) {
	        return {
	            // properties
	            starts: c.#starts,
	            ttls: c.#ttls,
	            sizes: c.#sizes,
	            keyMap: c.#keyMap,
	            keyList: c.#keyList,
	            valList: c.#valList,
	            next: c.#next,
	            prev: c.#prev,
	            get head() {
	                return c.#head;
	            },
	            get tail() {
	                return c.#tail;
	            },
	            free: c.#free,
	            // methods
	            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
	            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
	            moveToTail: (index) => c.#moveToTail(index),
	            indexes: (options) => c.#indexes(options),
	            rindexes: (options) => c.#rindexes(options),
	            isStale: (index) => c.#isStale(index),
	        };
	    }
	    // Protected read-only members
	    /**
	     * {@link LRUCache.OptionsBase.max} (read-only)
	     */
	    get max() {
	        return this.#max;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.maxSize} (read-only)
	     */
	    get maxSize() {
	        return this.#maxSize;
	    }
	    /**
	     * The total computed size of items in the cache (read-only)
	     */
	    get calculatedSize() {
	        return this.#calculatedSize;
	    }
	    /**
	     * The number of items stored in the cache (read-only)
	     */
	    get size() {
	        return this.#size;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
	     */
	    get fetchMethod() {
	        return this.#fetchMethod;
	    }
	    get memoMethod() {
	        return this.#memoMethod;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.dispose} (read-only)
	     */
	    get dispose() {
	        return this.#dispose;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.onInsert} (read-only)
	     */
	    get onInsert() {
	        return this.#onInsert;
	    }
	    /**
	     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
	     */
	    get disposeAfter() {
	        return this.#disposeAfter;
	    }
	    constructor(options) {
	        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
	        if (max !== 0 && !isPosInt(max)) {
	            throw new TypeError('max option must be a nonnegative integer');
	        }
	        const UintArray = max ? getUintArray(max) : Array;
	        if (!UintArray) {
	            throw new Error('invalid max value: ' + max);
	        }
	        this.#max = max;
	        this.#maxSize = maxSize;
	        this.maxEntrySize = maxEntrySize || this.#maxSize;
	        this.sizeCalculation = sizeCalculation;
	        if (this.sizeCalculation) {
	            if (!this.#maxSize && !this.maxEntrySize) {
	                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
	            }
	            if (typeof this.sizeCalculation !== 'function') {
	                throw new TypeError('sizeCalculation set to non-function');
	            }
	        }
	        if (memoMethod !== undefined &&
	            typeof memoMethod !== 'function') {
	            throw new TypeError('memoMethod must be a function if defined');
	        }
	        this.#memoMethod = memoMethod;
	        if (fetchMethod !== undefined &&
	            typeof fetchMethod !== 'function') {
	            throw new TypeError('fetchMethod must be a function if specified');
	        }
	        this.#fetchMethod = fetchMethod;
	        this.#hasFetchMethod = !!fetchMethod;
	        this.#keyMap = new Map();
	        this.#keyList = new Array(max).fill(undefined);
	        this.#valList = new Array(max).fill(undefined);
	        this.#next = new UintArray(max);
	        this.#prev = new UintArray(max);
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free = Stack.create(max);
	        this.#size = 0;
	        this.#calculatedSize = 0;
	        if (typeof dispose === 'function') {
	            this.#dispose = dispose;
	        }
	        if (typeof onInsert === 'function') {
	            this.#onInsert = onInsert;
	        }
	        if (typeof disposeAfter === 'function') {
	            this.#disposeAfter = disposeAfter;
	            this.#disposed = [];
	        }
	        else {
	            this.#disposeAfter = undefined;
	            this.#disposed = undefined;
	        }
	        this.#hasDispose = !!this.#dispose;
	        this.#hasOnInsert = !!this.#onInsert;
	        this.#hasDisposeAfter = !!this.#disposeAfter;
	        this.noDisposeOnSet = !!noDisposeOnSet;
	        this.noUpdateTTL = !!noUpdateTTL;
	        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
	        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
	        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
	        this.ignoreFetchAbort = !!ignoreFetchAbort;
	        // NB: maxEntrySize is set to maxSize if it's set
	        if (this.maxEntrySize !== 0) {
	            if (this.#maxSize !== 0) {
	                if (!isPosInt(this.#maxSize)) {
	                    throw new TypeError('maxSize must be a positive integer if specified');
	                }
	            }
	            if (!isPosInt(this.maxEntrySize)) {
	                throw new TypeError('maxEntrySize must be a positive integer if specified');
	            }
	            this.#initializeSizeTracking();
	        }
	        this.allowStale = !!allowStale;
	        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
	        this.updateAgeOnGet = !!updateAgeOnGet;
	        this.updateAgeOnHas = !!updateAgeOnHas;
	        this.ttlResolution =
	            isPosInt(ttlResolution) || ttlResolution === 0
	                ? ttlResolution
	                : 1;
	        this.ttlAutopurge = !!ttlAutopurge;
	        this.ttl = ttl || 0;
	        if (this.ttl) {
	            if (!isPosInt(this.ttl)) {
	                throw new TypeError('ttl must be a positive integer if specified');
	            }
	            this.#initializeTTLTracking();
	        }
	        // do not allow completely unbounded caches
	        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
	            throw new TypeError('At least one of max, maxSize, or ttl is required');
	        }
	        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
	            const code = 'LRU_CACHE_UNBOUNDED';
	            if (shouldWarn(code)) {
	                warned.add(code);
	                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
	                    'result in unbounded memory consumption.';
	                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
	            }
	        }
	    }
	    /**
	     * Return the number of ms left in the item's TTL. If item is not in cache,
	     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
	     */
	    getRemainingTTL(key) {
	        return this.#keyMap.has(key) ? Infinity : 0;
	    }
	    #initializeTTLTracking() {
	        const ttls = new ZeroArray(this.#max);
	        const starts = new ZeroArray(this.#max);
	        this.#ttls = ttls;
	        this.#starts = starts;
	        this.#setItemTTL = (index, ttl, start = perf.now()) => {
	            starts[index] = ttl !== 0 ? start : 0;
	            ttls[index] = ttl;
	            if (ttl !== 0 && this.ttlAutopurge) {
	                const t = setTimeout(() => {
	                    if (this.#isStale(index)) {
	                        this.#delete(this.#keyList[index], 'expire');
	                    }
	                }, ttl + 1);
	                // unref() not supported on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	        };
	        this.#updateItemAge = index => {
	            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
	        };
	        this.#statusTTL = (status, index) => {
	            if (ttls[index]) {
	                const ttl = ttls[index];
	                const start = starts[index];
	                /* c8 ignore next */
	                if (!ttl || !start)
	                    return;
	                status.ttl = ttl;
	                status.start = start;
	                status.now = cachedNow || getNow();
	                const age = status.now - start;
	                status.remainingTTL = ttl - age;
	            }
	        };
	        // debounce calls to perf.now() to 1s so we're not hitting
	        // that costly call repeatedly.
	        let cachedNow = 0;
	        const getNow = () => {
	            const n = perf.now();
	            if (this.ttlResolution > 0) {
	                cachedNow = n;
	                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
	                // not available on all platforms
	                /* c8 ignore start */
	                if (t.unref) {
	                    t.unref();
	                }
	                /* c8 ignore stop */
	            }
	            return n;
	        };
	        this.getRemainingTTL = key => {
	            const index = this.#keyMap.get(key);
	            if (index === undefined) {
	                return 0;
	            }
	            const ttl = ttls[index];
	            const start = starts[index];
	            if (!ttl || !start) {
	                return Infinity;
	            }
	            const age = (cachedNow || getNow()) - start;
	            return ttl - age;
	        };
	        this.#isStale = index => {
	            const s = starts[index];
	            const t = ttls[index];
	            return !!t && !!s && (cachedNow || getNow()) - s > t;
	        };
	    }
	    // conditionally set private methods related to TTL
	    #updateItemAge = () => { };
	    #statusTTL = () => { };
	    #setItemTTL = () => { };
	    /* c8 ignore stop */
	    #isStale = () => false;
	    #initializeSizeTracking() {
	        const sizes = new ZeroArray(this.#max);
	        this.#calculatedSize = 0;
	        this.#sizes = sizes;
	        this.#removeItemSize = index => {
	            this.#calculatedSize -= sizes[index];
	            sizes[index] = 0;
	        };
	        this.#requireSize = (k, v, size, sizeCalculation) => {
	            // provisionally accept background fetches.
	            // actual value size will be checked when they return.
	            if (this.#isBackgroundFetch(v)) {
	                return 0;
	            }
	            if (!isPosInt(size)) {
	                if (sizeCalculation) {
	                    if (typeof sizeCalculation !== 'function') {
	                        throw new TypeError('sizeCalculation must be a function');
	                    }
	                    size = sizeCalculation(v, k);
	                    if (!isPosInt(size)) {
	                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
	                    }
	                }
	                else {
	                    throw new TypeError('invalid size value (must be positive integer). ' +
	                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
	                        'or size must be set.');
	                }
	            }
	            return size;
	        };
	        this.#addItemSize = (index, size, status) => {
	            sizes[index] = size;
	            if (this.#maxSize) {
	                const maxSize = this.#maxSize - sizes[index];
	                while (this.#calculatedSize > maxSize) {
	                    this.#evict(true);
	                }
	            }
	            this.#calculatedSize += sizes[index];
	            if (status) {
	                status.entrySize = size;
	                status.totalCalculatedSize = this.#calculatedSize;
	            }
	        };
	    }
	    #removeItemSize = _i => { };
	    #addItemSize = (_i, _s, _st) => { };
	    #requireSize = (_k, _v, size, sizeCalculation) => {
	        if (size || sizeCalculation) {
	            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
	        }
	        return 0;
	    };
	    *#indexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#tail; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#head) {
	                    break;
	                }
	                else {
	                    i = this.#prev[i];
	                }
	            }
	        }
	    }
	    *#rindexes({ allowStale = this.allowStale } = {}) {
	        if (this.#size) {
	            for (let i = this.#head; true;) {
	                if (!this.#isValidIndex(i)) {
	                    break;
	                }
	                if (allowStale || !this.#isStale(i)) {
	                    yield i;
	                }
	                if (i === this.#tail) {
	                    break;
	                }
	                else {
	                    i = this.#next[i];
	                }
	            }
	        }
	    }
	    #isValidIndex(index) {
	        return (index !== undefined &&
	            this.#keyMap.get(this.#keyList[index]) === index);
	    }
	    /**
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from most recently used to least recently used.
	     */
	    *entries() {
	        for (const i of this.#indexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.entries}
	     *
	     * Return a generator yielding `[key, value]` pairs,
	     * in order from least recently used to most recently used.
	     */
	    *rentries() {
	        for (const i of this.#rindexes()) {
	            if (this.#valList[i] !== undefined &&
	                this.#keyList[i] !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield [this.#keyList[i], this.#valList[i]];
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the keys in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *keys() {
	        for (const i of this.#indexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.keys}
	     *
	     * Return a generator yielding the keys in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rkeys() {
	        for (const i of this.#rindexes()) {
	            const k = this.#keyList[i];
	            if (k !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield k;
	            }
	        }
	    }
	    /**
	     * Return a generator yielding the values in the cache,
	     * in order from most recently used to least recently used.
	     */
	    *values() {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Inverse order version of {@link LRUCache.values}
	     *
	     * Return a generator yielding the values in the cache,
	     * in order from least recently used to most recently used.
	     */
	    *rvalues() {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            if (v !== undefined &&
	                !this.#isBackgroundFetch(this.#valList[i])) {
	                yield this.#valList[i];
	            }
	        }
	    }
	    /**
	     * Iterating over the cache itself yields the same results as
	     * {@link LRUCache.entries}
	     */
	    [Symbol.iterator]() {
	        return this.entries();
	    }
	    /**
	     * A String value that is used in the creation of the default string
	     * description of an object. Called by the built-in method
	     * `Object.prototype.toString`.
	     */
	    [Symbol.toStringTag] = 'LRUCache';
	    /**
	     * Find a value for which the supplied fn method returns a truthy value,
	     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
	     */
	    find(fn, getOptions = {}) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            if (fn(value, this.#keyList[i], this)) {
	                return this.get(this.#keyList[i], getOptions);
	            }
	        }
	    }
	    /**
	     * Call the supplied function on each item in the cache, in order from most
	     * recently used to least recently used.
	     *
	     * `fn` is called as `fn(value, key, cache)`.
	     *
	     * If `thisp` is provided, function will be called in the `this`-context of
	     * the provided object, or the cache if no `thisp` object is provided.
	     *
	     * Does not update age or recenty of use, or iterate over stale values.
	     */
	    forEach(fn, thisp = this) {
	        for (const i of this.#indexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * The same as {@link LRUCache.forEach} but items are iterated over in
	     * reverse order.  (ie, less recently used items are iterated over first.)
	     */
	    rforEach(fn, thisp = this) {
	        for (const i of this.#rindexes()) {
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined)
	                continue;
	            fn.call(thisp, value, this.#keyList[i], this);
	        }
	    }
	    /**
	     * Delete any stale entries. Returns true if anything was removed,
	     * false otherwise.
	     */
	    purgeStale() {
	        let deleted = false;
	        for (const i of this.#rindexes({ allowStale: true })) {
	            if (this.#isStale(i)) {
	                this.#delete(this.#keyList[i], 'expire');
	                deleted = true;
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Get the extended info about a given entry, to get its value, size, and
	     * TTL info simultaneously. Returns `undefined` if the key is not present.
	     *
	     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
	     * serialization, the `start` value is always the current timestamp, and the
	     * `ttl` is a calculated remaining time to live (negative if expired).
	     *
	     * Always returns stale values, if their info is found in the cache, so be
	     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
	     * if relevant.
	     */
	    info(key) {
	        const i = this.#keyMap.get(key);
	        if (i === undefined)
	            return undefined;
	        const v = this.#valList[i];
	        const value = this.#isBackgroundFetch(v)
	            ? v.__staleWhileFetching
	            : v;
	        if (value === undefined)
	            return undefined;
	        const entry = { value };
	        if (this.#ttls && this.#starts) {
	            const ttl = this.#ttls[i];
	            const start = this.#starts[i];
	            if (ttl && start) {
	                const remain = ttl - (perf.now() - start);
	                entry.ttl = remain;
	                entry.start = Date.now();
	            }
	        }
	        if (this.#sizes) {
	            entry.size = this.#sizes[i];
	        }
	        return entry;
	    }
	    /**
	     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
	     * passed to {@link LRUCache#load}.
	     *
	     * The `start` fields are calculated relative to a portable `Date.now()`
	     * timestamp, even if `performance.now()` is available.
	     *
	     * Stale entries are always included in the `dump`, even if
	     * {@link LRUCache.OptionsBase.allowStale} is false.
	     *
	     * Note: this returns an actual array, not a generator, so it can be more
	     * easily passed around.
	     */
	    dump() {
	        const arr = [];
	        for (const i of this.#indexes({ allowStale: true })) {
	            const key = this.#keyList[i];
	            const v = this.#valList[i];
	            const value = this.#isBackgroundFetch(v)
	                ? v.__staleWhileFetching
	                : v;
	            if (value === undefined || key === undefined)
	                continue;
	            const entry = { value };
	            if (this.#ttls && this.#starts) {
	                entry.ttl = this.#ttls[i];
	                // always dump the start relative to a portable timestamp
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = perf.now() - this.#starts[i];
	                entry.start = Math.floor(Date.now() - age);
	            }
	            if (this.#sizes) {
	                entry.size = this.#sizes[i];
	            }
	            arr.unshift([key, entry]);
	        }
	        return arr;
	    }
	    /**
	     * Reset the cache and load in the items in entries in the order listed.
	     *
	     * The shape of the resulting cache may be different if the same options are
	     * not used in both caches.
	     *
	     * The `start` fields are assumed to be calculated relative to a portable
	     * `Date.now()` timestamp, even if `performance.now()` is available.
	     */
	    load(arr) {
	        this.clear();
	        for (const [key, entry] of arr) {
	            if (entry.start) {
	                // entry.start is a portable timestamp, but we may be using
	                // node's performance.now(), so calculate the offset, so that
	                // we get the intended remaining TTL, no matter how long it's
	                // been on ice.
	                //
	                // it's ok for this to be a bit slow, it's a rare operation.
	                const age = Date.now() - entry.start;
	                entry.start = perf.now() - age;
	            }
	            this.set(key, entry.value, entry);
	        }
	    }
	    /**
	     * Add a value to the cache.
	     *
	     * Note: if `undefined` is specified as a value, this is an alias for
	     * {@link LRUCache#delete}
	     *
	     * Fields on the {@link LRUCache.SetOptions} options param will override
	     * their corresponding values in the constructor options for the scope
	     * of this single `set()` operation.
	     *
	     * If `start` is provided, then that will set the effective start
	     * time for the TTL calculation. Note that this must be a previous
	     * value of `performance.now()` if supported, or a previous value of
	     * `Date.now()` if not.
	     *
	     * Options object may also include `size`, which will prevent
	     * calling the `sizeCalculation` function and just use the specified
	     * number if it is a positive integer, and `noDisposeOnSet` which
	     * will prevent calling a `dispose` function in the case of
	     * overwrites.
	     *
	     * If the `size` (or return value of `sizeCalculation`) for a given
	     * entry is greater than `maxEntrySize`, then the item will not be
	     * added to the cache.
	     *
	     * Will update the recency of the entry.
	     *
	     * If the value is `undefined`, then this is an alias for
	     * `cache.delete(key)`. `undefined` is never stored in the cache.
	     */
	    set(k, v, setOptions = {}) {
	        if (v === undefined) {
	            this.delete(k);
	            return this;
	        }
	        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
	        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
	        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
	        // if the item doesn't fit, don't do anything
	        // NB: maxEntrySize set to maxSize by default
	        if (this.maxEntrySize && size > this.maxEntrySize) {
	            if (status) {
	                status.set = 'miss';
	                status.maxEntrySizeExceeded = true;
	            }
	            // have to delete, in case something is there already.
	            this.#delete(k, 'set');
	            return this;
	        }
	        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
	        if (index === undefined) {
	            // addition
	            index = (this.#size === 0
	                ? this.#tail
	                : this.#free.length !== 0
	                    ? this.#free.pop()
	                    : this.#size === this.#max
	                        ? this.#evict(false)
	                        : this.#size);
	            this.#keyList[index] = k;
	            this.#valList[index] = v;
	            this.#keyMap.set(k, index);
	            this.#next[this.#tail] = index;
	            this.#prev[index] = this.#tail;
	            this.#tail = index;
	            this.#size++;
	            this.#addItemSize(index, size, status);
	            if (status)
	                status.set = 'add';
	            noUpdateTTL = false;
	            if (this.#hasOnInsert) {
	                this.#onInsert?.(v, k, 'add');
	            }
	        }
	        else {
	            // update
	            this.#moveToTail(index);
	            const oldVal = this.#valList[index];
	            if (v !== oldVal) {
	                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
	                    oldVal.__abortController.abort(new Error('replaced'));
	                    const { __staleWhileFetching: s } = oldVal;
	                    if (s !== undefined && !noDisposeOnSet) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(s, k, 'set');
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([s, k, 'set']);
	                        }
	                    }
	                }
	                else if (!noDisposeOnSet) {
	                    if (this.#hasDispose) {
	                        this.#dispose?.(oldVal, k, 'set');
	                    }
	                    if (this.#hasDisposeAfter) {
	                        this.#disposed?.push([oldVal, k, 'set']);
	                    }
	                }
	                this.#removeItemSize(index);
	                this.#addItemSize(index, size, status);
	                this.#valList[index] = v;
	                if (status) {
	                    status.set = 'replace';
	                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
	                        ? oldVal.__staleWhileFetching
	                        : oldVal;
	                    if (oldValue !== undefined)
	                        status.oldValue = oldValue;
	                }
	            }
	            else if (status) {
	                status.set = 'update';
	            }
	            if (this.#hasOnInsert) {
	                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
	            }
	        }
	        if (ttl !== 0 && !this.#ttls) {
	            this.#initializeTTLTracking();
	        }
	        if (this.#ttls) {
	            if (!noUpdateTTL) {
	                this.#setItemTTL(index, ttl, start);
	            }
	            if (status)
	                this.#statusTTL(status, index);
	        }
	        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return this;
	    }
	    /**
	     * Evict the least recently used item, returning its value or
	     * `undefined` if cache is empty.
	     */
	    pop() {
	        try {
	            while (this.#size) {
	                const val = this.#valList[this.#head];
	                this.#evict(true);
	                if (this.#isBackgroundFetch(val)) {
	                    if (val.__staleWhileFetching) {
	                        return val.__staleWhileFetching;
	                    }
	                }
	                else if (val !== undefined) {
	                    return val;
	                }
	            }
	        }
	        finally {
	            if (this.#hasDisposeAfter && this.#disposed) {
	                const dt = this.#disposed;
	                let task;
	                while ((task = dt?.shift())) {
	                    this.#disposeAfter?.(...task);
	                }
	            }
	        }
	    }
	    #evict(free) {
	        const head = this.#head;
	        const k = this.#keyList[head];
	        const v = this.#valList[head];
	        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
	            v.__abortController.abort(new Error('evicted'));
	        }
	        else if (this.#hasDispose || this.#hasDisposeAfter) {
	            if (this.#hasDispose) {
	                this.#dispose?.(v, k, 'evict');
	            }
	            if (this.#hasDisposeAfter) {
	                this.#disposed?.push([v, k, 'evict']);
	            }
	        }
	        this.#removeItemSize(head);
	        // if we aren't about to use the index, then null these out
	        if (free) {
	            this.#keyList[head] = undefined;
	            this.#valList[head] = undefined;
	            this.#free.push(head);
	        }
	        if (this.#size === 1) {
	            this.#head = this.#tail = 0;
	            this.#free.length = 0;
	        }
	        else {
	            this.#head = this.#next[head];
	        }
	        this.#keyMap.delete(k);
	        this.#size--;
	        return head;
	    }
	    /**
	     * Check if a key is in the cache, without updating the recency of use.
	     * Will return false if the item is stale, even though it is technically
	     * in the cache.
	     *
	     * Check if a key is in the cache, without updating the recency of
	     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
	     * to `true` in either the options or the constructor.
	     *
	     * Will return `false` if the item is stale, even though it is technically in
	     * the cache. The difference can be determined (if it matters) by using a
	     * `status` argument, and inspecting the `has` field.
	     *
	     * Will not update item age unless
	     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
	     */
	    has(k, hasOptions = {}) {
	        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v) &&
	                v.__staleWhileFetching === undefined) {
	                return false;
	            }
	            if (!this.#isStale(index)) {
	                if (updateAgeOnHas) {
	                    this.#updateItemAge(index);
	                }
	                if (status) {
	                    status.has = 'hit';
	                    this.#statusTTL(status, index);
	                }
	                return true;
	            }
	            else if (status) {
	                status.has = 'stale';
	                this.#statusTTL(status, index);
	            }
	        }
	        else if (status) {
	            status.has = 'miss';
	        }
	        return false;
	    }
	    /**
	     * Like {@link LRUCache#get} but doesn't update recency or delete stale
	     * items.
	     *
	     * Returns `undefined` if the item is stale, unless
	     * {@link LRUCache.OptionsBase.allowStale} is set.
	     */
	    peek(k, peekOptions = {}) {
	        const { allowStale = this.allowStale } = peekOptions;
	        const index = this.#keyMap.get(k);
	        if (index === undefined ||
	            (!allowStale && this.#isStale(index))) {
	            return;
	        }
	        const v = this.#valList[index];
	        // either stale and allowed, or forcing a refresh of non-stale value
	        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
	    }
	    #backgroundFetch(k, index, options, context) {
	        const v = index === undefined ? undefined : this.#valList[index];
	        if (this.#isBackgroundFetch(v)) {
	            return v;
	        }
	        const ac = new AC();
	        const { signal } = options;
	        // when/if our AC signals, then stop listening to theirs.
	        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
	            signal: ac.signal,
	        });
	        const fetchOpts = {
	            signal: ac.signal,
	            options,
	            context,
	        };
	        const cb = (v, updateCache = false) => {
	            const { aborted } = ac.signal;
	            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
	            if (options.status) {
	                if (aborted && !updateCache) {
	                    options.status.fetchAborted = true;
	                    options.status.fetchError = ac.signal.reason;
	                    if (ignoreAbort)
	                        options.status.fetchAbortIgnored = true;
	                }
	                else {
	                    options.status.fetchResolved = true;
	                }
	            }
	            if (aborted && !ignoreAbort && !updateCache) {
	                return fetchFail(ac.signal.reason);
	            }
	            // either we didn't abort, and are still here, or we did, and ignored
	            const bf = p;
	            if (this.#valList[index] === p) {
	                if (v === undefined) {
	                    if (bf.__staleWhileFetching) {
	                        this.#valList[index] = bf.__staleWhileFetching;
	                    }
	                    else {
	                        this.#delete(k, 'fetch');
	                    }
	                }
	                else {
	                    if (options.status)
	                        options.status.fetchUpdated = true;
	                    this.set(k, v, fetchOpts.options);
	                }
	            }
	            return v;
	        };
	        const eb = (er) => {
	            if (options.status) {
	                options.status.fetchRejected = true;
	                options.status.fetchError = er;
	            }
	            return fetchFail(er);
	        };
	        const fetchFail = (er) => {
	            const { aborted } = ac.signal;
	            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
	            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
	            const noDelete = allowStale || options.noDeleteOnFetchRejection;
	            const bf = p;
	            if (this.#valList[index] === p) {
	                // if we allow stale on fetch rejections, then we need to ensure that
	                // the stale value is not removed from the cache when the fetch fails.
	                const del = !noDelete || bf.__staleWhileFetching === undefined;
	                if (del) {
	                    this.#delete(k, 'fetch');
	                }
	                else if (!allowStaleAborted) {
	                    // still replace the *promise* with the stale value,
	                    // since we are done with the promise at this point.
	                    // leave it untouched if we're still waiting for an
	                    // aborted background fetch that hasn't yet returned.
	                    this.#valList[index] = bf.__staleWhileFetching;
	                }
	            }
	            if (allowStale) {
	                if (options.status && bf.__staleWhileFetching !== undefined) {
	                    options.status.returnedStale = true;
	                }
	                return bf.__staleWhileFetching;
	            }
	            else if (bf.__returned === bf) {
	                throw er;
	            }
	        };
	        const pcall = (res, rej) => {
	            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
	            if (fmp && fmp instanceof Promise) {
	                fmp.then(v => res(v === undefined ? undefined : v), rej);
	            }
	            // ignored, we go until we finish, regardless.
	            // defer check until we are actually aborting,
	            // so fetchMethod can override.
	            ac.signal.addEventListener('abort', () => {
	                if (!options.ignoreFetchAbort ||
	                    options.allowStaleOnFetchAbort) {
	                    res(undefined);
	                    // when it eventually resolves, update the cache.
	                    if (options.allowStaleOnFetchAbort) {
	                        res = v => cb(v, true);
	                    }
	                }
	            });
	        };
	        if (options.status)
	            options.status.fetchDispatched = true;
	        const p = new Promise(pcall).then(cb, eb);
	        const bf = Object.assign(p, {
	            __abortController: ac,
	            __staleWhileFetching: v,
	            __returned: undefined,
	        });
	        if (index === undefined) {
	            // internal, don't expose status.
	            this.set(k, bf, { ...fetchOpts.options, status: undefined });
	            index = this.#keyMap.get(k);
	        }
	        else {
	            this.#valList[index] = bf;
	        }
	        return bf;
	    }
	    #isBackgroundFetch(p) {
	        if (!this.#hasFetchMethod)
	            return false;
	        const b = p;
	        return (!!b &&
	            b instanceof Promise &&
	            b.hasOwnProperty('__staleWhileFetching') &&
	            b.__abortController instanceof AC);
	    }
	    async fetch(k, fetchOptions = {}) {
	        const { 
	        // get options
	        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
	        // set options
	        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
	        // fetch exclusive options
	        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
	        if (!this.#hasFetchMethod) {
	            if (status)
	                status.fetch = 'get';
	            return this.get(k, {
	                allowStale,
	                updateAgeOnGet,
	                noDeleteOnStaleGet,
	                status,
	            });
	        }
	        const options = {
	            allowStale,
	            updateAgeOnGet,
	            noDeleteOnStaleGet,
	            ttl,
	            noDisposeOnSet,
	            size,
	            sizeCalculation,
	            noUpdateTTL,
	            noDeleteOnFetchRejection,
	            allowStaleOnFetchRejection,
	            allowStaleOnFetchAbort,
	            ignoreFetchAbort,
	            status,
	            signal,
	        };
	        let index = this.#keyMap.get(k);
	        if (index === undefined) {
	            if (status)
	                status.fetch = 'miss';
	            const p = this.#backgroundFetch(k, index, options, context);
	            return (p.__returned = p);
	        }
	        else {
	            // in cache, maybe already fetching
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                const stale = allowStale && v.__staleWhileFetching !== undefined;
	                if (status) {
	                    status.fetch = 'inflight';
	                    if (stale)
	                        status.returnedStale = true;
	                }
	                return stale ? v.__staleWhileFetching : (v.__returned = v);
	            }
	            // if we force a refresh, that means do NOT serve the cached value,
	            // unless we are already in the process of refreshing the cache.
	            const isStale = this.#isStale(index);
	            if (!forceRefresh && !isStale) {
	                if (status)
	                    status.fetch = 'hit';
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                if (status)
	                    this.#statusTTL(status, index);
	                return v;
	            }
	            // ok, it is stale or a forced refresh, and not already fetching.
	            // refresh the cache.
	            const p = this.#backgroundFetch(k, index, options, context);
	            const hasStale = p.__staleWhileFetching !== undefined;
	            const staleVal = hasStale && allowStale;
	            if (status) {
	                status.fetch = isStale ? 'stale' : 'refresh';
	                if (staleVal && isStale)
	                    status.returnedStale = true;
	            }
	            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
	        }
	    }
	    async forceFetch(k, fetchOptions = {}) {
	        const v = await this.fetch(k, fetchOptions);
	        if (v === undefined)
	            throw new Error('fetch() returned undefined');
	        return v;
	    }
	    memo(k, memoOptions = {}) {
	        const memoMethod = this.#memoMethod;
	        if (!memoMethod) {
	            throw new Error('no memoMethod provided to constructor');
	        }
	        const { context, forceRefresh, ...options } = memoOptions;
	        const v = this.get(k, options);
	        if (!forceRefresh && v !== undefined)
	            return v;
	        const vv = memoMethod(k, v, {
	            options,
	            context,
	        });
	        this.set(k, vv, options);
	        return vv;
	    }
	    /**
	     * Return a value from the cache. Will update the recency of the cache
	     * entry found.
	     *
	     * If the key is not found, get() will return `undefined`.
	     */
	    get(k, getOptions = {}) {
	        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
	        const index = this.#keyMap.get(k);
	        if (index !== undefined) {
	            const value = this.#valList[index];
	            const fetching = this.#isBackgroundFetch(value);
	            if (status)
	                this.#statusTTL(status, index);
	            if (this.#isStale(index)) {
	                if (status)
	                    status.get = 'stale';
	                // delete only if not an in-flight background fetch
	                if (!fetching) {
	                    if (!noDeleteOnStaleGet) {
	                        this.#delete(k, 'expire');
	                    }
	                    if (status && allowStale)
	                        status.returnedStale = true;
	                    return allowStale ? value : undefined;
	                }
	                else {
	                    if (status &&
	                        allowStale &&
	                        value.__staleWhileFetching !== undefined) {
	                        status.returnedStale = true;
	                    }
	                    return allowStale ? value.__staleWhileFetching : undefined;
	                }
	            }
	            else {
	                if (status)
	                    status.get = 'hit';
	                // if we're currently fetching it, we don't actually have it yet
	                // it's not stale, which means this isn't a staleWhileRefetching.
	                // If it's not stale, and fetching, AND has a __staleWhileFetching
	                // value, then that means the user fetched with {forceRefresh:true},
	                // so it's safe to return that value.
	                if (fetching) {
	                    return value.__staleWhileFetching;
	                }
	                this.#moveToTail(index);
	                if (updateAgeOnGet) {
	                    this.#updateItemAge(index);
	                }
	                return value;
	            }
	        }
	        else if (status) {
	            status.get = 'miss';
	        }
	    }
	    #connect(p, n) {
	        this.#prev[n] = p;
	        this.#next[p] = n;
	    }
	    #moveToTail(index) {
	        // if tail already, nothing to do
	        // if head, move head to next[index]
	        // else
	        //   move next[prev[index]] to next[index] (head has no prev)
	        //   move prev[next[index]] to prev[index]
	        // prev[index] = tail
	        // next[tail] = index
	        // tail = index
	        if (index !== this.#tail) {
	            if (index === this.#head) {
	                this.#head = this.#next[index];
	            }
	            else {
	                this.#connect(this.#prev[index], this.#next[index]);
	            }
	            this.#connect(this.#tail, index);
	            this.#tail = index;
	        }
	    }
	    /**
	     * Deletes a key out of the cache.
	     *
	     * Returns true if the key was deleted, false otherwise.
	     */
	    delete(k) {
	        return this.#delete(k, 'delete');
	    }
	    #delete(k, reason) {
	        let deleted = false;
	        if (this.#size !== 0) {
	            const index = this.#keyMap.get(k);
	            if (index !== undefined) {
	                deleted = true;
	                if (this.#size === 1) {
	                    this.#clear(reason);
	                }
	                else {
	                    this.#removeItemSize(index);
	                    const v = this.#valList[index];
	                    if (this.#isBackgroundFetch(v)) {
	                        v.__abortController.abort(new Error('deleted'));
	                    }
	                    else if (this.#hasDispose || this.#hasDisposeAfter) {
	                        if (this.#hasDispose) {
	                            this.#dispose?.(v, k, reason);
	                        }
	                        if (this.#hasDisposeAfter) {
	                            this.#disposed?.push([v, k, reason]);
	                        }
	                    }
	                    this.#keyMap.delete(k);
	                    this.#keyList[index] = undefined;
	                    this.#valList[index] = undefined;
	                    if (index === this.#tail) {
	                        this.#tail = this.#prev[index];
	                    }
	                    else if (index === this.#head) {
	                        this.#head = this.#next[index];
	                    }
	                    else {
	                        const pi = this.#prev[index];
	                        this.#next[pi] = this.#next[index];
	                        const ni = this.#next[index];
	                        this.#prev[ni] = this.#prev[index];
	                    }
	                    this.#size--;
	                    this.#free.push(index);
	                }
	            }
	        }
	        if (this.#hasDisposeAfter && this.#disposed?.length) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	        return deleted;
	    }
	    /**
	     * Clear the cache entirely, throwing away all values.
	     */
	    clear() {
	        return this.#clear('delete');
	    }
	    #clear(reason) {
	        for (const index of this.#rindexes({ allowStale: true })) {
	            const v = this.#valList[index];
	            if (this.#isBackgroundFetch(v)) {
	                v.__abortController.abort(new Error('deleted'));
	            }
	            else {
	                const k = this.#keyList[index];
	                if (this.#hasDispose) {
	                    this.#dispose?.(v, k, reason);
	                }
	                if (this.#hasDisposeAfter) {
	                    this.#disposed?.push([v, k, reason]);
	                }
	            }
	        }
	        this.#keyMap.clear();
	        this.#valList.fill(undefined);
	        this.#keyList.fill(undefined);
	        if (this.#ttls && this.#starts) {
	            this.#ttls.fill(0);
	            this.#starts.fill(0);
	        }
	        if (this.#sizes) {
	            this.#sizes.fill(0);
	        }
	        this.#head = 0;
	        this.#tail = 0;
	        this.#free.length = 0;
	        this.#calculatedSize = 0;
	        this.#size = 0;
	        if (this.#hasDisposeAfter && this.#disposed) {
	            const dt = this.#disposed;
	            let task;
	            while ((task = dt?.shift())) {
	                this.#disposeAfter?.(...task);
	            }
	        }
	    }
	}
	commonjs$1.LRUCache = LRUCache;
	
	return commonjs$1;
}

var commonjs = {};

var hasRequiredCommonjs$2;

function requireCommonjs$2 () {
	if (hasRequiredCommonjs$2) return commonjs;
	hasRequiredCommonjs$2 = 1;
	(function (exports) {
		var __importDefault = (commonjs && commonjs.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;
		const proc = typeof process === 'object' && process
		    ? process
		    : {
		        stdout: null,
		        stderr: null,
		    };
		const node_events_1 = require$$0$4;
		const node_stream_1 = __importDefault(require$$1$5);
		const node_string_decoder_1 = require$$2$3;
		/**
		 * Return true if the argument is a Minipass stream, Node stream, or something
		 * else that Minipass can interact with.
		 */
		const isStream = (s) => !!s &&
		    typeof s === 'object' &&
		    (s instanceof Minipass ||
		        s instanceof node_stream_1.default ||
		        (0, exports.isReadable)(s) ||
		        (0, exports.isWritable)(s));
		exports.isStream = isStream;
		/**
		 * Return true if the argument is a valid {@link Minipass.Readable}
		 */
		const isReadable = (s) => !!s &&
		    typeof s === 'object' &&
		    s instanceof node_events_1.EventEmitter &&
		    typeof s.pipe === 'function' &&
		    // node core Writable streams have a pipe() method, but it throws
		    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
		exports.isReadable = isReadable;
		/**
		 * Return true if the argument is a valid {@link Minipass.Writable}
		 */
		const isWritable = (s) => !!s &&
		    typeof s === 'object' &&
		    s instanceof node_events_1.EventEmitter &&
		    typeof s.write === 'function' &&
		    typeof s.end === 'function';
		exports.isWritable = isWritable;
		const EOF = Symbol('EOF');
		const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
		const EMITTED_END = Symbol('emittedEnd');
		const EMITTING_END = Symbol('emittingEnd');
		const EMITTED_ERROR = Symbol('emittedError');
		const CLOSED = Symbol('closed');
		const READ = Symbol('read');
		const FLUSH = Symbol('flush');
		const FLUSHCHUNK = Symbol('flushChunk');
		const ENCODING = Symbol('encoding');
		const DECODER = Symbol('decoder');
		const FLOWING = Symbol('flowing');
		const PAUSED = Symbol('paused');
		const RESUME = Symbol('resume');
		const BUFFER = Symbol('buffer');
		const PIPES = Symbol('pipes');
		const BUFFERLENGTH = Symbol('bufferLength');
		const BUFFERPUSH = Symbol('bufferPush');
		const BUFFERSHIFT = Symbol('bufferShift');
		const OBJECTMODE = Symbol('objectMode');
		// internal event when stream is destroyed
		const DESTROYED = Symbol('destroyed');
		// internal event when stream has an error
		const ERROR = Symbol('error');
		const EMITDATA = Symbol('emitData');
		const EMITEND = Symbol('emitEnd');
		const EMITEND2 = Symbol('emitEnd2');
		const ASYNC = Symbol('async');
		const ABORT = Symbol('abort');
		const ABORTED = Symbol('aborted');
		const SIGNAL = Symbol('signal');
		const DATALISTENERS = Symbol('dataListeners');
		const DISCARDED = Symbol('discarded');
		const defer = (fn) => Promise.resolve().then(fn);
		const nodefer = (fn) => fn();
		const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
		const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
		    (!!b &&
		        typeof b === 'object' &&
		        b.constructor &&
		        b.constructor.name === 'ArrayBuffer' &&
		        b.byteLength >= 0);
		const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
		/**
		 * Internal class representing a pipe to a destination stream.
		 *
		 * @internal
		 */
		class Pipe {
		    src;
		    dest;
		    opts;
		    ondrain;
		    constructor(src, dest, opts) {
		        this.src = src;
		        this.dest = dest;
		        this.opts = opts;
		        this.ondrain = () => src[RESUME]();
		        this.dest.on('drain', this.ondrain);
		    }
		    unpipe() {
		        this.dest.removeListener('drain', this.ondrain);
		    }
		    // only here for the prototype
		    /* c8 ignore start */
		    proxyErrors(_er) { }
		    /* c8 ignore stop */
		    end() {
		        this.unpipe();
		        if (this.opts.end)
		            this.dest.end();
		    }
		}
		/**
		 * Internal class representing a pipe to a destination stream where
		 * errors are proxied.
		 *
		 * @internal
		 */
		class PipeProxyErrors extends Pipe {
		    unpipe() {
		        this.src.removeListener('error', this.proxyErrors);
		        super.unpipe();
		    }
		    constructor(src, dest, opts) {
		        super(src, dest, opts);
		        this.proxyErrors = er => dest.emit('error', er);
		        src.on('error', this.proxyErrors);
		    }
		}
		const isObjectModeOptions = (o) => !!o.objectMode;
		const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
		/**
		 * Main export, the Minipass class
		 *
		 * `RType` is the type of data emitted, defaults to Buffer
		 *
		 * `WType` is the type of data to be written, if RType is buffer or string,
		 * then any {@link Minipass.ContiguousData} is allowed.
		 *
		 * `Events` is the set of event handler signatures that this object
		 * will emit, see {@link Minipass.Events}
		 */
		class Minipass extends node_events_1.EventEmitter {
		    [FLOWING] = false;
		    [PAUSED] = false;
		    [PIPES] = [];
		    [BUFFER] = [];
		    [OBJECTMODE];
		    [ENCODING];
		    [ASYNC];
		    [DECODER];
		    [EOF] = false;
		    [EMITTED_END] = false;
		    [EMITTING_END] = false;
		    [CLOSED] = false;
		    [EMITTED_ERROR] = null;
		    [BUFFERLENGTH] = 0;
		    [DESTROYED] = false;
		    [SIGNAL];
		    [ABORTED] = false;
		    [DATALISTENERS] = 0;
		    [DISCARDED] = false;
		    /**
		     * true if the stream can be written
		     */
		    writable = true;
		    /**
		     * true if the stream can be read
		     */
		    readable = true;
		    /**
		     * If `RType` is Buffer, then options do not need to be provided.
		     * Otherwise, an options object must be provided to specify either
		     * {@link Minipass.SharedOptions.objectMode} or
		     * {@link Minipass.SharedOptions.encoding}, as appropriate.
		     */
		    constructor(...args) {
		        const options = (args[0] ||
		            {});
		        super();
		        if (options.objectMode && typeof options.encoding === 'string') {
		            throw new TypeError('Encoding and objectMode may not be used together');
		        }
		        if (isObjectModeOptions(options)) {
		            this[OBJECTMODE] = true;
		            this[ENCODING] = null;
		        }
		        else if (isEncodingOptions(options)) {
		            this[ENCODING] = options.encoding;
		            this[OBJECTMODE] = false;
		        }
		        else {
		            this[OBJECTMODE] = false;
		            this[ENCODING] = null;
		        }
		        this[ASYNC] = !!options.async;
		        this[DECODER] = this[ENCODING]
		            ? new node_string_decoder_1.StringDecoder(this[ENCODING])
		            : null;
		        //@ts-ignore - private option for debugging and testing
		        if (options && options.debugExposeBuffer === true) {
		            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
		        }
		        //@ts-ignore - private option for debugging and testing
		        if (options && options.debugExposePipes === true) {
		            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
		        }
		        const { signal } = options;
		        if (signal) {
		            this[SIGNAL] = signal;
		            if (signal.aborted) {
		                this[ABORT]();
		            }
		            else {
		                signal.addEventListener('abort', () => this[ABORT]());
		            }
		        }
		    }
		    /**
		     * The amount of data stored in the buffer waiting to be read.
		     *
		     * For Buffer strings, this will be the total byte length.
		     * For string encoding streams, this will be the string character length,
		     * according to JavaScript's `string.length` logic.
		     * For objectMode streams, this is a count of the items waiting to be
		     * emitted.
		     */
		    get bufferLength() {
		        return this[BUFFERLENGTH];
		    }
		    /**
		     * The `BufferEncoding` currently in use, or `null`
		     */
		    get encoding() {
		        return this[ENCODING];
		    }
		    /**
		     * @deprecated - This is a read only property
		     */
		    set encoding(_enc) {
		        throw new Error('Encoding must be set at instantiation time');
		    }
		    /**
		     * @deprecated - Encoding may only be set at instantiation time
		     */
		    setEncoding(_enc) {
		        throw new Error('Encoding must be set at instantiation time');
		    }
		    /**
		     * True if this is an objectMode stream
		     */
		    get objectMode() {
		        return this[OBJECTMODE];
		    }
		    /**
		     * @deprecated - This is a read-only property
		     */
		    set objectMode(_om) {
		        throw new Error('objectMode must be set at instantiation time');
		    }
		    /**
		     * true if this is an async stream
		     */
		    get ['async']() {
		        return this[ASYNC];
		    }
		    /**
		     * Set to true to make this stream async.
		     *
		     * Once set, it cannot be unset, as this would potentially cause incorrect
		     * behavior.  Ie, a sync stream can be made async, but an async stream
		     * cannot be safely made sync.
		     */
		    set ['async'](a) {
		        this[ASYNC] = this[ASYNC] || !!a;
		    }
		    // drop everything and get out of the flow completely
		    [ABORT]() {
		        this[ABORTED] = true;
		        this.emit('abort', this[SIGNAL]?.reason);
		        this.destroy(this[SIGNAL]?.reason);
		    }
		    /**
		     * True if the stream has been aborted.
		     */
		    get aborted() {
		        return this[ABORTED];
		    }
		    /**
		     * No-op setter. Stream aborted status is set via the AbortSignal provided
		     * in the constructor options.
		     */
		    set aborted(_) { }
		    write(chunk, encoding, cb) {
		        if (this[ABORTED])
		            return false;
		        if (this[EOF])
		            throw new Error('write after end');
		        if (this[DESTROYED]) {
		            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
		            return true;
		        }
		        if (typeof encoding === 'function') {
		            cb = encoding;
		            encoding = 'utf8';
		        }
		        if (!encoding)
		            encoding = 'utf8';
		        const fn = this[ASYNC] ? defer : nodefer;
		        // convert array buffers and typed array views into buffers
		        // at some point in the future, we may want to do the opposite!
		        // leave strings and buffers as-is
		        // anything is only allowed if in object mode, so throw
		        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
		            if (isArrayBufferView(chunk)) {
		                //@ts-ignore - sinful unsafe type changing
		                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
		            }
		            else if (isArrayBufferLike(chunk)) {
		                //@ts-ignore - sinful unsafe type changing
		                chunk = Buffer.from(chunk);
		            }
		            else if (typeof chunk !== 'string') {
		                throw new Error('Non-contiguous data written to non-objectMode stream');
		            }
		        }
		        // handle object mode up front, since it's simpler
		        // this yields better performance, fewer checks later.
		        if (this[OBJECTMODE]) {
		            // maybe impossible?
		            /* c8 ignore start */
		            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
		                this[FLUSH](true);
		            /* c8 ignore stop */
		            if (this[FLOWING])
		                this.emit('data', chunk);
		            else
		                this[BUFFERPUSH](chunk);
		            if (this[BUFFERLENGTH] !== 0)
		                this.emit('readable');
		            if (cb)
		                fn(cb);
		            return this[FLOWING];
		        }
		        // at this point the chunk is a buffer or string
		        // don't buffer it up or send it to the decoder
		        if (!chunk.length) {
		            if (this[BUFFERLENGTH] !== 0)
		                this.emit('readable');
		            if (cb)
		                fn(cb);
		            return this[FLOWING];
		        }
		        // fast-path writing strings of same encoding to a stream with
		        // an empty buffer, skipping the buffer/decoder dance
		        if (typeof chunk === 'string' &&
		            // unless it is a string already ready for us to use
		            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
		            //@ts-ignore - sinful unsafe type change
		            chunk = Buffer.from(chunk, encoding);
		        }
		        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
		            //@ts-ignore - sinful unsafe type change
		            chunk = this[DECODER].write(chunk);
		        }
		        // Note: flushing CAN potentially switch us into not-flowing mode
		        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
		            this[FLUSH](true);
		        if (this[FLOWING])
		            this.emit('data', chunk);
		        else
		            this[BUFFERPUSH](chunk);
		        if (this[BUFFERLENGTH] !== 0)
		            this.emit('readable');
		        if (cb)
		            fn(cb);
		        return this[FLOWING];
		    }
		    /**
		     * Low-level explicit read method.
		     *
		     * In objectMode, the argument is ignored, and one item is returned if
		     * available.
		     *
		     * `n` is the number of bytes (or in the case of encoding streams,
		     * characters) to consume. If `n` is not provided, then the entire buffer
		     * is returned, or `null` is returned if no data is available.
		     *
		     * If `n` is greater that the amount of data in the internal buffer,
		     * then `null` is returned.
		     */
		    read(n) {
		        if (this[DESTROYED])
		            return null;
		        this[DISCARDED] = false;
		        if (this[BUFFERLENGTH] === 0 ||
		            n === 0 ||
		            (n && n > this[BUFFERLENGTH])) {
		            this[MAYBE_EMIT_END]();
		            return null;
		        }
		        if (this[OBJECTMODE])
		            n = null;
		        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
		            // not object mode, so if we have an encoding, then RType is string
		            // otherwise, must be Buffer
		            this[BUFFER] = [
		                (this[ENCODING]
		                    ? this[BUFFER].join('')
		                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
		            ];
		        }
		        const ret = this[READ](n || null, this[BUFFER][0]);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [READ](n, chunk) {
		        if (this[OBJECTMODE])
		            this[BUFFERSHIFT]();
		        else {
		            const c = chunk;
		            if (n === c.length || n === null)
		                this[BUFFERSHIFT]();
		            else if (typeof c === 'string') {
		                this[BUFFER][0] = c.slice(n);
		                chunk = c.slice(0, n);
		                this[BUFFERLENGTH] -= n;
		            }
		            else {
		                this[BUFFER][0] = c.subarray(n);
		                chunk = c.subarray(0, n);
		                this[BUFFERLENGTH] -= n;
		            }
		        }
		        this.emit('data', chunk);
		        if (!this[BUFFER].length && !this[EOF])
		            this.emit('drain');
		        return chunk;
		    }
		    end(chunk, encoding, cb) {
		        if (typeof chunk === 'function') {
		            cb = chunk;
		            chunk = undefined;
		        }
		        if (typeof encoding === 'function') {
		            cb = encoding;
		            encoding = 'utf8';
		        }
		        if (chunk !== undefined)
		            this.write(chunk, encoding);
		        if (cb)
		            this.once('end', cb);
		        this[EOF] = true;
		        this.writable = false;
		        // if we haven't written anything, then go ahead and emit,
		        // even if we're not reading.
		        // we'll re-emit if a new 'end' listener is added anyway.
		        // This makes MP more suitable to write-only use cases.
		        if (this[FLOWING] || !this[PAUSED])
		            this[MAYBE_EMIT_END]();
		        return this;
		    }
		    // don't let the internal resume be overwritten
		    [RESUME]() {
		        if (this[DESTROYED])
		            return;
		        if (!this[DATALISTENERS] && !this[PIPES].length) {
		            this[DISCARDED] = true;
		        }
		        this[PAUSED] = false;
		        this[FLOWING] = true;
		        this.emit('resume');
		        if (this[BUFFER].length)
		            this[FLUSH]();
		        else if (this[EOF])
		            this[MAYBE_EMIT_END]();
		        else
		            this.emit('drain');
		    }
		    /**
		     * Resume the stream if it is currently in a paused state
		     *
		     * If called when there are no pipe destinations or `data` event listeners,
		     * this will place the stream in a "discarded" state, where all data will
		     * be thrown away. The discarded state is removed if a pipe destination or
		     * data handler is added, if pause() is called, or if any synchronous or
		     * asynchronous iteration is started.
		     */
		    resume() {
		        return this[RESUME]();
		    }
		    /**
		     * Pause the stream
		     */
		    pause() {
		        this[FLOWING] = false;
		        this[PAUSED] = true;
		        this[DISCARDED] = false;
		    }
		    /**
		     * true if the stream has been forcibly destroyed
		     */
		    get destroyed() {
		        return this[DESTROYED];
		    }
		    /**
		     * true if the stream is currently in a flowing state, meaning that
		     * any writes will be immediately emitted.
		     */
		    get flowing() {
		        return this[FLOWING];
		    }
		    /**
		     * true if the stream is currently in a paused state
		     */
		    get paused() {
		        return this[PAUSED];
		    }
		    [BUFFERPUSH](chunk) {
		        if (this[OBJECTMODE])
		            this[BUFFERLENGTH] += 1;
		        else
		            this[BUFFERLENGTH] += chunk.length;
		        this[BUFFER].push(chunk);
		    }
		    [BUFFERSHIFT]() {
		        if (this[OBJECTMODE])
		            this[BUFFERLENGTH] -= 1;
		        else
		            this[BUFFERLENGTH] -= this[BUFFER][0].length;
		        return this[BUFFER].shift();
		    }
		    [FLUSH](noDrain = false) {
		        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
		            this[BUFFER].length);
		        if (!noDrain && !this[BUFFER].length && !this[EOF])
		            this.emit('drain');
		    }
		    [FLUSHCHUNK](chunk) {
		        this.emit('data', chunk);
		        return this[FLOWING];
		    }
		    /**
		     * Pipe all data emitted by this stream into the destination provided.
		     *
		     * Triggers the flow of data.
		     */
		    pipe(dest, opts) {
		        if (this[DESTROYED])
		            return dest;
		        this[DISCARDED] = false;
		        const ended = this[EMITTED_END];
		        opts = opts || {};
		        if (dest === proc.stdout || dest === proc.stderr)
		            opts.end = false;
		        else
		            opts.end = opts.end !== false;
		        opts.proxyErrors = !!opts.proxyErrors;
		        // piping an ended stream ends immediately
		        if (ended) {
		            if (opts.end)
		                dest.end();
		        }
		        else {
		            // "as" here just ignores the WType, which pipes don't care about,
		            // since they're only consuming from us, and writing to the dest
		            this[PIPES].push(!opts.proxyErrors
		                ? new Pipe(this, dest, opts)
		                : new PipeProxyErrors(this, dest, opts));
		            if (this[ASYNC])
		                defer(() => this[RESUME]());
		            else
		                this[RESUME]();
		        }
		        return dest;
		    }
		    /**
		     * Fully unhook a piped destination stream.
		     *
		     * If the destination stream was the only consumer of this stream (ie,
		     * there are no other piped destinations or `'data'` event listeners)
		     * then the flow of data will stop until there is another consumer or
		     * {@link Minipass#resume} is explicitly called.
		     */
		    unpipe(dest) {
		        const p = this[PIPES].find(p => p.dest === dest);
		        if (p) {
		            if (this[PIPES].length === 1) {
		                if (this[FLOWING] && this[DATALISTENERS] === 0) {
		                    this[FLOWING] = false;
		                }
		                this[PIPES] = [];
		            }
		            else
		                this[PIPES].splice(this[PIPES].indexOf(p), 1);
		            p.unpipe();
		        }
		    }
		    /**
		     * Alias for {@link Minipass#on}
		     */
		    addListener(ev, handler) {
		        return this.on(ev, handler);
		    }
		    /**
		     * Mostly identical to `EventEmitter.on`, with the following
		     * behavior differences to prevent data loss and unnecessary hangs:
		     *
		     * - Adding a 'data' event handler will trigger the flow of data
		     *
		     * - Adding a 'readable' event handler when there is data waiting to be read
		     *   will cause 'readable' to be emitted immediately.
		     *
		     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
		     *   already passed will cause the event to be emitted immediately and all
		     *   handlers removed.
		     *
		     * - Adding an 'error' event handler after an error has been emitted will
		     *   cause the event to be re-emitted immediately with the error previously
		     *   raised.
		     */
		    on(ev, handler) {
		        const ret = super.on(ev, handler);
		        if (ev === 'data') {
		            this[DISCARDED] = false;
		            this[DATALISTENERS]++;
		            if (!this[PIPES].length && !this[FLOWING]) {
		                this[RESUME]();
		            }
		        }
		        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
		            super.emit('readable');
		        }
		        else if (isEndish(ev) && this[EMITTED_END]) {
		            super.emit(ev);
		            this.removeAllListeners(ev);
		        }
		        else if (ev === 'error' && this[EMITTED_ERROR]) {
		            const h = handler;
		            if (this[ASYNC])
		                defer(() => h.call(this, this[EMITTED_ERROR]));
		            else
		                h.call(this, this[EMITTED_ERROR]);
		        }
		        return ret;
		    }
		    /**
		     * Alias for {@link Minipass#off}
		     */
		    removeListener(ev, handler) {
		        return this.off(ev, handler);
		    }
		    /**
		     * Mostly identical to `EventEmitter.off`
		     *
		     * If a 'data' event handler is removed, and it was the last consumer
		     * (ie, there are no pipe destinations or other 'data' event listeners),
		     * then the flow of data will stop until there is another consumer or
		     * {@link Minipass#resume} is explicitly called.
		     */
		    off(ev, handler) {
		        const ret = super.off(ev, handler);
		        // if we previously had listeners, and now we don't, and we don't
		        // have any pipes, then stop the flow, unless it's been explicitly
		        // put in a discarded flowing state via stream.resume().
		        if (ev === 'data') {
		            this[DATALISTENERS] = this.listeners('data').length;
		            if (this[DATALISTENERS] === 0 &&
		                !this[DISCARDED] &&
		                !this[PIPES].length) {
		                this[FLOWING] = false;
		            }
		        }
		        return ret;
		    }
		    /**
		     * Mostly identical to `EventEmitter.removeAllListeners`
		     *
		     * If all 'data' event handlers are removed, and they were the last consumer
		     * (ie, there are no pipe destinations), then the flow of data will stop
		     * until there is another consumer or {@link Minipass#resume} is explicitly
		     * called.
		     */
		    removeAllListeners(ev) {
		        const ret = super.removeAllListeners(ev);
		        if (ev === 'data' || ev === undefined) {
		            this[DATALISTENERS] = 0;
		            if (!this[DISCARDED] && !this[PIPES].length) {
		                this[FLOWING] = false;
		            }
		        }
		        return ret;
		    }
		    /**
		     * true if the 'end' event has been emitted
		     */
		    get emittedEnd() {
		        return this[EMITTED_END];
		    }
		    [MAYBE_EMIT_END]() {
		        if (!this[EMITTING_END] &&
		            !this[EMITTED_END] &&
		            !this[DESTROYED] &&
		            this[BUFFER].length === 0 &&
		            this[EOF]) {
		            this[EMITTING_END] = true;
		            this.emit('end');
		            this.emit('prefinish');
		            this.emit('finish');
		            if (this[CLOSED])
		                this.emit('close');
		            this[EMITTING_END] = false;
		        }
		    }
		    /**
		     * Mostly identical to `EventEmitter.emit`, with the following
		     * behavior differences to prevent data loss and unnecessary hangs:
		     *
		     * If the stream has been destroyed, and the event is something other
		     * than 'close' or 'error', then `false` is returned and no handlers
		     * are called.
		     *
		     * If the event is 'end', and has already been emitted, then the event
		     * is ignored. If the stream is in a paused or non-flowing state, then
		     * the event will be deferred until data flow resumes. If the stream is
		     * async, then handlers will be called on the next tick rather than
		     * immediately.
		     *
		     * If the event is 'close', and 'end' has not yet been emitted, then
		     * the event will be deferred until after 'end' is emitted.
		     *
		     * If the event is 'error', and an AbortSignal was provided for the stream,
		     * and there are no listeners, then the event is ignored, matching the
		     * behavior of node core streams in the presense of an AbortSignal.
		     *
		     * If the event is 'finish' or 'prefinish', then all listeners will be
		     * removed after emitting the event, to prevent double-firing.
		     */
		    emit(ev, ...args) {
		        const data = args[0];
		        // error and close are only events allowed after calling destroy()
		        if (ev !== 'error' &&
		            ev !== 'close' &&
		            ev !== DESTROYED &&
		            this[DESTROYED]) {
		            return false;
		        }
		        else if (ev === 'data') {
		            return !this[OBJECTMODE] && !data
		                ? false
		                : this[ASYNC]
		                    ? (defer(() => this[EMITDATA](data)), true)
		                    : this[EMITDATA](data);
		        }
		        else if (ev === 'end') {
		            return this[EMITEND]();
		        }
		        else if (ev === 'close') {
		            this[CLOSED] = true;
		            // don't emit close before 'end' and 'finish'
		            if (!this[EMITTED_END] && !this[DESTROYED])
		                return false;
		            const ret = super.emit('close');
		            this.removeAllListeners('close');
		            return ret;
		        }
		        else if (ev === 'error') {
		            this[EMITTED_ERROR] = data;
		            super.emit(ERROR, data);
		            const ret = !this[SIGNAL] || this.listeners('error').length
		                ? super.emit('error', data)
		                : false;
		            this[MAYBE_EMIT_END]();
		            return ret;
		        }
		        else if (ev === 'resume') {
		            const ret = super.emit('resume');
		            this[MAYBE_EMIT_END]();
		            return ret;
		        }
		        else if (ev === 'finish' || ev === 'prefinish') {
		            const ret = super.emit(ev);
		            this.removeAllListeners(ev);
		            return ret;
		        }
		        // Some other unknown event
		        const ret = super.emit(ev, ...args);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [EMITDATA](data) {
		        for (const p of this[PIPES]) {
		            if (p.dest.write(data) === false)
		                this.pause();
		        }
		        const ret = this[DISCARDED] ? false : super.emit('data', data);
		        this[MAYBE_EMIT_END]();
		        return ret;
		    }
		    [EMITEND]() {
		        if (this[EMITTED_END])
		            return false;
		        this[EMITTED_END] = true;
		        this.readable = false;
		        return this[ASYNC]
		            ? (defer(() => this[EMITEND2]()), true)
		            : this[EMITEND2]();
		    }
		    [EMITEND2]() {
		        if (this[DECODER]) {
		            const data = this[DECODER].end();
		            if (data) {
		                for (const p of this[PIPES]) {
		                    p.dest.write(data);
		                }
		                if (!this[DISCARDED])
		                    super.emit('data', data);
		            }
		        }
		        for (const p of this[PIPES]) {
		            p.end();
		        }
		        const ret = super.emit('end');
		        this.removeAllListeners('end');
		        return ret;
		    }
		    /**
		     * Return a Promise that resolves to an array of all emitted data once
		     * the stream ends.
		     */
		    async collect() {
		        const buf = Object.assign([], {
		            dataLength: 0,
		        });
		        if (!this[OBJECTMODE])
		            buf.dataLength = 0;
		        // set the promise first, in case an error is raised
		        // by triggering the flow here.
		        const p = this.promise();
		        this.on('data', c => {
		            buf.push(c);
		            if (!this[OBJECTMODE])
		                buf.dataLength += c.length;
		        });
		        await p;
		        return buf;
		    }
		    /**
		     * Return a Promise that resolves to the concatenation of all emitted data
		     * once the stream ends.
		     *
		     * Not allowed on objectMode streams.
		     */
		    async concat() {
		        if (this[OBJECTMODE]) {
		            throw new Error('cannot concat in objectMode');
		        }
		        const buf = await this.collect();
		        return (this[ENCODING]
		            ? buf.join('')
		            : Buffer.concat(buf, buf.dataLength));
		    }
		    /**
		     * Return a void Promise that resolves once the stream ends.
		     */
		    async promise() {
		        return new Promise((resolve, reject) => {
		            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
		            this.on('error', er => reject(er));
		            this.on('end', () => resolve());
		        });
		    }
		    /**
		     * Asynchronous `for await of` iteration.
		     *
		     * This will continue emitting all chunks until the stream terminates.
		     */
		    [Symbol.asyncIterator]() {
		        // set this up front, in case the consumer doesn't call next()
		        // right away.
		        this[DISCARDED] = false;
		        let stopped = false;
		        const stop = async () => {
		            this.pause();
		            stopped = true;
		            return { value: undefined, done: true };
		        };
		        const next = () => {
		            if (stopped)
		                return stop();
		            const res = this.read();
		            if (res !== null)
		                return Promise.resolve({ done: false, value: res });
		            if (this[EOF])
		                return stop();
		            let resolve;
		            let reject;
		            const onerr = (er) => {
		                this.off('data', ondata);
		                this.off('end', onend);
		                this.off(DESTROYED, ondestroy);
		                stop();
		                reject(er);
		            };
		            const ondata = (value) => {
		                this.off('error', onerr);
		                this.off('end', onend);
		                this.off(DESTROYED, ondestroy);
		                this.pause();
		                resolve({ value, done: !!this[EOF] });
		            };
		            const onend = () => {
		                this.off('error', onerr);
		                this.off('data', ondata);
		                this.off(DESTROYED, ondestroy);
		                stop();
		                resolve({ done: true, value: undefined });
		            };
		            const ondestroy = () => onerr(new Error('stream destroyed'));
		            return new Promise((res, rej) => {
		                reject = rej;
		                resolve = res;
		                this.once(DESTROYED, ondestroy);
		                this.once('error', onerr);
		                this.once('end', onend);
		                this.once('data', ondata);
		            });
		        };
		        return {
		            next,
		            throw: stop,
		            return: stop,
		            [Symbol.asyncIterator]() {
		                return this;
		            },
		        };
		    }
		    /**
		     * Synchronous `for of` iteration.
		     *
		     * The iteration will terminate when the internal buffer runs out, even
		     * if the stream has not yet terminated.
		     */
		    [Symbol.iterator]() {
		        // set this up front, in case the consumer doesn't call next()
		        // right away.
		        this[DISCARDED] = false;
		        let stopped = false;
		        const stop = () => {
		            this.pause();
		            this.off(ERROR, stop);
		            this.off(DESTROYED, stop);
		            this.off('end', stop);
		            stopped = true;
		            return { done: true, value: undefined };
		        };
		        const next = () => {
		            if (stopped)
		                return stop();
		            const value = this.read();
		            return value === null ? stop() : { done: false, value };
		        };
		        this.once('end', stop);
		        this.once(ERROR, stop);
		        this.once(DESTROYED, stop);
		        return {
		            next,
		            throw: stop,
		            return: stop,
		            [Symbol.iterator]() {
		                return this;
		            },
		        };
		    }
		    /**
		     * Destroy a stream, preventing it from being used for any further purpose.
		     *
		     * If the stream has a `close()` method, then it will be called on
		     * destruction.
		     *
		     * After destruction, any attempt to write data, read data, or emit most
		     * events will be ignored.
		     *
		     * If an error argument is provided, then it will be emitted in an
		     * 'error' event.
		     */
		    destroy(er) {
		        if (this[DESTROYED]) {
		            if (er)
		                this.emit('error', er);
		            else
		                this.emit(DESTROYED);
		            return this;
		        }
		        this[DESTROYED] = true;
		        this[DISCARDED] = true;
		        // throw away all buffered data, it's never coming out
		        this[BUFFER].length = 0;
		        this[BUFFERLENGTH] = 0;
		        const wc = this;
		        if (typeof wc.close === 'function' && !this[CLOSED])
		            wc.close();
		        if (er)
		            this.emit('error', er);
		        // if no error to emit, still reject pending promises
		        else
		            this.emit(DESTROYED);
		        return this;
		    }
		    /**
		     * Alias for {@link isStream}
		     *
		     * Former export location, maintained for backwards compatibility.
		     *
		     * @deprecated
		     */
		    static get isStream() {
		        return exports.isStream;
		    }
		}
		exports.Minipass = Minipass;
		
	} (commonjs));
	return commonjs;
}

var hasRequiredCommonjs$1;

function requireCommonjs$1 () {
	if (hasRequiredCommonjs$1) return commonjs$2;
	hasRequiredCommonjs$1 = 1;
	var __createBinding = (commonjs$2 && commonjs$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjs$2 && commonjs$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjs$2 && commonjs$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(commonjs$2, "__esModule", { value: true });
	commonjs$2.PathScurry = commonjs$2.Path = commonjs$2.PathScurryDarwin = commonjs$2.PathScurryPosix = commonjs$2.PathScurryWin32 = commonjs$2.PathScurryBase = commonjs$2.PathPosix = commonjs$2.PathWin32 = commonjs$2.PathBase = commonjs$2.ChildrenCache = commonjs$2.ResolveCache = void 0;
	const lru_cache_1 = /*@__PURE__*/ requireCommonjs$3();
	const node_path_1 = require$$1$4;
	const node_url_1 = require$$1$6;
	const fs_1 = require$$0$2;
	const actualFS = __importStar(require$$0$f);
	const realpathSync = fs_1.realpathSync.native;
	// TODO: test perf of fs/promises realpath vs realpathCB,
	// since the promises one uses realpath.native
	const promises_1 = require$$5$1;
	const minipass_1 = requireCommonjs$2();
	const defaultFS = {
	    lstatSync: fs_1.lstatSync,
	    readdir: fs_1.readdir,
	    readdirSync: fs_1.readdirSync,
	    readlinkSync: fs_1.readlinkSync,
	    realpathSync,
	    promises: {
	        lstat: promises_1.lstat,
	        readdir: promises_1.readdir,
	        readlink: promises_1.readlink,
	        realpath: promises_1.realpath,
	    },
	};
	// if they just gave us require('fs') then use our default
	const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ?
	    defaultFS
	    : {
	        ...defaultFS,
	        ...fsOption,
	        promises: {
	            ...defaultFS.promises,
	            ...(fsOption.promises || {}),
	        },
	    };
	// turn something like //?/c:/ into c:\
	const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
	const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
	// windows paths are separated by either / or \
	const eitherSep = /[\\\/]/;
	const UNKNOWN = 0; // may not even exist, for all we know
	const IFIFO = 0b0001;
	const IFCHR = 0b0010;
	const IFDIR = 0b0100;
	const IFBLK = 0b0110;
	const IFREG = 0b1000;
	const IFLNK = 0b1010;
	const IFSOCK = 0b1100;
	const IFMT = 0b1111;
	// mask to unset low 4 bits
	const IFMT_UNKNOWN = ~IFMT;
	// set after successfully calling readdir() and getting entries.
	const READDIR_CALLED = 0b0000_0001_0000;
	// set after a successful lstat()
	const LSTAT_CALLED = 0b0000_0010_0000;
	// set if an entry (or one of its parents) is definitely not a dir
	const ENOTDIR = 0b0000_0100_0000;
	// set if an entry (or one of its parents) does not exist
	// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
	const ENOENT = 0b0000_1000_0000;
	// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
	// set if we fail to readlink
	const ENOREADLINK = 0b0001_0000_0000;
	// set if we know realpath() will fail
	const ENOREALPATH = 0b0010_0000_0000;
	const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
	const TYPEMASK = 0b0011_1111_1111;
	const entToType = (s) => s.isFile() ? IFREG
	    : s.isDirectory() ? IFDIR
	        : s.isSymbolicLink() ? IFLNK
	            : s.isCharacterDevice() ? IFCHR
	                : s.isBlockDevice() ? IFBLK
	                    : s.isSocket() ? IFSOCK
	                        : s.isFIFO() ? IFIFO
	                            : UNKNOWN;
	// normalize unicode path names
	const normalizeCache = new Map();
	const normalize = (s) => {
	    const c = normalizeCache.get(s);
	    if (c)
	        return c;
	    const n = s.normalize('NFKD');
	    normalizeCache.set(s, n);
	    return n;
	};
	const normalizeNocaseCache = new Map();
	const normalizeNocase = (s) => {
	    const c = normalizeNocaseCache.get(s);
	    if (c)
	        return c;
	    const n = normalize(s.toLowerCase());
	    normalizeNocaseCache.set(s, n);
	    return n;
	};
	/**
	 * An LRUCache for storing resolved path strings or Path objects.
	 * @internal
	 */
	class ResolveCache extends lru_cache_1.LRUCache {
	    constructor() {
	        super({ max: 256 });
	    }
	}
	commonjs$2.ResolveCache = ResolveCache;
	// In order to prevent blowing out the js heap by allocating hundreds of
	// thousands of Path entries when walking extremely large trees, the "children"
	// in this tree are represented by storing an array of Path entries in an
	// LRUCache, indexed by the parent.  At any time, Path.children() may return an
	// empty array, indicating that it doesn't know about any of its children, and
	// thus has to rebuild that cache.  This is fine, it just means that we don't
	// benefit as much from having the cached entries, but huge directory walks
	// don't blow out the stack, and smaller ones are still as fast as possible.
	//
	//It does impose some complexity when building up the readdir data, because we
	//need to pass a reference to the children array that we started with.
	/**
	 * an LRUCache for storing child entries.
	 * @internal
	 */
	class ChildrenCache extends lru_cache_1.LRUCache {
	    constructor(maxSize = 16 * 1024) {
	        super({
	            maxSize,
	            // parent + children
	            sizeCalculation: a => a.length + 1,
	        });
	    }
	}
	commonjs$2.ChildrenCache = ChildrenCache;
	const setAsCwd = Symbol('PathScurry setAsCwd');
	/**
	 * Path objects are sort of like a super-powered
	 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
	 *
	 * Each one represents a single filesystem entry on disk, which may or may not
	 * exist. It includes methods for reading various types of information via
	 * lstat, readlink, and readdir, and caches all information to the greatest
	 * degree possible.
	 *
	 * Note that fs operations that would normally throw will instead return an
	 * "empty" value. This is in order to prevent excessive overhead from error
	 * stack traces.
	 */
	class PathBase {
	    /**
	     * the basename of this path
	     *
	     * **Important**: *always* test the path name against any test string
	     * usingthe {@link isNamed} method, and not by directly comparing this
	     * string. Otherwise, unicode path strings that the system sees as identical
	     * will not be properly treated as the same path, leading to incorrect
	     * behavior and possible security issues.
	     */
	    name;
	    /**
	     * the Path entry corresponding to the path root.
	     *
	     * @internal
	     */
	    root;
	    /**
	     * All roots found within the current PathScurry family
	     *
	     * @internal
	     */
	    roots;
	    /**
	     * a reference to the parent path, or undefined in the case of root entries
	     *
	     * @internal
	     */
	    parent;
	    /**
	     * boolean indicating whether paths are compared case-insensitively
	     * @internal
	     */
	    nocase;
	    /**
	     * boolean indicating that this path is the current working directory
	     * of the PathScurry collection that contains it.
	     */
	    isCWD = false;
	    // potential default fs override
	    #fs;
	    // Stats fields
	    #dev;
	    get dev() {
	        return this.#dev;
	    }
	    #mode;
	    get mode() {
	        return this.#mode;
	    }
	    #nlink;
	    get nlink() {
	        return this.#nlink;
	    }
	    #uid;
	    get uid() {
	        return this.#uid;
	    }
	    #gid;
	    get gid() {
	        return this.#gid;
	    }
	    #rdev;
	    get rdev() {
	        return this.#rdev;
	    }
	    #blksize;
	    get blksize() {
	        return this.#blksize;
	    }
	    #ino;
	    get ino() {
	        return this.#ino;
	    }
	    #size;
	    get size() {
	        return this.#size;
	    }
	    #blocks;
	    get blocks() {
	        return this.#blocks;
	    }
	    #atimeMs;
	    get atimeMs() {
	        return this.#atimeMs;
	    }
	    #mtimeMs;
	    get mtimeMs() {
	        return this.#mtimeMs;
	    }
	    #ctimeMs;
	    get ctimeMs() {
	        return this.#ctimeMs;
	    }
	    #birthtimeMs;
	    get birthtimeMs() {
	        return this.#birthtimeMs;
	    }
	    #atime;
	    get atime() {
	        return this.#atime;
	    }
	    #mtime;
	    get mtime() {
	        return this.#mtime;
	    }
	    #ctime;
	    get ctime() {
	        return this.#ctime;
	    }
	    #birthtime;
	    get birthtime() {
	        return this.#birthtime;
	    }
	    #matchName;
	    #depth;
	    #fullpath;
	    #fullpathPosix;
	    #relative;
	    #relativePosix;
	    #type;
	    #children;
	    #linkTarget;
	    #realpath;
	    /**
	     * This property is for compatibility with the Dirent class as of
	     * Node v20, where Dirent['parentPath'] refers to the path of the
	     * directory that was passed to readdir. For root entries, it's the path
	     * to the entry itself.
	     */
	    get parentPath() {
	        return (this.parent || this).fullpath();
	    }
	    /**
	     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
	     * this property refers to the *parent* path, not the path object itself.
	     *
	     * @deprecated
	     */
	    get path() {
	        return this.parentPath;
	    }
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        this.name = name;
	        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
	        this.#type = type & TYPEMASK;
	        this.nocase = nocase;
	        this.roots = roots;
	        this.root = root || this;
	        this.#children = children;
	        this.#fullpath = opts.fullpath;
	        this.#relative = opts.relative;
	        this.#relativePosix = opts.relativePosix;
	        this.parent = opts.parent;
	        if (this.parent) {
	            this.#fs = this.parent.#fs;
	        }
	        else {
	            this.#fs = fsFromOption(opts.fs);
	        }
	    }
	    /**
	     * Returns the depth of the Path object from its root.
	     *
	     * For example, a path at `/foo/bar` would have a depth of 2.
	     */
	    depth() {
	        if (this.#depth !== undefined)
	            return this.#depth;
	        if (!this.parent)
	            return (this.#depth = 0);
	        return (this.#depth = this.parent.depth() + 1);
	    }
	    /**
	     * @internal
	     */
	    childrenCache() {
	        return this.#children;
	    }
	    /**
	     * Get the Path object referenced by the string path, resolved from this Path
	     */
	    resolve(path) {
	        if (!path) {
	            return this;
	        }
	        const rootPath = this.getRootString(path);
	        const dir = path.substring(rootPath.length);
	        const dirParts = dir.split(this.splitSep);
	        const result = rootPath ?
	            this.getRoot(rootPath).#resolveParts(dirParts)
	            : this.#resolveParts(dirParts);
	        return result;
	    }
	    #resolveParts(dirParts) {
	        let p = this;
	        for (const part of dirParts) {
	            p = p.child(part);
	        }
	        return p;
	    }
	    /**
	     * Returns the cached children Path objects, if still available.  If they
	     * have fallen out of the cache, then returns an empty array, and resets the
	     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
	     * lookup.
	     *
	     * @internal
	     */
	    children() {
	        const cached = this.#children.get(this);
	        if (cached) {
	            return cached;
	        }
	        const children = Object.assign([], { provisional: 0 });
	        this.#children.set(this, children);
	        this.#type &= ~READDIR_CALLED;
	        return children;
	    }
	    /**
	     * Resolves a path portion and returns or creates the child Path.
	     *
	     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
	     * `'..'`.
	     *
	     * This should not be called directly.  If `pathPart` contains any path
	     * separators, it will lead to unsafe undefined behavior.
	     *
	     * Use `Path.resolve()` instead.
	     *
	     * @internal
	     */
	    child(pathPart, opts) {
	        if (pathPart === '' || pathPart === '.') {
	            return this;
	        }
	        if (pathPart === '..') {
	            return this.parent || this;
	        }
	        // find the child
	        const children = this.children();
	        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
	        for (const p of children) {
	            if (p.#matchName === name) {
	                return p;
	            }
	        }
	        // didn't find it, create provisional child, since it might not
	        // actually exist.  If we know the parent isn't a dir, then
	        // in fact it CAN'T exist.
	        const s = this.parent ? this.sep : '';
	        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
	        const pchild = this.newChild(pathPart, UNKNOWN, {
	            ...opts,
	            parent: this,
	            fullpath,
	        });
	        if (!this.canReaddir()) {
	            pchild.#type |= ENOENT;
	        }
	        // don't have to update provisional, because if we have real children,
	        // then provisional is set to children.length, otherwise a lower number
	        children.push(pchild);
	        return pchild;
	    }
	    /**
	     * The relative path from the cwd. If it does not share an ancestor with
	     * the cwd, then this ends up being equivalent to the fullpath()
	     */
	    relative() {
	        if (this.isCWD)
	            return '';
	        if (this.#relative !== undefined) {
	            return this.#relative;
	        }
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#relative = this.name);
	        }
	        const pv = p.relative();
	        return pv + (!pv || !p.parent ? '' : this.sep) + name;
	    }
	    /**
	     * The relative path from the cwd, using / as the path separator.
	     * If it does not share an ancestor with
	     * the cwd, then this ends up being equivalent to the fullpathPosix()
	     * On posix systems, this is identical to relative().
	     */
	    relativePosix() {
	        if (this.sep === '/')
	            return this.relative();
	        if (this.isCWD)
	            return '';
	        if (this.#relativePosix !== undefined)
	            return this.#relativePosix;
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#relativePosix = this.fullpathPosix());
	        }
	        const pv = p.relativePosix();
	        return pv + (!pv || !p.parent ? '' : '/') + name;
	    }
	    /**
	     * The fully resolved path string for this Path entry
	     */
	    fullpath() {
	        if (this.#fullpath !== undefined) {
	            return this.#fullpath;
	        }
	        const name = this.name;
	        const p = this.parent;
	        if (!p) {
	            return (this.#fullpath = this.name);
	        }
	        const pv = p.fullpath();
	        const fp = pv + (!p.parent ? '' : this.sep) + name;
	        return (this.#fullpath = fp);
	    }
	    /**
	     * On platforms other than windows, this is identical to fullpath.
	     *
	     * On windows, this is overridden to return the forward-slash form of the
	     * full UNC path.
	     */
	    fullpathPosix() {
	        if (this.#fullpathPosix !== undefined)
	            return this.#fullpathPosix;
	        if (this.sep === '/')
	            return (this.#fullpathPosix = this.fullpath());
	        if (!this.parent) {
	            const p = this.fullpath().replace(/\\/g, '/');
	            if (/^[a-z]:\//i.test(p)) {
	                return (this.#fullpathPosix = `//?/${p}`);
	            }
	            else {
	                return (this.#fullpathPosix = p);
	            }
	        }
	        const p = this.parent;
	        const pfpp = p.fullpathPosix();
	        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
	        return (this.#fullpathPosix = fpp);
	    }
	    /**
	     * Is the Path of an unknown type?
	     *
	     * Note that we might know *something* about it if there has been a previous
	     * filesystem operation, for example that it does not exist, or is not a
	     * link, or whether it has child entries.
	     */
	    isUnknown() {
	        return (this.#type & IFMT) === UNKNOWN;
	    }
	    isType(type) {
	        return this[`is${type}`]();
	    }
	    getType() {
	        return (this.isUnknown() ? 'Unknown'
	            : this.isDirectory() ? 'Directory'
	                : this.isFile() ? 'File'
	                    : this.isSymbolicLink() ? 'SymbolicLink'
	                        : this.isFIFO() ? 'FIFO'
	                            : this.isCharacterDevice() ? 'CharacterDevice'
	                                : this.isBlockDevice() ? 'BlockDevice'
	                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
	                                        : 'Unknown');
	        /* c8 ignore stop */
	    }
	    /**
	     * Is the Path a regular file?
	     */
	    isFile() {
	        return (this.#type & IFMT) === IFREG;
	    }
	    /**
	     * Is the Path a directory?
	     */
	    isDirectory() {
	        return (this.#type & IFMT) === IFDIR;
	    }
	    /**
	     * Is the path a character device?
	     */
	    isCharacterDevice() {
	        return (this.#type & IFMT) === IFCHR;
	    }
	    /**
	     * Is the path a block device?
	     */
	    isBlockDevice() {
	        return (this.#type & IFMT) === IFBLK;
	    }
	    /**
	     * Is the path a FIFO pipe?
	     */
	    isFIFO() {
	        return (this.#type & IFMT) === IFIFO;
	    }
	    /**
	     * Is the path a socket?
	     */
	    isSocket() {
	        return (this.#type & IFMT) === IFSOCK;
	    }
	    /**
	     * Is the path a symbolic link?
	     */
	    isSymbolicLink() {
	        return (this.#type & IFLNK) === IFLNK;
	    }
	    /**
	     * Return the entry if it has been subject of a successful lstat, or
	     * undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* simply
	     * mean that we haven't called lstat on it.
	     */
	    lstatCached() {
	        return this.#type & LSTAT_CALLED ? this : undefined;
	    }
	    /**
	     * Return the cached link target if the entry has been the subject of a
	     * successful readlink, or undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * readlink() has been called at some point.
	     */
	    readlinkCached() {
	        return this.#linkTarget;
	    }
	    /**
	     * Returns the cached realpath target if the entry has been the subject
	     * of a successful realpath, or undefined otherwise.
	     *
	     * Does not read the filesystem, so an undefined result *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * realpath() has been called at some point.
	     */
	    realpathCached() {
	        return this.#realpath;
	    }
	    /**
	     * Returns the cached child Path entries array if the entry has been the
	     * subject of a successful readdir(), or [] otherwise.
	     *
	     * Does not read the filesystem, so an empty array *could* just mean we
	     * don't have any cached data. Only use it if you are very sure that a
	     * readdir() has been called recently enough to still be valid.
	     */
	    readdirCached() {
	        const children = this.children();
	        return children.slice(0, children.provisional);
	    }
	    /**
	     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
	     * any indication that readlink will definitely fail.
	     *
	     * Returns false if the path is known to not be a symlink, if a previous
	     * readlink failed, or if the entry does not exist.
	     */
	    canReadlink() {
	        if (this.#linkTarget)
	            return true;
	        if (!this.parent)
	            return false;
	        // cases where it cannot possibly succeed
	        const ifmt = this.#type & IFMT;
	        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
	            this.#type & ENOREADLINK ||
	            this.#type & ENOENT);
	    }
	    /**
	     * Return true if readdir has previously been successfully called on this
	     * path, indicating that cachedReaddir() is likely valid.
	     */
	    calledReaddir() {
	        return !!(this.#type & READDIR_CALLED);
	    }
	    /**
	     * Returns true if the path is known to not exist. That is, a previous lstat
	     * or readdir failed to verify its existence when that would have been
	     * expected, or a parent entry was marked either enoent or enotdir.
	     */
	    isENOENT() {
	        return !!(this.#type & ENOENT);
	    }
	    /**
	     * Return true if the path is a match for the given path name.  This handles
	     * case sensitivity and unicode normalization.
	     *
	     * Note: even on case-sensitive systems, it is **not** safe to test the
	     * equality of the `.name` property to determine whether a given pathname
	     * matches, due to unicode normalization mismatches.
	     *
	     * Always use this method instead of testing the `path.name` property
	     * directly.
	     */
	    isNamed(n) {
	        return !this.nocase ?
	            this.#matchName === normalize(n)
	            : this.#matchName === normalizeNocase(n);
	    }
	    /**
	     * Return the Path object corresponding to the target of a symbolic link.
	     *
	     * If the Path is not a symbolic link, or if the readlink call fails for any
	     * reason, `undefined` is returned.
	     *
	     * Result is cached, and thus may be outdated if the filesystem is mutated.
	     */
	    async readlink() {
	        const target = this.#linkTarget;
	        if (target) {
	            return target;
	        }
	        if (!this.canReadlink()) {
	            return undefined;
	        }
	        /* c8 ignore start */
	        // already covered by the canReadlink test, here for ts grumples
	        if (!this.parent) {
	            return undefined;
	        }
	        /* c8 ignore stop */
	        try {
	            const read = await this.#fs.promises.readlink(this.fullpath());
	            const linkTarget = (await this.parent.realpath())?.resolve(read);
	            if (linkTarget) {
	                return (this.#linkTarget = linkTarget);
	            }
	        }
	        catch (er) {
	            this.#readlinkFail(er.code);
	            return undefined;
	        }
	    }
	    /**
	     * Synchronous {@link PathBase.readlink}
	     */
	    readlinkSync() {
	        const target = this.#linkTarget;
	        if (target) {
	            return target;
	        }
	        if (!this.canReadlink()) {
	            return undefined;
	        }
	        /* c8 ignore start */
	        // already covered by the canReadlink test, here for ts grumples
	        if (!this.parent) {
	            return undefined;
	        }
	        /* c8 ignore stop */
	        try {
	            const read = this.#fs.readlinkSync(this.fullpath());
	            const linkTarget = this.parent.realpathSync()?.resolve(read);
	            if (linkTarget) {
	                return (this.#linkTarget = linkTarget);
	            }
	        }
	        catch (er) {
	            this.#readlinkFail(er.code);
	            return undefined;
	        }
	    }
	    #readdirSuccess(children) {
	        // succeeded, mark readdir called bit
	        this.#type |= READDIR_CALLED;
	        // mark all remaining provisional children as ENOENT
	        for (let p = children.provisional; p < children.length; p++) {
	            const c = children[p];
	            if (c)
	                c.#markENOENT();
	        }
	    }
	    #markENOENT() {
	        // mark as UNKNOWN and ENOENT
	        if (this.#type & ENOENT)
	            return;
	        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
	        this.#markChildrenENOENT();
	    }
	    #markChildrenENOENT() {
	        // all children are provisional and do not exist
	        const children = this.children();
	        children.provisional = 0;
	        for (const p of children) {
	            p.#markENOENT();
	        }
	    }
	    #markENOREALPATH() {
	        this.#type |= ENOREALPATH;
	        this.#markENOTDIR();
	    }
	    // save the information when we know the entry is not a dir
	    #markENOTDIR() {
	        // entry is not a directory, so any children can't exist.
	        // this *should* be impossible, since any children created
	        // after it's been marked ENOTDIR should be marked ENOENT,
	        // so it won't even get to this point.
	        /* c8 ignore start */
	        if (this.#type & ENOTDIR)
	            return;
	        /* c8 ignore stop */
	        let t = this.#type;
	        // this could happen if we stat a dir, then delete it,
	        // then try to read it or one of its children.
	        if ((t & IFMT) === IFDIR)
	            t &= IFMT_UNKNOWN;
	        this.#type = t | ENOTDIR;
	        this.#markChildrenENOENT();
	    }
	    #readdirFail(code = '') {
	        // markENOTDIR and markENOENT also set provisional=0
	        if (code === 'ENOTDIR' || code === 'EPERM') {
	            this.#markENOTDIR();
	        }
	        else if (code === 'ENOENT') {
	            this.#markENOENT();
	        }
	        else {
	            this.children().provisional = 0;
	        }
	    }
	    #lstatFail(code = '') {
	        // Windows just raises ENOENT in this case, disable for win CI
	        /* c8 ignore start */
	        if (code === 'ENOTDIR') {
	            // already know it has a parent by this point
	            const p = this.parent;
	            p.#markENOTDIR();
	        }
	        else if (code === 'ENOENT') {
	            /* c8 ignore stop */
	            this.#markENOENT();
	        }
	    }
	    #readlinkFail(code = '') {
	        let ter = this.#type;
	        ter |= ENOREADLINK;
	        if (code === 'ENOENT')
	            ter |= ENOENT;
	        // windows gets a weird error when you try to readlink a file
	        if (code === 'EINVAL' || code === 'UNKNOWN') {
	            // exists, but not a symlink, we don't know WHAT it is, so remove
	            // all IFMT bits.
	            ter &= IFMT_UNKNOWN;
	        }
	        this.#type = ter;
	        // windows just gets ENOENT in this case.  We do cover the case,
	        // just disabled because it's impossible on Windows CI
	        /* c8 ignore start */
	        if (code === 'ENOTDIR' && this.parent) {
	            this.parent.#markENOTDIR();
	        }
	        /* c8 ignore stop */
	    }
	    #readdirAddChild(e, c) {
	        return (this.#readdirMaybePromoteChild(e, c) ||
	            this.#readdirAddNewChild(e, c));
	    }
	    #readdirAddNewChild(e, c) {
	        // alloc new entry at head, so it's never provisional
	        const type = entToType(e);
	        const child = this.newChild(e.name, type, { parent: this });
	        const ifmt = child.#type & IFMT;
	        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
	            child.#type |= ENOTDIR;
	        }
	        c.unshift(child);
	        c.provisional++;
	        return child;
	    }
	    #readdirMaybePromoteChild(e, c) {
	        for (let p = c.provisional; p < c.length; p++) {
	            const pchild = c[p];
	            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
	            if (name !== pchild.#matchName) {
	                continue;
	            }
	            return this.#readdirPromoteChild(e, pchild, p, c);
	        }
	    }
	    #readdirPromoteChild(e, p, index, c) {
	        const v = p.name;
	        // retain any other flags, but set ifmt from dirent
	        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
	        // case sensitivity fixing when we learn the true name.
	        if (v !== e.name)
	            p.name = e.name;
	        // just advance provisional index (potentially off the list),
	        // otherwise we have to splice/pop it out and re-insert at head
	        if (index !== c.provisional) {
	            if (index === c.length - 1)
	                c.pop();
	            else
	                c.splice(index, 1);
	            c.unshift(p);
	        }
	        c.provisional++;
	        return p;
	    }
	    /**
	     * Call lstat() on this Path, and update all known information that can be
	     * determined.
	     *
	     * Note that unlike `fs.lstat()`, the returned value does not contain some
	     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
	     * information is required, you will need to call `fs.lstat` yourself.
	     *
	     * If the Path refers to a nonexistent file, or if the lstat call fails for
	     * any reason, `undefined` is returned.  Otherwise the updated Path object is
	     * returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async lstat() {
	        if ((this.#type & ENOENT) === 0) {
	            try {
	                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
	                return this;
	            }
	            catch (er) {
	                this.#lstatFail(er.code);
	            }
	        }
	    }
	    /**
	     * synchronous {@link PathBase.lstat}
	     */
	    lstatSync() {
	        if ((this.#type & ENOENT) === 0) {
	            try {
	                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
	                return this;
	            }
	            catch (er) {
	                this.#lstatFail(er.code);
	            }
	        }
	    }
	    #applyStat(st) {
	        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
	        this.#atime = atime;
	        this.#atimeMs = atimeMs;
	        this.#birthtime = birthtime;
	        this.#birthtimeMs = birthtimeMs;
	        this.#blksize = blksize;
	        this.#blocks = blocks;
	        this.#ctime = ctime;
	        this.#ctimeMs = ctimeMs;
	        this.#dev = dev;
	        this.#gid = gid;
	        this.#ino = ino;
	        this.#mode = mode;
	        this.#mtime = mtime;
	        this.#mtimeMs = mtimeMs;
	        this.#nlink = nlink;
	        this.#rdev = rdev;
	        this.#size = size;
	        this.#uid = uid;
	        const ifmt = entToType(st);
	        // retain any other flags, but set the ifmt
	        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
	        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
	            this.#type |= ENOTDIR;
	        }
	    }
	    #onReaddirCB = [];
	    #readdirCBInFlight = false;
	    #callOnReaddirCB(children) {
	        this.#readdirCBInFlight = false;
	        const cbs = this.#onReaddirCB.slice();
	        this.#onReaddirCB.length = 0;
	        cbs.forEach(cb => cb(null, children));
	    }
	    /**
	     * Standard node-style callback interface to get list of directory entries.
	     *
	     * If the Path cannot or does not contain any children, then an empty array
	     * is returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     *
	     * @param cb The callback called with (er, entries).  Note that the `er`
	     * param is somewhat extraneous, as all readdir() errors are handled and
	     * simply result in an empty set of entries being returned.
	     * @param allowZalgo Boolean indicating that immediately known results should
	     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
	     * zalgo at your peril, the dark pony lord is devious and unforgiving.
	     */
	    readdirCB(cb, allowZalgo = false) {
	        if (!this.canReaddir()) {
	            if (allowZalgo)
	                cb(null, []);
	            else
	                queueMicrotask(() => cb(null, []));
	            return;
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            const c = children.slice(0, children.provisional);
	            if (allowZalgo)
	                cb(null, c);
	            else
	                queueMicrotask(() => cb(null, c));
	            return;
	        }
	        // don't have to worry about zalgo at this point.
	        this.#onReaddirCB.push(cb);
	        if (this.#readdirCBInFlight) {
	            return;
	        }
	        this.#readdirCBInFlight = true;
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
	            if (er) {
	                this.#readdirFail(er.code);
	                children.provisional = 0;
	            }
	            else {
	                // if we didn't get an error, we always get entries.
	                //@ts-ignore
	                for (const e of entries) {
	                    this.#readdirAddChild(e, children);
	                }
	                this.#readdirSuccess(children);
	            }
	            this.#callOnReaddirCB(children.slice(0, children.provisional));
	            return;
	        });
	    }
	    #asyncReaddirInFlight;
	    /**
	     * Return an array of known child entries.
	     *
	     * If the Path cannot or does not contain any children, then an empty array
	     * is returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async readdir() {
	        if (!this.canReaddir()) {
	            return [];
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            return children.slice(0, children.provisional);
	        }
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        if (this.#asyncReaddirInFlight) {
	            await this.#asyncReaddirInFlight;
	        }
	        else {
	            /* c8 ignore start */
	            let resolve = () => { };
	            /* c8 ignore stop */
	            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
	            try {
	                for (const e of await this.#fs.promises.readdir(fullpath, {
	                    withFileTypes: true,
	                })) {
	                    this.#readdirAddChild(e, children);
	                }
	                this.#readdirSuccess(children);
	            }
	            catch (er) {
	                this.#readdirFail(er.code);
	                children.provisional = 0;
	            }
	            this.#asyncReaddirInFlight = undefined;
	            resolve();
	        }
	        return children.slice(0, children.provisional);
	    }
	    /**
	     * synchronous {@link PathBase.readdir}
	     */
	    readdirSync() {
	        if (!this.canReaddir()) {
	            return [];
	        }
	        const children = this.children();
	        if (this.calledReaddir()) {
	            return children.slice(0, children.provisional);
	        }
	        // else read the directory, fill up children
	        // de-provisionalize any provisional children.
	        const fullpath = this.fullpath();
	        try {
	            for (const e of this.#fs.readdirSync(fullpath, {
	                withFileTypes: true,
	            })) {
	                this.#readdirAddChild(e, children);
	            }
	            this.#readdirSuccess(children);
	        }
	        catch (er) {
	            this.#readdirFail(er.code);
	            children.provisional = 0;
	        }
	        return children.slice(0, children.provisional);
	    }
	    canReaddir() {
	        if (this.#type & ENOCHILD)
	            return false;
	        const ifmt = IFMT & this.#type;
	        // we always set ENOTDIR when setting IFMT, so should be impossible
	        /* c8 ignore start */
	        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
	            return false;
	        }
	        /* c8 ignore stop */
	        return true;
	    }
	    shouldWalk(dirs, walkFilter) {
	        return ((this.#type & IFDIR) === IFDIR &&
	            !(this.#type & ENOCHILD) &&
	            !dirs.has(this) &&
	            (!walkFilter || walkFilter(this)));
	    }
	    /**
	     * Return the Path object corresponding to path as resolved
	     * by realpath(3).
	     *
	     * If the realpath call fails for any reason, `undefined` is returned.
	     *
	     * Result is cached, and thus may be outdated if the filesystem is mutated.
	     * On success, returns a Path object.
	     */
	    async realpath() {
	        if (this.#realpath)
	            return this.#realpath;
	        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
	            return undefined;
	        try {
	            const rp = await this.#fs.promises.realpath(this.fullpath());
	            return (this.#realpath = this.resolve(rp));
	        }
	        catch (_) {
	            this.#markENOREALPATH();
	        }
	    }
	    /**
	     * Synchronous {@link realpath}
	     */
	    realpathSync() {
	        if (this.#realpath)
	            return this.#realpath;
	        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
	            return undefined;
	        try {
	            const rp = this.#fs.realpathSync(this.fullpath());
	            return (this.#realpath = this.resolve(rp));
	        }
	        catch (_) {
	            this.#markENOREALPATH();
	        }
	    }
	    /**
	     * Internal method to mark this Path object as the scurry cwd,
	     * called by {@link PathScurry#chdir}
	     *
	     * @internal
	     */
	    [setAsCwd](oldCwd) {
	        if (oldCwd === this)
	            return;
	        oldCwd.isCWD = false;
	        this.isCWD = true;
	        const changed = new Set([]);
	        let rp = [];
	        let p = this;
	        while (p && p.parent) {
	            changed.add(p);
	            p.#relative = rp.join(this.sep);
	            p.#relativePosix = rp.join('/');
	            p = p.parent;
	            rp.push('..');
	        }
	        // now un-memoize parents of old cwd
	        p = oldCwd;
	        while (p && p.parent && !changed.has(p)) {
	            p.#relative = undefined;
	            p.#relativePosix = undefined;
	            p = p.parent;
	        }
	    }
	}
	commonjs$2.PathBase = PathBase;
	/**
	 * Path class used on win32 systems
	 *
	 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
	 * as the path separator for parsing paths.
	 */
	class PathWin32 extends PathBase {
	    /**
	     * Separator for generating path strings.
	     */
	    sep = '\\';
	    /**
	     * Separator for parsing path strings.
	     */
	    splitSep = eitherSep;
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        super(name, type, root, roots, nocase, children, opts);
	    }
	    /**
	     * @internal
	     */
	    newChild(name, type = UNKNOWN, opts = {}) {
	        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
	    }
	    /**
	     * @internal
	     */
	    getRootString(path) {
	        return node_path_1.win32.parse(path).root;
	    }
	    /**
	     * @internal
	     */
	    getRoot(rootPath) {
	        rootPath = uncToDrive(rootPath.toUpperCase());
	        if (rootPath === this.root.name) {
	            return this.root;
	        }
	        // ok, not that one, check if it matches another we know about
	        for (const [compare, root] of Object.entries(this.roots)) {
	            if (this.sameRoot(rootPath, compare)) {
	                return (this.roots[rootPath] = root);
	            }
	        }
	        // otherwise, have to create a new one.
	        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
	    }
	    /**
	     * @internal
	     */
	    sameRoot(rootPath, compare = this.root.name) {
	        // windows can (rarely) have case-sensitive filesystem, but
	        // UNC and drive letters are always case-insensitive, and canonically
	        // represented uppercase.
	        rootPath = rootPath
	            .toUpperCase()
	            .replace(/\//g, '\\')
	            .replace(uncDriveRegexp, '$1\\');
	        return rootPath === compare;
	    }
	}
	commonjs$2.PathWin32 = PathWin32;
	/**
	 * Path class used on all posix systems.
	 *
	 * Uses `'/'` as the path separator.
	 */
	class PathPosix extends PathBase {
	    /**
	     * separator for parsing path strings
	     */
	    splitSep = '/';
	    /**
	     * separator for generating path strings
	     */
	    sep = '/';
	    /**
	     * Do not create new Path objects directly.  They should always be accessed
	     * via the PathScurry class or other methods on the Path class.
	     *
	     * @internal
	     */
	    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
	        super(name, type, root, roots, nocase, children, opts);
	    }
	    /**
	     * @internal
	     */
	    getRootString(path) {
	        return path.startsWith('/') ? '/' : '';
	    }
	    /**
	     * @internal
	     */
	    getRoot(_rootPath) {
	        return this.root;
	    }
	    /**
	     * @internal
	     */
	    newChild(name, type = UNKNOWN, opts = {}) {
	        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
	    }
	}
	commonjs$2.PathPosix = PathPosix;
	/**
	 * The base class for all PathScurry classes, providing the interface for path
	 * resolution and filesystem operations.
	 *
	 * Typically, you should *not* instantiate this class directly, but rather one
	 * of the platform-specific classes, or the exported {@link PathScurry} which
	 * defaults to the current platform.
	 */
	class PathScurryBase {
	    /**
	     * The root Path entry for the current working directory of this Scurry
	     */
	    root;
	    /**
	     * The string path for the root of this Scurry's current working directory
	     */
	    rootPath;
	    /**
	     * A collection of all roots encountered, referenced by rootPath
	     */
	    roots;
	    /**
	     * The Path entry corresponding to this PathScurry's current working directory.
	     */
	    cwd;
	    #resolveCache;
	    #resolvePosixCache;
	    #children;
	    /**
	     * Perform path comparisons case-insensitively.
	     *
	     * Defaults true on Darwin and Windows systems, false elsewhere.
	     */
	    nocase;
	    #fs;
	    /**
	     * This class should not be instantiated directly.
	     *
	     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
	     *
	     * @internal
	     */
	    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
	        this.#fs = fsFromOption(fs);
	        if (cwd instanceof URL || cwd.startsWith('file://')) {
	            cwd = (0, node_url_1.fileURLToPath)(cwd);
	        }
	        // resolve and split root, and then add to the store.
	        // this is the only time we call path.resolve()
	        const cwdPath = pathImpl.resolve(cwd);
	        this.roots = Object.create(null);
	        this.rootPath = this.parseRootPath(cwdPath);
	        this.#resolveCache = new ResolveCache();
	        this.#resolvePosixCache = new ResolveCache();
	        this.#children = new ChildrenCache(childrenCacheSize);
	        const split = cwdPath.substring(this.rootPath.length).split(sep);
	        // resolve('/') leaves '', splits to [''], we don't want that.
	        if (split.length === 1 && !split[0]) {
	            split.pop();
	        }
	        /* c8 ignore start */
	        if (nocase === undefined) {
	            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
	        }
	        /* c8 ignore stop */
	        this.nocase = nocase;
	        this.root = this.newRoot(this.#fs);
	        this.roots[this.rootPath] = this.root;
	        let prev = this.root;
	        let len = split.length - 1;
	        const joinSep = pathImpl.sep;
	        let abs = this.rootPath;
	        let sawFirst = false;
	        for (const part of split) {
	            const l = len--;
	            prev = prev.child(part, {
	                relative: new Array(l).fill('..').join(joinSep),
	                relativePosix: new Array(l).fill('..').join('/'),
	                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
	            });
	            sawFirst = true;
	        }
	        this.cwd = prev;
	    }
	    /**
	     * Get the depth of a provided path, string, or the cwd
	     */
	    depth(path = this.cwd) {
	        if (typeof path === 'string') {
	            path = this.cwd.resolve(path);
	        }
	        return path.depth();
	    }
	    /**
	     * Return the cache of child entries.  Exposed so subclasses can create
	     * child Path objects in a platform-specific way.
	     *
	     * @internal
	     */
	    childrenCache() {
	        return this.#children;
	    }
	    /**
	     * Resolve one or more path strings to a resolved string
	     *
	     * Same interface as require('path').resolve.
	     *
	     * Much faster than path.resolve() when called multiple times for the same
	     * path, because the resolved Path objects are cached.  Much slower
	     * otherwise.
	     */
	    resolve(...paths) {
	        // first figure out the minimum number of paths we have to test
	        // we always start at cwd, but any absolutes will bump the start
	        let r = '';
	        for (let i = paths.length - 1; i >= 0; i--) {
	            const p = paths[i];
	            if (!p || p === '.')
	                continue;
	            r = r ? `${p}/${r}` : p;
	            if (this.isAbsolute(p)) {
	                break;
	            }
	        }
	        const cached = this.#resolveCache.get(r);
	        if (cached !== undefined) {
	            return cached;
	        }
	        const result = this.cwd.resolve(r).fullpath();
	        this.#resolveCache.set(r, result);
	        return result;
	    }
	    /**
	     * Resolve one or more path strings to a resolved string, returning
	     * the posix path.  Identical to .resolve() on posix systems, but on
	     * windows will return a forward-slash separated UNC path.
	     *
	     * Same interface as require('path').resolve.
	     *
	     * Much faster than path.resolve() when called multiple times for the same
	     * path, because the resolved Path objects are cached.  Much slower
	     * otherwise.
	     */
	    resolvePosix(...paths) {
	        // first figure out the minimum number of paths we have to test
	        // we always start at cwd, but any absolutes will bump the start
	        let r = '';
	        for (let i = paths.length - 1; i >= 0; i--) {
	            const p = paths[i];
	            if (!p || p === '.')
	                continue;
	            r = r ? `${p}/${r}` : p;
	            if (this.isAbsolute(p)) {
	                break;
	            }
	        }
	        const cached = this.#resolvePosixCache.get(r);
	        if (cached !== undefined) {
	            return cached;
	        }
	        const result = this.cwd.resolve(r).fullpathPosix();
	        this.#resolvePosixCache.set(r, result);
	        return result;
	    }
	    /**
	     * find the relative path from the cwd to the supplied path string or entry
	     */
	    relative(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.relative();
	    }
	    /**
	     * find the relative path from the cwd to the supplied path string or
	     * entry, using / as the path delimiter, even on Windows.
	     */
	    relativePosix(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.relativePosix();
	    }
	    /**
	     * Return the basename for the provided string or Path object
	     */
	    basename(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.name;
	    }
	    /**
	     * Return the dirname for the provided string or Path object
	     */
	    dirname(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return (entry.parent || entry).fullpath();
	    }
	    async readdir(entry = this.cwd, opts = {
	        withFileTypes: true,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes } = opts;
	        if (!entry.canReaddir()) {
	            return [];
	        }
	        else {
	            const p = await entry.readdir();
	            return withFileTypes ? p : p.map(e => e.name);
	        }
	    }
	    readdirSync(entry = this.cwd, opts = {
	        withFileTypes: true,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true } = opts;
	        if (!entry.canReaddir()) {
	            return [];
	        }
	        else if (withFileTypes) {
	            return entry.readdirSync();
	        }
	        else {
	            return entry.readdirSync().map(e => e.name);
	        }
	    }
	    /**
	     * Call lstat() on the string or Path object, and update all known
	     * information that can be determined.
	     *
	     * Note that unlike `fs.lstat()`, the returned value does not contain some
	     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
	     * information is required, you will need to call `fs.lstat` yourself.
	     *
	     * If the Path refers to a nonexistent file, or if the lstat call fails for
	     * any reason, `undefined` is returned.  Otherwise the updated Path object is
	     * returned.
	     *
	     * Results are cached, and thus may be out of date if the filesystem is
	     * mutated.
	     */
	    async lstat(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.lstat();
	    }
	    /**
	     * synchronous {@link PathScurryBase.lstat}
	     */
	    lstatSync(entry = this.cwd) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        return entry.lstatSync();
	    }
	    async readlink(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = await entry.readlink();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    readlinkSync(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = entry.readlinkSync();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    async realpath(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = await entry.realpath();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    realpathSync(entry = this.cwd, { withFileTypes } = {
	        withFileTypes: false,
	    }) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            withFileTypes = entry.withFileTypes;
	            entry = this.cwd;
	        }
	        const e = entry.realpathSync();
	        return withFileTypes ? e : e?.fullpath();
	    }
	    async walk(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = [];
	        if (!filter || filter(entry)) {
	            results.push(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set();
	        const walk = (dir, cb) => {
	            dirs.add(dir);
	            dir.readdirCB((er, entries) => {
	                /* c8 ignore start */
	                if (er) {
	                    return cb(er);
	                }
	                /* c8 ignore stop */
	                let len = entries.length;
	                if (!len)
	                    return cb();
	                const next = () => {
	                    if (--len === 0) {
	                        cb();
	                    }
	                };
	                for (const e of entries) {
	                    if (!filter || filter(e)) {
	                        results.push(withFileTypes ? e : e.fullpath());
	                    }
	                    if (follow && e.isSymbolicLink()) {
	                        e.realpath()
	                            .then(r => (r?.isUnknown() ? r.lstat() : r))
	                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
	                    }
	                    else {
	                        if (e.shouldWalk(dirs, walkFilter)) {
	                            walk(e, next);
	                        }
	                        else {
	                            next();
	                        }
	                    }
	                }
	            }, true); // zalgooooooo
	        };
	        const start = entry;
	        return new Promise((res, rej) => {
	            walk(start, er => {
	                /* c8 ignore start */
	                if (er)
	                    return rej(er);
	                /* c8 ignore stop */
	                res(results);
	            });
	        });
	    }
	    walkSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = [];
	        if (!filter || filter(entry)) {
	            results.push(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set([entry]);
	        for (const dir of dirs) {
	            const entries = dir.readdirSync();
	            for (const e of entries) {
	                if (!filter || filter(e)) {
	                    results.push(withFileTypes ? e : e.fullpath());
	                }
	                let r = e;
	                if (e.isSymbolicLink()) {
	                    if (!(follow && (r = e.realpathSync())))
	                        continue;
	                    if (r.isUnknown())
	                        r.lstatSync();
	                }
	                if (r.shouldWalk(dirs, walkFilter)) {
	                    dirs.add(r);
	                }
	            }
	        }
	        return results;
	    }
	    /**
	     * Support for `for await`
	     *
	     * Alias for {@link PathScurryBase.iterate}
	     *
	     * Note: As of Node 19, this is very slow, compared to other methods of
	     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
	     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
	     */
	    [Symbol.asyncIterator]() {
	        return this.iterate();
	    }
	    iterate(entry = this.cwd, options = {}) {
	        // iterating async over the stream is significantly more performant,
	        // especially in the warm-cache scenario, because it buffers up directory
	        // entries in the background instead of waiting for a yield for each one.
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            options = entry;
	            entry = this.cwd;
	        }
	        return this.stream(entry, options)[Symbol.asyncIterator]();
	    }
	    /**
	     * Iterating over a PathScurry performs a synchronous walk.
	     *
	     * Alias for {@link PathScurryBase.iterateSync}
	     */
	    [Symbol.iterator]() {
	        return this.iterateSync();
	    }
	    *iterateSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        if (!filter || filter(entry)) {
	            yield withFileTypes ? entry : entry.fullpath();
	        }
	        const dirs = new Set([entry]);
	        for (const dir of dirs) {
	            const entries = dir.readdirSync();
	            for (const e of entries) {
	                if (!filter || filter(e)) {
	                    yield withFileTypes ? e : e.fullpath();
	                }
	                let r = e;
	                if (e.isSymbolicLink()) {
	                    if (!(follow && (r = e.realpathSync())))
	                        continue;
	                    if (r.isUnknown())
	                        r.lstatSync();
	                }
	                if (r.shouldWalk(dirs, walkFilter)) {
	                    dirs.add(r);
	                }
	            }
	        }
	    }
	    stream(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = new minipass_1.Minipass({ objectMode: true });
	        if (!filter || filter(entry)) {
	            results.write(withFileTypes ? entry : entry.fullpath());
	        }
	        const dirs = new Set();
	        const queue = [entry];
	        let processing = 0;
	        const process = () => {
	            let paused = false;
	            while (!paused) {
	                const dir = queue.shift();
	                if (!dir) {
	                    if (processing === 0)
	                        results.end();
	                    return;
	                }
	                processing++;
	                dirs.add(dir);
	                const onReaddir = (er, entries, didRealpaths = false) => {
	                    /* c8 ignore start */
	                    if (er)
	                        return results.emit('error', er);
	                    /* c8 ignore stop */
	                    if (follow && !didRealpaths) {
	                        const promises = [];
	                        for (const e of entries) {
	                            if (e.isSymbolicLink()) {
	                                promises.push(e
	                                    .realpath()
	                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
	                            }
	                        }
	                        if (promises.length) {
	                            Promise.all(promises).then(() => onReaddir(null, entries, true));
	                            return;
	                        }
	                    }
	                    for (const e of entries) {
	                        if (e && (!filter || filter(e))) {
	                            if (!results.write(withFileTypes ? e : e.fullpath())) {
	                                paused = true;
	                            }
	                        }
	                    }
	                    processing--;
	                    for (const e of entries) {
	                        const r = e.realpathCached() || e;
	                        if (r.shouldWalk(dirs, walkFilter)) {
	                            queue.push(r);
	                        }
	                    }
	                    if (paused && !results.flowing) {
	                        results.once('drain', process);
	                    }
	                    else if (!sync) {
	                        process();
	                    }
	                };
	                // zalgo containment
	                let sync = true;
	                dir.readdirCB(onReaddir, true);
	                sync = false;
	            }
	        };
	        process();
	        return results;
	    }
	    streamSync(entry = this.cwd, opts = {}) {
	        if (typeof entry === 'string') {
	            entry = this.cwd.resolve(entry);
	        }
	        else if (!(entry instanceof PathBase)) {
	            opts = entry;
	            entry = this.cwd;
	        }
	        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
	        const results = new minipass_1.Minipass({ objectMode: true });
	        const dirs = new Set();
	        if (!filter || filter(entry)) {
	            results.write(withFileTypes ? entry : entry.fullpath());
	        }
	        const queue = [entry];
	        let processing = 0;
	        const process = () => {
	            let paused = false;
	            while (!paused) {
	                const dir = queue.shift();
	                if (!dir) {
	                    if (processing === 0)
	                        results.end();
	                    return;
	                }
	                processing++;
	                dirs.add(dir);
	                const entries = dir.readdirSync();
	                for (const e of entries) {
	                    if (!filter || filter(e)) {
	                        if (!results.write(withFileTypes ? e : e.fullpath())) {
	                            paused = true;
	                        }
	                    }
	                }
	                processing--;
	                for (const e of entries) {
	                    let r = e;
	                    if (e.isSymbolicLink()) {
	                        if (!(follow && (r = e.realpathSync())))
	                            continue;
	                        if (r.isUnknown())
	                            r.lstatSync();
	                    }
	                    if (r.shouldWalk(dirs, walkFilter)) {
	                        queue.push(r);
	                    }
	                }
	            }
	            if (paused && !results.flowing)
	                results.once('drain', process);
	        };
	        process();
	        return results;
	    }
	    chdir(path = this.cwd) {
	        const oldCwd = this.cwd;
	        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
	        this.cwd[setAsCwd](oldCwd);
	    }
	}
	commonjs$2.PathScurryBase = PathScurryBase;
	/**
	 * Windows implementation of {@link PathScurryBase}
	 *
	 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
	 * {@link PathWin32} for Path objects.
	 */
	class PathScurryWin32 extends PathScurryBase {
	    /**
	     * separator for generating path strings
	     */
	    sep = '\\';
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = true } = opts;
	        super(cwd, node_path_1.win32, '\\', { ...opts, nocase });
	        this.nocase = nocase;
	        for (let p = this.cwd; p; p = p.parent) {
	            p.nocase = this.nocase;
	        }
	    }
	    /**
	     * @internal
	     */
	    parseRootPath(dir) {
	        // if the path starts with a single separator, it's not a UNC, and we'll
	        // just get separator as the root, and driveFromUNC will return \
	        // In that case, mount \ on the root from the cwd.
	        return node_path_1.win32.parse(dir).root.toUpperCase();
	    }
	    /**
	     * @internal
	     */
	    newRoot(fs) {
	        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
	    }
	    /**
	     * Return true if the provided path string is an absolute path
	     */
	    isAbsolute(p) {
	        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
	    }
	}
	commonjs$2.PathScurryWin32 = PathScurryWin32;
	/**
	 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
	 *
	 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
	 *
	 * Uses {@link PathPosix} for Path objects.
	 */
	class PathScurryPosix extends PathScurryBase {
	    /**
	     * separator for generating path strings
	     */
	    sep = '/';
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = false } = opts;
	        super(cwd, node_path_1.posix, '/', { ...opts, nocase });
	        this.nocase = nocase;
	    }
	    /**
	     * @internal
	     */
	    parseRootPath(_dir) {
	        return '/';
	    }
	    /**
	     * @internal
	     */
	    newRoot(fs) {
	        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
	    }
	    /**
	     * Return true if the provided path string is an absolute path
	     */
	    isAbsolute(p) {
	        return p.startsWith('/');
	    }
	}
	commonjs$2.PathScurryPosix = PathScurryPosix;
	/**
	 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
	 *
	 * Defaults to case-insensitive matching, uses `'/'` for generating path
	 * strings.
	 *
	 * Uses {@link PathPosix} for Path objects.
	 */
	class PathScurryDarwin extends PathScurryPosix {
	    constructor(cwd = process.cwd(), opts = {}) {
	        const { nocase = true } = opts;
	        super(cwd, { ...opts, nocase });
	    }
	}
	commonjs$2.PathScurryDarwin = PathScurryDarwin;
	/**
	 * Default {@link PathBase} implementation for the current platform.
	 *
	 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
	 */
	commonjs$2.Path = process.platform === 'win32' ? PathWin32 : PathPosix;
	/**
	 * Default {@link PathScurryBase} implementation for the current platform.
	 *
	 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
	 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
	 */
	commonjs$2.PathScurry = process.platform === 'win32' ? PathScurryWin32
	    : process.platform === 'darwin' ? PathScurryDarwin
	        : PathScurryPosix;
	
	return commonjs$2;
}

var pattern = {};

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	// this is just a very light wrapper around 2 arrays with an offset index
	Object.defineProperty(pattern, "__esModule", { value: true });
	pattern.Pattern = void 0;
	const minimatch_1 = requireCommonjs$4();
	const isPatternList = (pl) => pl.length >= 1;
	const isGlobList = (gl) => gl.length >= 1;
	/**
	 * An immutable-ish view on an array of glob parts and their parsed
	 * results
	 */
	class Pattern {
	    #patternList;
	    #globList;
	    #index;
	    length;
	    #platform;
	    #rest;
	    #globString;
	    #isDrive;
	    #isUNC;
	    #isAbsolute;
	    #followGlobstar = true;
	    constructor(patternList, globList, index, platform) {
	        if (!isPatternList(patternList)) {
	            throw new TypeError('empty pattern list');
	        }
	        if (!isGlobList(globList)) {
	            throw new TypeError('empty glob list');
	        }
	        if (globList.length !== patternList.length) {
	            throw new TypeError('mismatched pattern list and glob list lengths');
	        }
	        this.length = patternList.length;
	        if (index < 0 || index >= this.length) {
	            throw new TypeError('index out of range');
	        }
	        this.#patternList = patternList;
	        this.#globList = globList;
	        this.#index = index;
	        this.#platform = platform;
	        // normalize root entries of absolute patterns on initial creation.
	        if (this.#index === 0) {
	            // c: => ['c:/']
	            // C:/ => ['C:/']
	            // C:/x => ['C:/', 'x']
	            // //host/share => ['//host/share/']
	            // //host/share/ => ['//host/share/']
	            // //host/share/x => ['//host/share/', 'x']
	            // /etc => ['/', 'etc']
	            // / => ['/']
	            if (this.isUNC()) {
	                // '' / '' / 'host' / 'share'
	                const [p0, p1, p2, p3, ...prest] = this.#patternList;
	                const [g0, g1, g2, g3, ...grest] = this.#globList;
	                if (prest[0] === '') {
	                    // ends in /
	                    prest.shift();
	                    grest.shift();
	                }
	                const p = [p0, p1, p2, p3, ''].join('/');
	                const g = [g0, g1, g2, g3, ''].join('/');
	                this.#patternList = [p, ...prest];
	                this.#globList = [g, ...grest];
	                this.length = this.#patternList.length;
	            }
	            else if (this.isDrive() || this.isAbsolute()) {
	                const [p1, ...prest] = this.#patternList;
	                const [g1, ...grest] = this.#globList;
	                if (prest[0] === '') {
	                    // ends in /
	                    prest.shift();
	                    grest.shift();
	                }
	                const p = p1 + '/';
	                const g = g1 + '/';
	                this.#patternList = [p, ...prest];
	                this.#globList = [g, ...grest];
	                this.length = this.#patternList.length;
	            }
	        }
	    }
	    /**
	     * The first entry in the parsed list of patterns
	     */
	    pattern() {
	        return this.#patternList[this.#index];
	    }
	    /**
	     * true of if pattern() returns a string
	     */
	    isString() {
	        return typeof this.#patternList[this.#index] === 'string';
	    }
	    /**
	     * true of if pattern() returns GLOBSTAR
	     */
	    isGlobstar() {
	        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
	    }
	    /**
	     * true if pattern() returns a regexp
	     */
	    isRegExp() {
	        return this.#patternList[this.#index] instanceof RegExp;
	    }
	    /**
	     * The /-joined set of glob parts that make up this pattern
	     */
	    globString() {
	        return (this.#globString =
	            this.#globString ||
	                (this.#index === 0 ?
	                    this.isAbsolute() ?
	                        this.#globList[0] + this.#globList.slice(1).join('/')
	                        : this.#globList.join('/')
	                    : this.#globList.slice(this.#index).join('/')));
	    }
	    /**
	     * true if there are more pattern parts after this one
	     */
	    hasMore() {
	        return this.length > this.#index + 1;
	    }
	    /**
	     * The rest of the pattern after this part, or null if this is the end
	     */
	    rest() {
	        if (this.#rest !== undefined)
	            return this.#rest;
	        if (!this.hasMore())
	            return (this.#rest = null);
	        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
	        this.#rest.#isAbsolute = this.#isAbsolute;
	        this.#rest.#isUNC = this.#isUNC;
	        this.#rest.#isDrive = this.#isDrive;
	        return this.#rest;
	    }
	    /**
	     * true if the pattern represents a //unc/path/ on windows
	     */
	    isUNC() {
	        const pl = this.#patternList;
	        return this.#isUNC !== undefined ?
	            this.#isUNC
	            : (this.#isUNC =
	                this.#platform === 'win32' &&
	                    this.#index === 0 &&
	                    pl[0] === '' &&
	                    pl[1] === '' &&
	                    typeof pl[2] === 'string' &&
	                    !!pl[2] &&
	                    typeof pl[3] === 'string' &&
	                    !!pl[3]);
	    }
	    // pattern like C:/...
	    // split = ['C:', ...]
	    // XXX: would be nice to handle patterns like `c:*` to test the cwd
	    // in c: for *, but I don't know of a way to even figure out what that
	    // cwd is without actually chdir'ing into it?
	    /**
	     * True if the pattern starts with a drive letter on Windows
	     */
	    isDrive() {
	        const pl = this.#patternList;
	        return this.#isDrive !== undefined ?
	            this.#isDrive
	            : (this.#isDrive =
	                this.#platform === 'win32' &&
	                    this.#index === 0 &&
	                    this.length > 1 &&
	                    typeof pl[0] === 'string' &&
	                    /^[a-z]:$/i.test(pl[0]));
	    }
	    // pattern = '/' or '/...' or '/x/...'
	    // split = ['', ''] or ['', ...] or ['', 'x', ...]
	    // Drive and UNC both considered absolute on windows
	    /**
	     * True if the pattern is rooted on an absolute path
	     */
	    isAbsolute() {
	        const pl = this.#patternList;
	        return this.#isAbsolute !== undefined ?
	            this.#isAbsolute
	            : (this.#isAbsolute =
	                (pl[0] === '' && pl.length > 1) ||
	                    this.isDrive() ||
	                    this.isUNC());
	    }
	    /**
	     * consume the root of the pattern, and return it
	     */
	    root() {
	        const p = this.#patternList[0];
	        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
	            p
	            : '';
	    }
	    /**
	     * Check to see if the current globstar pattern is allowed to follow
	     * a symbolic link.
	     */
	    checkFollowGlobstar() {
	        return !(this.#index === 0 ||
	            !this.isGlobstar() ||
	            !this.#followGlobstar);
	    }
	    /**
	     * Mark that the current globstar pattern is following a symbolic link
	     */
	    markFollowGlobstar() {
	        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
	            return false;
	        this.#followGlobstar = false;
	        return true;
	    }
	}
	pattern.Pattern = Pattern;
	
	return pattern;
}

var walker = {};

var ignore = {};

var hasRequiredIgnore;

function requireIgnore () {
	if (hasRequiredIgnore) return ignore;
	hasRequiredIgnore = 1;
	// give it a pattern, and it'll be able to tell you if
	// a given path should be ignored.
	// Ignoring a path ignores its children if the pattern ends in /**
	// Ignores are always parsed in dot:true mode
	Object.defineProperty(ignore, "__esModule", { value: true });
	ignore.Ignore = void 0;
	const minimatch_1 = requireCommonjs$4();
	const pattern_js_1 = requirePattern();
	const defaultPlatform = (typeof process === 'object' &&
	    process &&
	    typeof process.platform === 'string') ?
	    process.platform
	    : 'linux';
	/**
	 * Class used to process ignored patterns
	 */
	class Ignore {
	    relative;
	    relativeChildren;
	    absolute;
	    absoluteChildren;
	    platform;
	    mmopts;
	    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {
	        this.relative = [];
	        this.absolute = [];
	        this.relativeChildren = [];
	        this.absoluteChildren = [];
	        this.platform = platform;
	        this.mmopts = {
	            dot: true,
	            nobrace,
	            nocase,
	            noext,
	            noglobstar,
	            optimizationLevel: 2,
	            platform,
	            nocomment: true,
	            nonegate: true,
	        };
	        for (const ign of ignored)
	            this.add(ign);
	    }
	    add(ign) {
	        // this is a little weird, but it gives us a clean set of optimized
	        // minimatch matchers, without getting tripped up if one of them
	        // ends in /** inside a brace section, and it's only inefficient at
	        // the start of the walk, not along it.
	        // It'd be nice if the Pattern class just had a .test() method, but
	        // handling globstars is a bit of a pita, and that code already lives
	        // in minimatch anyway.
	        // Another way would be if maybe Minimatch could take its set/globParts
	        // as an option, and then we could at least just use Pattern to test
	        // for absolute-ness.
	        // Yet another way, Minimatch could take an array of glob strings, and
	        // a cwd option, and do the right thing.
	        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
	        for (let i = 0; i < mm.set.length; i++) {
	            const parsed = mm.set[i];
	            const globParts = mm.globParts[i];
	            /* c8 ignore start */
	            if (!parsed || !globParts) {
	                throw new Error('invalid pattern object');
	            }
	            // strip off leading ./ portions
	            // https://github.com/isaacs/node-glob/issues/570
	            while (parsed[0] === '.' && globParts[0] === '.') {
	                parsed.shift();
	                globParts.shift();
	            }
	            /* c8 ignore stop */
	            const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
	            const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
	            const children = globParts[globParts.length - 1] === '**';
	            const absolute = p.isAbsolute();
	            if (absolute)
	                this.absolute.push(m);
	            else
	                this.relative.push(m);
	            if (children) {
	                if (absolute)
	                    this.absoluteChildren.push(m);
	                else
	                    this.relativeChildren.push(m);
	            }
	        }
	    }
	    ignored(p) {
	        const fullpath = p.fullpath();
	        const fullpaths = `${fullpath}/`;
	        const relative = p.relative() || '.';
	        const relatives = `${relative}/`;
	        for (const m of this.relative) {
	            if (m.match(relative) || m.match(relatives))
	                return true;
	        }
	        for (const m of this.absolute) {
	            if (m.match(fullpath) || m.match(fullpaths))
	                return true;
	        }
	        return false;
	    }
	    childrenIgnored(p) {
	        const fullpath = p.fullpath() + '/';
	        const relative = (p.relative() || '.') + '/';
	        for (const m of this.relativeChildren) {
	            if (m.match(relative))
	                return true;
	        }
	        for (const m of this.absoluteChildren) {
	            if (m.match(fullpath))
	                return true;
	        }
	        return false;
	    }
	}
	ignore.Ignore = Ignore;
	
	return ignore;
}

var processor = {};

var hasRequiredProcessor;

function requireProcessor () {
	if (hasRequiredProcessor) return processor;
	hasRequiredProcessor = 1;
	// synchronous utility for filtering entries and calculating subwalks
	Object.defineProperty(processor, "__esModule", { value: true });
	processor.Processor = processor.SubWalks = processor.MatchRecord = processor.HasWalkedCache = void 0;
	const minimatch_1 = requireCommonjs$4();
	/**
	 * A cache of which patterns have been processed for a given Path
	 */
	class HasWalkedCache {
	    store;
	    constructor(store = new Map()) {
	        this.store = store;
	    }
	    copy() {
	        return new HasWalkedCache(new Map(this.store));
	    }
	    hasWalked(target, pattern) {
	        return this.store.get(target.fullpath())?.has(pattern.globString());
	    }
	    storeWalked(target, pattern) {
	        const fullpath = target.fullpath();
	        const cached = this.store.get(fullpath);
	        if (cached)
	            cached.add(pattern.globString());
	        else
	            this.store.set(fullpath, new Set([pattern.globString()]));
	    }
	}
	processor.HasWalkedCache = HasWalkedCache;
	/**
	 * A record of which paths have been matched in a given walk step,
	 * and whether they only are considered a match if they are a directory,
	 * and whether their absolute or relative path should be returned.
	 */
	class MatchRecord {
	    store = new Map();
	    add(target, absolute, ifDir) {
	        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
	        const current = this.store.get(target);
	        this.store.set(target, current === undefined ? n : n & current);
	    }
	    // match, absolute, ifdir
	    entries() {
	        return [...this.store.entries()].map(([path, n]) => [
	            path,
	            !!(n & 2),
	            !!(n & 1),
	        ]);
	    }
	}
	processor.MatchRecord = MatchRecord;
	/**
	 * A collection of patterns that must be processed in a subsequent step
	 * for a given path.
	 */
	class SubWalks {
	    store = new Map();
	    add(target, pattern) {
	        if (!target.canReaddir()) {
	            return;
	        }
	        const subs = this.store.get(target);
	        if (subs) {
	            if (!subs.find(p => p.globString() === pattern.globString())) {
	                subs.push(pattern);
	            }
	        }
	        else
	            this.store.set(target, [pattern]);
	    }
	    get(target) {
	        const subs = this.store.get(target);
	        /* c8 ignore start */
	        if (!subs) {
	            throw new Error('attempting to walk unknown path');
	        }
	        /* c8 ignore stop */
	        return subs;
	    }
	    entries() {
	        return this.keys().map(k => [k, this.store.get(k)]);
	    }
	    keys() {
	        return [...this.store.keys()].filter(t => t.canReaddir());
	    }
	}
	processor.SubWalks = SubWalks;
	/**
	 * The class that processes patterns for a given path.
	 *
	 * Handles child entry filtering, and determining whether a path's
	 * directory contents must be read.
	 */
	class Processor {
	    hasWalkedCache;
	    matches = new MatchRecord();
	    subwalks = new SubWalks();
	    patterns;
	    follow;
	    dot;
	    opts;
	    constructor(opts, hasWalkedCache) {
	        this.opts = opts;
	        this.follow = !!opts.follow;
	        this.dot = !!opts.dot;
	        this.hasWalkedCache =
	            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
	    }
	    processPatterns(target, patterns) {
	        this.patterns = patterns;
	        const processingSet = patterns.map(p => [target, p]);
	        // map of paths to the magic-starting subwalks they need to walk
	        // first item in patterns is the filter
	        for (let [t, pattern] of processingSet) {
	            this.hasWalkedCache.storeWalked(t, pattern);
	            const root = pattern.root();
	            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
	            // start absolute patterns at root
	            if (root) {
	                t = t.resolve(root === '/' && this.opts.root !== undefined ?
	                    this.opts.root
	                    : root);
	                const rest = pattern.rest();
	                if (!rest) {
	                    this.matches.add(t, true, false);
	                    continue;
	                }
	                else {
	                    pattern = rest;
	                }
	            }
	            if (t.isENOENT())
	                continue;
	            let p;
	            let rest;
	            let changed = false;
	            while (typeof (p = pattern.pattern()) === 'string' &&
	                (rest = pattern.rest())) {
	                const c = t.resolve(p);
	                t = c;
	                pattern = rest;
	                changed = true;
	            }
	            p = pattern.pattern();
	            rest = pattern.rest();
	            if (changed) {
	                if (this.hasWalkedCache.hasWalked(t, pattern))
	                    continue;
	                this.hasWalkedCache.storeWalked(t, pattern);
	            }
	            // now we have either a final string for a known entry,
	            // more strings for an unknown entry,
	            // or a pattern starting with magic, mounted on t.
	            if (typeof p === 'string') {
	                // must not be final entry, otherwise we would have
	                // concatenated it earlier.
	                const ifDir = p === '..' || p === '' || p === '.';
	                this.matches.add(t.resolve(p), absolute, ifDir);
	                continue;
	            }
	            else if (p === minimatch_1.GLOBSTAR) {
	                // if no rest, match and subwalk pattern
	                // if rest, process rest and subwalk pattern
	                // if it's a symlink, but we didn't get here by way of a
	                // globstar match (meaning it's the first time THIS globstar
	                // has traversed a symlink), then we follow it. Otherwise, stop.
	                if (!t.isSymbolicLink() ||
	                    this.follow ||
	                    pattern.checkFollowGlobstar()) {
	                    this.subwalks.add(t, pattern);
	                }
	                const rp = rest?.pattern();
	                const rrest = rest?.rest();
	                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
	                    // only HAS to be a dir if it ends in **/ or **/.
	                    // but ending in ** will match files as well.
	                    this.matches.add(t, absolute, rp === '' || rp === '.');
	                }
	                else {
	                    if (rp === '..') {
	                        // this would mean you're matching **/.. at the fs root,
	                        // and no thanks, I'm not gonna test that specific case.
	                        /* c8 ignore start */
	                        const tp = t.parent || t;
	                        /* c8 ignore stop */
	                        if (!rrest)
	                            this.matches.add(tp, absolute, true);
	                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
	                            this.subwalks.add(tp, rrest);
	                        }
	                    }
	                }
	            }
	            else if (p instanceof RegExp) {
	                this.subwalks.add(t, pattern);
	            }
	        }
	        return this;
	    }
	    subwalkTargets() {
	        return this.subwalks.keys();
	    }
	    child() {
	        return new Processor(this.opts, this.hasWalkedCache);
	    }
	    // return a new Processor containing the subwalks for each
	    // child entry, and a set of matches, and
	    // a hasWalkedCache that's a copy of this one
	    // then we're going to call
	    filterEntries(parent, entries) {
	        const patterns = this.subwalks.get(parent);
	        // put matches and entry walks into the results processor
	        const results = this.child();
	        for (const e of entries) {
	            for (const pattern of patterns) {
	                const absolute = pattern.isAbsolute();
	                const p = pattern.pattern();
	                const rest = pattern.rest();
	                if (p === minimatch_1.GLOBSTAR) {
	                    results.testGlobstar(e, pattern, rest, absolute);
	                }
	                else if (p instanceof RegExp) {
	                    results.testRegExp(e, p, rest, absolute);
	                }
	                else {
	                    results.testString(e, p, rest, absolute);
	                }
	            }
	        }
	        return results;
	    }
	    testGlobstar(e, pattern, rest, absolute) {
	        if (this.dot || !e.name.startsWith('.')) {
	            if (!pattern.hasMore()) {
	                this.matches.add(e, absolute, false);
	            }
	            if (e.canReaddir()) {
	                // if we're in follow mode or it's not a symlink, just keep
	                // testing the same pattern. If there's more after the globstar,
	                // then this symlink consumes the globstar. If not, then we can
	                // follow at most ONE symlink along the way, so we mark it, which
	                // also checks to ensure that it wasn't already marked.
	                if (this.follow || !e.isSymbolicLink()) {
	                    this.subwalks.add(e, pattern);
	                }
	                else if (e.isSymbolicLink()) {
	                    if (rest && pattern.checkFollowGlobstar()) {
	                        this.subwalks.add(e, rest);
	                    }
	                    else if (pattern.markFollowGlobstar()) {
	                        this.subwalks.add(e, pattern);
	                    }
	                }
	            }
	        }
	        // if the NEXT thing matches this entry, then also add
	        // the rest.
	        if (rest) {
	            const rp = rest.pattern();
	            if (typeof rp === 'string' &&
	                // dots and empty were handled already
	                rp !== '..' &&
	                rp !== '' &&
	                rp !== '.') {
	                this.testString(e, rp, rest.rest(), absolute);
	            }
	            else if (rp === '..') {
	                /* c8 ignore start */
	                const ep = e.parent || e;
	                /* c8 ignore stop */
	                this.subwalks.add(ep, rest);
	            }
	            else if (rp instanceof RegExp) {
	                this.testRegExp(e, rp, rest.rest(), absolute);
	            }
	        }
	    }
	    testRegExp(e, p, rest, absolute) {
	        if (!p.test(e.name))
	            return;
	        if (!rest) {
	            this.matches.add(e, absolute, false);
	        }
	        else {
	            this.subwalks.add(e, rest);
	        }
	    }
	    testString(e, p, rest, absolute) {
	        // should never happen?
	        if (!e.isNamed(p))
	            return;
	        if (!rest) {
	            this.matches.add(e, absolute, false);
	        }
	        else {
	            this.subwalks.add(e, rest);
	        }
	    }
	}
	processor.Processor = Processor;
	
	return processor;
}

var hasRequiredWalker;

function requireWalker () {
	if (hasRequiredWalker) return walker;
	hasRequiredWalker = 1;
	Object.defineProperty(walker, "__esModule", { value: true });
	walker.GlobStream = walker.GlobWalker = walker.GlobUtil = void 0;
	/**
	 * Single-use utility classes to provide functionality to the {@link Glob}
	 * methods.
	 *
	 * @module
	 */
	const minipass_1 = requireCommonjs$2();
	const ignore_js_1 = requireIgnore();
	const processor_js_1 = requireProcessor();
	const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts)
	    : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts)
	        : ignore;
	/**
	 * basic walking utilities that all the glob walker types use
	 */
	class GlobUtil {
	    path;
	    patterns;
	    opts;
	    seen = new Set();
	    paused = false;
	    aborted = false;
	    #onResume = [];
	    #ignore;
	    #sep;
	    signal;
	    maxDepth;
	    includeChildMatches;
	    constructor(patterns, path, opts) {
	        this.patterns = patterns;
	        this.path = path;
	        this.opts = opts;
	        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
	        this.includeChildMatches = opts.includeChildMatches !== false;
	        if (opts.ignore || !this.includeChildMatches) {
	            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
	            if (!this.includeChildMatches &&
	                typeof this.#ignore.add !== 'function') {
	                const m = 'cannot ignore child matches, ignore lacks add() method.';
	                throw new Error(m);
	            }
	        }
	        // ignore, always set with maxDepth, but it's optional on the
	        // GlobOptions type
	        /* c8 ignore start */
	        this.maxDepth = opts.maxDepth || Infinity;
	        /* c8 ignore stop */
	        if (opts.signal) {
	            this.signal = opts.signal;
	            this.signal.addEventListener('abort', () => {
	                this.#onResume.length = 0;
	            });
	        }
	    }
	    #ignored(path) {
	        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
	    }
	    #childrenIgnored(path) {
	        return !!this.#ignore?.childrenIgnored?.(path);
	    }
	    // backpressure mechanism
	    pause() {
	        this.paused = true;
	    }
	    resume() {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            return;
	        /* c8 ignore stop */
	        this.paused = false;
	        let fn = undefined;
	        while (!this.paused && (fn = this.#onResume.shift())) {
	            fn();
	        }
	    }
	    onResume(fn) {
	        if (this.signal?.aborted)
	            return;
	        /* c8 ignore start */
	        if (!this.paused) {
	            fn();
	        }
	        else {
	            /* c8 ignore stop */
	            this.#onResume.push(fn);
	        }
	    }
	    // do the requisite realpath/stat checking, and return the path
	    // to add or undefined to filter it out.
	    async matchCheck(e, ifDir) {
	        if (ifDir && this.opts.nodir)
	            return undefined;
	        let rpc;
	        if (this.opts.realpath) {
	            rpc = e.realpathCached() || (await e.realpath());
	            if (!rpc)
	                return undefined;
	            e = rpc;
	        }
	        const needStat = e.isUnknown() || this.opts.stat;
	        const s = needStat ? await e.lstat() : e;
	        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
	            const target = await s.realpath();
	            /* c8 ignore start */
	            if (target && (target.isUnknown() || this.opts.stat)) {
	                await target.lstat();
	            }
	            /* c8 ignore stop */
	        }
	        return this.matchCheckTest(s, ifDir);
	    }
	    matchCheckTest(e, ifDir) {
	        return (e &&
	            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
	            (!ifDir || e.canReaddir()) &&
	            (!this.opts.nodir || !e.isDirectory()) &&
	            (!this.opts.nodir ||
	                !this.opts.follow ||
	                !e.isSymbolicLink() ||
	                !e.realpathCached()?.isDirectory()) &&
	            !this.#ignored(e)) ?
	            e
	            : undefined;
	    }
	    matchCheckSync(e, ifDir) {
	        if (ifDir && this.opts.nodir)
	            return undefined;
	        let rpc;
	        if (this.opts.realpath) {
	            rpc = e.realpathCached() || e.realpathSync();
	            if (!rpc)
	                return undefined;
	            e = rpc;
	        }
	        const needStat = e.isUnknown() || this.opts.stat;
	        const s = needStat ? e.lstatSync() : e;
	        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
	            const target = s.realpathSync();
	            if (target && (target?.isUnknown() || this.opts.stat)) {
	                target.lstatSync();
	            }
	        }
	        return this.matchCheckTest(s, ifDir);
	    }
	    matchFinish(e, absolute) {
	        if (this.#ignored(e))
	            return;
	        // we know we have an ignore if this is false, but TS doesn't
	        if (!this.includeChildMatches && this.#ignore?.add) {
	            const ign = `${e.relativePosix()}/**`;
	            this.#ignore.add(ign);
	        }
	        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
	        this.seen.add(e);
	        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
	        // ok, we have what we need!
	        if (this.opts.withFileTypes) {
	            this.matchEmit(e);
	        }
	        else if (abs) {
	            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
	            this.matchEmit(abs + mark);
	        }
	        else {
	            const rel = this.opts.posix ? e.relativePosix() : e.relative();
	            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
	                '.' + this.#sep
	                : '';
	            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
	        }
	    }
	    async match(e, absolute, ifDir) {
	        const p = await this.matchCheck(e, ifDir);
	        if (p)
	            this.matchFinish(p, absolute);
	    }
	    matchSync(e, absolute, ifDir) {
	        const p = this.matchCheckSync(e, ifDir);
	        if (p)
	            this.matchFinish(p, absolute);
	    }
	    walkCB(target, patterns, cb) {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            cb();
	        /* c8 ignore stop */
	        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
	    }
	    walkCB2(target, patterns, processor, cb) {
	        if (this.#childrenIgnored(target))
	            return cb();
	        if (this.signal?.aborted)
	            cb();
	        if (this.paused) {
	            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
	            return;
	        }
	        processor.processPatterns(target, patterns);
	        // done processing.  all of the above is sync, can be abstracted out.
	        // subwalks is a map of paths to the entry filters they need
	        // matches is a map of paths to [absolute, ifDir] tuples.
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            tasks++;
	            this.match(m, absolute, ifDir).then(() => next());
	        }
	        for (const t of processor.subwalkTargets()) {
	            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
	                continue;
	            }
	            tasks++;
	            const childrenCached = t.readdirCached();
	            if (t.calledReaddir())
	                this.walkCB3(t, childrenCached, processor, next);
	            else {
	                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
	            }
	        }
	        next();
	    }
	    walkCB3(target, entries, processor, cb) {
	        processor = processor.filterEntries(target, entries);
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            tasks++;
	            this.match(m, absolute, ifDir).then(() => next());
	        }
	        for (const [target, patterns] of processor.subwalks.entries()) {
	            tasks++;
	            this.walkCB2(target, patterns, processor.child(), next);
	        }
	        next();
	    }
	    walkCBSync(target, patterns, cb) {
	        /* c8 ignore start */
	        if (this.signal?.aborted)
	            cb();
	        /* c8 ignore stop */
	        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
	    }
	    walkCB2Sync(target, patterns, processor, cb) {
	        if (this.#childrenIgnored(target))
	            return cb();
	        if (this.signal?.aborted)
	            cb();
	        if (this.paused) {
	            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
	            return;
	        }
	        processor.processPatterns(target, patterns);
	        // done processing.  all of the above is sync, can be abstracted out.
	        // subwalks is a map of paths to the entry filters they need
	        // matches is a map of paths to [absolute, ifDir] tuples.
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            this.matchSync(m, absolute, ifDir);
	        }
	        for (const t of processor.subwalkTargets()) {
	            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
	                continue;
	            }
	            tasks++;
	            const children = t.readdirSync();
	            this.walkCB3Sync(t, children, processor, next);
	        }
	        next();
	    }
	    walkCB3Sync(target, entries, processor, cb) {
	        processor = processor.filterEntries(target, entries);
	        let tasks = 1;
	        const next = () => {
	            if (--tasks === 0)
	                cb();
	        };
	        for (const [m, absolute, ifDir] of processor.matches.entries()) {
	            if (this.#ignored(m))
	                continue;
	            this.matchSync(m, absolute, ifDir);
	        }
	        for (const [target, patterns] of processor.subwalks.entries()) {
	            tasks++;
	            this.walkCB2Sync(target, patterns, processor.child(), next);
	        }
	        next();
	    }
	}
	walker.GlobUtil = GlobUtil;
	class GlobWalker extends GlobUtil {
	    matches = new Set();
	    constructor(patterns, path, opts) {
	        super(patterns, path, opts);
	    }
	    matchEmit(e) {
	        this.matches.add(e);
	    }
	    async walk() {
	        if (this.signal?.aborted)
	            throw this.signal.reason;
	        if (this.path.isUnknown()) {
	            await this.path.lstat();
	        }
	        await new Promise((res, rej) => {
	            this.walkCB(this.path, this.patterns, () => {
	                if (this.signal?.aborted) {
	                    rej(this.signal.reason);
	                }
	                else {
	                    res(this.matches);
	                }
	            });
	        });
	        return this.matches;
	    }
	    walkSync() {
	        if (this.signal?.aborted)
	            throw this.signal.reason;
	        if (this.path.isUnknown()) {
	            this.path.lstatSync();
	        }
	        // nothing for the callback to do, because this never pauses
	        this.walkCBSync(this.path, this.patterns, () => {
	            if (this.signal?.aborted)
	                throw this.signal.reason;
	        });
	        return this.matches;
	    }
	}
	walker.GlobWalker = GlobWalker;
	class GlobStream extends GlobUtil {
	    results;
	    constructor(patterns, path, opts) {
	        super(patterns, path, opts);
	        this.results = new minipass_1.Minipass({
	            signal: this.signal,
	            objectMode: true,
	        });
	        this.results.on('drain', () => this.resume());
	        this.results.on('resume', () => this.resume());
	    }
	    matchEmit(e) {
	        this.results.write(e);
	        if (!this.results.flowing)
	            this.pause();
	    }
	    stream() {
	        const target = this.path;
	        if (target.isUnknown()) {
	            target.lstat().then(() => {
	                this.walkCB(target, this.patterns, () => this.results.end());
	            });
	        }
	        else {
	            this.walkCB(target, this.patterns, () => this.results.end());
	        }
	        return this.results;
	    }
	    streamSync() {
	        if (this.path.isUnknown()) {
	            this.path.lstatSync();
	        }
	        this.walkCBSync(this.path, this.patterns, () => this.results.end());
	        return this.results;
	    }
	}
	walker.GlobStream = GlobStream;
	
	return walker;
}

var hasRequiredGlob;

function requireGlob () {
	if (hasRequiredGlob) return glob;
	hasRequiredGlob = 1;
	Object.defineProperty(glob, "__esModule", { value: true });
	glob.Glob = void 0;
	const minimatch_1 = requireCommonjs$4();
	const node_url_1 = require$$1$6;
	const path_scurry_1 = requireCommonjs$1();
	const pattern_js_1 = requirePattern();
	const walker_js_1 = requireWalker();
	// if no process global, just call it linux.
	// so we default to case-sensitive, / separators
	const defaultPlatform = (typeof process === 'object' &&
	    process &&
	    typeof process.platform === 'string') ?
	    process.platform
	    : 'linux';
	/**
	 * An object that can perform glob pattern traversals.
	 */
	class Glob {
	    absolute;
	    cwd;
	    root;
	    dot;
	    dotRelative;
	    follow;
	    ignore;
	    magicalBraces;
	    mark;
	    matchBase;
	    maxDepth;
	    nobrace;
	    nocase;
	    nodir;
	    noext;
	    noglobstar;
	    pattern;
	    platform;
	    realpath;
	    scurry;
	    stat;
	    signal;
	    windowsPathsNoEscape;
	    withFileTypes;
	    includeChildMatches;
	    /**
	     * The options provided to the constructor.
	     */
	    opts;
	    /**
	     * An array of parsed immutable {@link Pattern} objects.
	     */
	    patterns;
	    /**
	     * All options are stored as properties on the `Glob` object.
	     *
	     * See {@link GlobOptions} for full options descriptions.
	     *
	     * Note that a previous `Glob` object can be passed as the
	     * `GlobOptions` to another `Glob` instantiation to re-use settings
	     * and caches with a new pattern.
	     *
	     * Traversal functions can be called multiple times to run the walk
	     * again.
	     */
	    constructor(pattern, opts) {
	        /* c8 ignore start */
	        if (!opts)
	            throw new TypeError('glob options required');
	        /* c8 ignore stop */
	        this.withFileTypes = !!opts.withFileTypes;
	        this.signal = opts.signal;
	        this.follow = !!opts.follow;
	        this.dot = !!opts.dot;
	        this.dotRelative = !!opts.dotRelative;
	        this.nodir = !!opts.nodir;
	        this.mark = !!opts.mark;
	        if (!opts.cwd) {
	            this.cwd = '';
	        }
	        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
	            opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
	        }
	        this.cwd = opts.cwd || '';
	        this.root = opts.root;
	        this.magicalBraces = !!opts.magicalBraces;
	        this.nobrace = !!opts.nobrace;
	        this.noext = !!opts.noext;
	        this.realpath = !!opts.realpath;
	        this.absolute = opts.absolute;
	        this.includeChildMatches = opts.includeChildMatches !== false;
	        this.noglobstar = !!opts.noglobstar;
	        this.matchBase = !!opts.matchBase;
	        this.maxDepth =
	            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
	        this.stat = !!opts.stat;
	        this.ignore = opts.ignore;
	        if (this.withFileTypes && this.absolute !== undefined) {
	            throw new Error('cannot set absolute and withFileTypes:true');
	        }
	        if (typeof pattern === 'string') {
	            pattern = [pattern];
	        }
	        this.windowsPathsNoEscape =
	            !!opts.windowsPathsNoEscape ||
	                opts.allowWindowsEscape ===
	                    false;
	        if (this.windowsPathsNoEscape) {
	            pattern = pattern.map(p => p.replace(/\\/g, '/'));
	        }
	        if (this.matchBase) {
	            if (opts.noglobstar) {
	                throw new TypeError('base matching requires globstar');
	            }
	            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
	        }
	        this.pattern = pattern;
	        this.platform = opts.platform || defaultPlatform;
	        this.opts = { ...opts, platform: this.platform };
	        if (opts.scurry) {
	            this.scurry = opts.scurry;
	            if (opts.nocase !== undefined &&
	                opts.nocase !== opts.scurry.nocase) {
	                throw new Error('nocase option contradicts provided scurry option');
	            }
	        }
	        else {
	            const Scurry = opts.platform === 'win32' ? path_scurry_1.PathScurryWin32
	                : opts.platform === 'darwin' ? path_scurry_1.PathScurryDarwin
	                    : opts.platform ? path_scurry_1.PathScurryPosix
	                        : path_scurry_1.PathScurry;
	            this.scurry = new Scurry(this.cwd, {
	                nocase: opts.nocase,
	                fs: opts.fs,
	            });
	        }
	        this.nocase = this.scurry.nocase;
	        // If you do nocase:true on a case-sensitive file system, then
	        // we need to use regexps instead of strings for non-magic
	        // path portions, because statting `aBc` won't return results
	        // for the file `AbC` for example.
	        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
	        const mmo = {
	            // default nocase based on platform
	            ...opts,
	            dot: this.dot,
	            matchBase: this.matchBase,
	            nobrace: this.nobrace,
	            nocase: this.nocase,
	            nocaseMagicOnly,
	            nocomment: true,
	            noext: this.noext,
	            nonegate: true,
	            optimizationLevel: 2,
	            platform: this.platform,
	            windowsPathsNoEscape: this.windowsPathsNoEscape,
	            debug: !!this.opts.debug,
	        };
	        const mms = this.pattern.map(p => new minimatch_1.Minimatch(p, mmo));
	        const [matchSet, globParts] = mms.reduce((set, m) => {
	            set[0].push(...m.set);
	            set[1].push(...m.globParts);
	            return set;
	        }, [[], []]);
	        this.patterns = matchSet.map((set, i) => {
	            const g = globParts[i];
	            /* c8 ignore start */
	            if (!g)
	                throw new Error('invalid pattern object');
	            /* c8 ignore stop */
	            return new pattern_js_1.Pattern(set, g, 0, this.platform);
	        });
	    }
	    async walk() {
	        // Walkers always return array of Path objects, so we just have to
	        // coerce them into the right shape.  It will have already called
	        // realpath() if the option was set to do so, so we know that's cached.
	        // start out knowing the cwd, at least
	        return [
	            ...(await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
	                ...this.opts,
	                maxDepth: this.maxDepth !== Infinity ?
	                    this.maxDepth + this.scurry.cwd.depth()
	                    : Infinity,
	                platform: this.platform,
	                nocase: this.nocase,
	                includeChildMatches: this.includeChildMatches,
	            }).walk()),
	        ];
	    }
	    walkSync() {
	        return [
	            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
	                ...this.opts,
	                maxDepth: this.maxDepth !== Infinity ?
	                    this.maxDepth + this.scurry.cwd.depth()
	                    : Infinity,
	                platform: this.platform,
	                nocase: this.nocase,
	                includeChildMatches: this.includeChildMatches,
	            }).walkSync(),
	        ];
	    }
	    stream() {
	        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
	            ...this.opts,
	            maxDepth: this.maxDepth !== Infinity ?
	                this.maxDepth + this.scurry.cwd.depth()
	                : Infinity,
	            platform: this.platform,
	            nocase: this.nocase,
	            includeChildMatches: this.includeChildMatches,
	        }).stream();
	    }
	    streamSync() {
	        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
	            ...this.opts,
	            maxDepth: this.maxDepth !== Infinity ?
	                this.maxDepth + this.scurry.cwd.depth()
	                : Infinity,
	            platform: this.platform,
	            nocase: this.nocase,
	            includeChildMatches: this.includeChildMatches,
	        }).streamSync();
	    }
	    /**
	     * Default sync iteration function. Returns a Generator that
	     * iterates over the results.
	     */
	    iterateSync() {
	        return this.streamSync()[Symbol.iterator]();
	    }
	    [Symbol.iterator]() {
	        return this.iterateSync();
	    }
	    /**
	     * Default async iteration function. Returns an AsyncGenerator that
	     * iterates over the results.
	     */
	    iterate() {
	        return this.stream()[Symbol.asyncIterator]();
	    }
	    [Symbol.asyncIterator]() {
	        return this.iterate();
	    }
	}
	glob.Glob = Glob;
	
	return glob;
}

var hasMagic = {};

var hasRequiredHasMagic;

function requireHasMagic () {
	if (hasRequiredHasMagic) return hasMagic;
	hasRequiredHasMagic = 1;
	Object.defineProperty(hasMagic, "__esModule", { value: true });
	hasMagic.hasMagic = void 0;
	const minimatch_1 = requireCommonjs$4();
	/**
	 * Return true if the patterns provided contain any magic glob characters,
	 * given the options provided.
	 *
	 * Brace expansion is not considered "magic" unless the `magicalBraces` option
	 * is set, as brace expansion just turns one string into an array of strings.
	 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
	 * `'xby'` both do not contain any magic glob characters, and it's treated the
	 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
	 * is in the options, brace expansion _is_ treated as a pattern having magic.
	 */
	const hasMagic$1 = (pattern, options = {}) => {
	    if (!Array.isArray(pattern)) {
	        pattern = [pattern];
	    }
	    for (const p of pattern) {
	        if (new minimatch_1.Minimatch(p, options).hasMagic())
	            return true;
	    }
	    return false;
	};
	hasMagic.hasMagic = hasMagic$1;
	
	return hasMagic;
}

var hasRequiredCommonjs;

function requireCommonjs () {
	if (hasRequiredCommonjs) return commonjs$6;
	hasRequiredCommonjs = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;
		exports.globStreamSync = globStreamSync;
		exports.globStream = globStream;
		exports.globSync = globSync;
		exports.globIterateSync = globIterateSync;
		exports.globIterate = globIterate;
		const minimatch_1 = requireCommonjs$4();
		const glob_js_1 = requireGlob();
		const has_magic_js_1 = requireHasMagic();
		var minimatch_2 = requireCommonjs$4();
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return minimatch_2.escape; } });
		Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return minimatch_2.unescape; } });
		var glob_js_2 = requireGlob();
		Object.defineProperty(exports, "Glob", { enumerable: true, get: function () { return glob_js_2.Glob; } });
		var has_magic_js_2 = requireHasMagic();
		Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function () { return has_magic_js_2.hasMagic; } });
		var ignore_js_1 = requireIgnore();
		Object.defineProperty(exports, "Ignore", { enumerable: true, get: function () { return ignore_js_1.Ignore; } });
		function globStreamSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).streamSync();
		}
		function globStream(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).stream();
		}
		function globSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).walkSync();
		}
		async function glob_(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).walk();
		}
		function globIterateSync(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).iterateSync();
		}
		function globIterate(pattern, options = {}) {
		    return new glob_js_1.Glob(pattern, options).iterate();
		}
		// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
		exports.streamSync = globStreamSync;
		exports.stream = Object.assign(globStream, { sync: globStreamSync });
		exports.iterateSync = globIterateSync;
		exports.iterate = Object.assign(globIterate, {
		    sync: globIterateSync,
		});
		exports.sync = Object.assign(globSync, {
		    stream: globStreamSync,
		    iterate: globIterateSync,
		});
		exports.glob = Object.assign(glob_, {
		    glob: glob_,
		    globSync,
		    sync: exports.sync,
		    globStream,
		    stream: exports.stream,
		    globStreamSync,
		    streamSync: exports.streamSync,
		    globIterate,
		    iterate: exports.iterate,
		    globIterateSync,
		    iterateSync: exports.iterateSync,
		    Glob: glob_js_1.Glob,
		    hasMagic: has_magic_js_1.hasMagic,
		    escape: minimatch_1.escape,
		    unescape: minimatch_1.unescape,
		});
		exports.glob.glob = exports.glob;
		
	} (commonjs$6));
	return commonjs$6;
}

var send$1 = {exports: {}};

var isUtf8MimeType = {};

var hasRequiredIsUtf8MimeType;

function requireIsUtf8MimeType () {
	if (hasRequiredIsUtf8MimeType) return isUtf8MimeType;
	hasRequiredIsUtf8MimeType = 1;

	function isUtf8MimeType$1 (value) {
	  const len = value.length;
	  return (
	    (len > 21 && value.indexOf('application/javascript') === 0) ||
	    (len > 14 && value.indexOf('application/json') === 0) ||
	    (len > 5 && value.indexOf('text/') === 0)
	  )
	}

	isUtf8MimeType.isUtf8MimeType = isUtf8MimeType$1;
	return isUtf8MimeType;
}

var Mime_1;
var hasRequiredMime$1;

function requireMime$1 () {
	if (hasRequiredMime$1) return Mime_1;
	hasRequiredMime$1 = 1;

	/**
	 * @param typeMap [Object] Map of MIME type -> Array[extensions]
	 * @param ...
	 */
	function Mime() {
	  this._types = Object.create(null);
	  this._extensions = Object.create(null);

	  for (let i = 0; i < arguments.length; i++) {
	    this.define(arguments[i]);
	  }

	  this.define = this.define.bind(this);
	  this.getType = this.getType.bind(this);
	  this.getExtension = this.getExtension.bind(this);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * If a type declares an extension that has already been defined, an error will
	 * be thrown.  To suppress this error and force the extension to be associated
	 * with the new type, pass `force`=true.  Alternatively, you may prefix the
	 * extension with "*" to map the type to extension, without mapping the
	 * extension to the type.
	 *
	 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
	 *
	 *
	 * @param map (Object) type definitions
	 * @param force (Boolean) if true, force overriding of existing definitions
	 */
	Mime.prototype.define = function(typeMap, force) {
	  for (let type in typeMap) {
	    let extensions = typeMap[type].map(function(t) {
	      return t.toLowerCase();
	    });
	    type = type.toLowerCase();

	    for (let i = 0; i < extensions.length; i++) {
	      const ext = extensions[i];

	      // '*' prefix = not the preferred type for this extension.  So fixup the
	      // extension, and skip it.
	      if (ext[0] === '*') {
	        continue;
	      }

	      if (!force && (ext in this._types)) {
	        throw new Error(
	          'Attempt to change mapping for "' + ext +
	          '" extension from "' + this._types[ext] + '" to "' + type +
	          '". Pass `force=true` to allow this, otherwise remove "' + ext +
	          '" from the list of extensions for "' + type + '".'
	        );
	      }

	      this._types[ext] = type;
	    }

	    // Use first extension as default
	    if (force || !this._extensions[type]) {
	      const ext = extensions[0];
	      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
	    }
	  }
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.getType = function(path) {
	  path = String(path);
	  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
	  let ext = last.replace(/^.*\./, '').toLowerCase();

	  let hasPath = last.length < path.length;
	  let hasDot = ext.length < last.length - 1;

	  return (hasDot || !hasPath) && this._types[ext] || null;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.getExtension = function(type) {
	  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
	  return type && this._extensions[type.toLowerCase()] || null;
	};

	Mime_1 = Mime;
	return Mime_1;
}

var standard;
var hasRequiredStandard;

function requireStandard () {
	if (hasRequiredStandard) return standard;
	hasRequiredStandard = 1;
	standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};
	return standard;
}

var other;
var hasRequiredOther;

function requireOther () {
	if (hasRequiredOther) return other;
	hasRequiredOther = 1;
	other = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mapbox-vector-tile":["mvt"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-iwork-keynote-sffkey":["*key"],"application/x-iwork-numbers-sffnumbers":["*numbers"],"application/x-iwork-pages-sffpages":["*pages"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.sap.vds":["vds"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};
	return other;
}

var mime;
var hasRequiredMime;

function requireMime () {
	if (hasRequiredMime) return mime;
	hasRequiredMime = 1;

	let Mime = requireMime$1();
	mime = new Mime(requireStandard(), requireOther());
	return mime;
}

var send = {};

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

var escapeHtml_1;
var hasRequiredEscapeHtml;

function requireEscapeHtml () {
	if (hasRequiredEscapeHtml) return escapeHtml_1;
	hasRequiredEscapeHtml = 1;

	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Module exports.
	 * @public
	 */

	escapeHtml_1 = escapeHtml;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}
	return escapeHtml_1;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/,
		SEC = 1e3,
		MIN = SEC * 60,
		HOUR = MIN * 60,
		DAY = HOUR * 24,
		YEAR = DAY * 365.25;

	function parse(val) {
		var num, arr = val.toLowerCase().match(RGX);
		if (arr != null && (num = parseFloat(arr[1]))) {
			if (arr[3] != null) return num * SEC;
			if (arr[4] != null) return num * MIN;
			if (arr[5] != null) return num * HOUR;
			if (arr[6] != null) return num * DAY;
			if (arr[7] != null) return num * DAY * 7;
			if (arr[8] != null) return num * YEAR;
			return num;
		}
	}

	function fmt(val, pfx, str, long) {
		var num = (val | 0) === val ? val : ~~(val + 0.5);
		return pfx + num + (long ? (' ' + str + (num != 1 ? 's' : '')) : str[0]);
	}

	function format(num, long) {
		var pfx = num < 0  ? '-' : '', abs = num < 0 ? -num : num;
		if (abs < SEC) return num + (long ? ' ms' : 'ms');
		if (abs < MIN) return fmt(abs / SEC, pfx, 'second', long);
		if (abs < HOUR) return fmt(abs / MIN, pfx, 'minute', long);
		if (abs < DAY) return fmt(abs / HOUR, pfx, 'hour', long);
		if (abs < YEAR) return fmt(abs / DAY, pfx, 'day', long);
		return fmt(abs / YEAR, pfx, 'year', long);
	}

	dist.format = format;
	dist.parse = parse;
	return dist;
}

var collapseLeadingSlashes = {};

var hasRequiredCollapseLeadingSlashes;

function requireCollapseLeadingSlashes () {
	if (hasRequiredCollapseLeadingSlashes) return collapseLeadingSlashes;
	hasRequiredCollapseLeadingSlashes = 1;

	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */

	function collapseLeadingSlashes$1 (str) {
	  if (
	    str[0] !== '/' ||
	    str[1] !== '/'
	  ) {
	    return str
	  }
	  for (let i = 2, il = str.length; i < il; ++i) {
	    if (str[i] !== '/') {
	      return str.slice(i - 1)
	    }
	  }
	  /* c8 ignore next */
	}

	collapseLeadingSlashes.collapseLeadingSlashes = collapseLeadingSlashes$1;
	return collapseLeadingSlashes;
}

var containsDotFile = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContainsDotFile;

function requireContainsDotFile () {
	if (hasRequiredContainsDotFile) return containsDotFile;
	hasRequiredContainsDotFile = 1;
	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */
	function containsDotFile$1 (parts) {
	  for (let i = 0, il = parts.length; i < il; ++i) {
	    if (parts[i].length !== 1 && parts[i][0] === '.') {
	      return true
	    }
	  }

	  return false
	}

	containsDotFile.containsDotFile = containsDotFile$1;
	return containsDotFile;
}

var contentRange = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentRange;

function requireContentRange () {
	if (hasRequiredContentRange) return contentRange;
	hasRequiredContentRange = 1;
	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */
	function contentRange$1 (type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
	}
	contentRange.contentRange = contentRange$1;
	return contentRange;
}

var createHtmlDocument = {};

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredCreateHtmlDocument;

function requireCreateHtmlDocument () {
	if (hasRequiredCreateHtmlDocument) return createHtmlDocument;
	hasRequiredCreateHtmlDocument = 1;
	/**
	 * Create a minimal HTML document.
	 *
	 * @param {string} title
	 * @param {string} body
	 * @private
	 */
	function createHtmlDocument$1 (title, body) {
	  const html = '<!DOCTYPE html>\n' +
	    '<html lang="en">\n' +
	    '<head>\n' +
	    '<meta charset="utf-8">\n' +
	    '<title>' + title + '</title>\n' +
	    '</head>\n' +
	    '<body>\n' +
	    '<pre>' + body + '</pre>\n' +
	    '</body>\n' +
	    '</html>\n';

	  return [html, Buffer.byteLength(html)]
	}
	createHtmlDocument.createHtmlDocument = createHtmlDocument$1;
	return createHtmlDocument;
}

var normalizeList = {};

var hasRequiredNormalizeList;

function requireNormalizeList () {
	if (hasRequiredNormalizeList) return normalizeList;
	hasRequiredNormalizeList = 1;

	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */

	function normalizeList$1 (val, name) {
	  if (typeof val === 'string') {
	    return [val]
	  } else if (val === false) {
	    return []
	  } else if (Array.isArray(val)) {
	    for (let i = 0, il = val.length; i < il; ++i) {
	      if (typeof val[i] !== 'string') {
	        throw new TypeError(name + ' must be array of strings or false')
	      }
	    }
	    return val
	  } else {
	    throw new TypeError(name + ' must be array of strings or false')
	  }
	}

	normalizeList.normalizeList = normalizeList$1;
	return normalizeList;
}

var parseBytesRange = {};

var hasRequiredParseBytesRange;

function requireParseBytesRange () {
	if (hasRequiredParseBytesRange) return parseBytesRange;
	hasRequiredParseBytesRange = 1;

	/*!
	 * Based on range-parser
	 *
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @return {Array}
	 * @public
	 */

	function parseBytesRange$1 (size, str) {
	  // split the range string
	  const values = str.slice(str.indexOf('=') + 1);
	  const ranges = [];

	  const len = values.length;
	  let i = 0;
	  let il = 0;
	  let j = 0;
	  let start;
	  let end;
	  let commaIdx = values.indexOf(',');
	  let dashIdx = values.indexOf('-');
	  let prevIdx = -1;

	  // parse all ranges
	  while (true) {
	    commaIdx === -1 && (commaIdx = len);
	    start = parseInt(values.slice(prevIdx + 1, dashIdx), 10);
	    end = parseInt(values.slice(dashIdx + 1, commaIdx), 10);

	    // -nnn
	    // eslint-disable-next-line no-self-compare
	    if (start !== start) { // fast path of isNaN(number)
	      start = size - end;
	      end = size - 1;
	      // nnn-
	    // eslint-disable-next-line no-self-compare
	    } else if (end !== end) { // fast path of isNaN(number)
	      end = size - 1;
	      // limit last-byte-pos to current length
	    } else if (end > size - 1) {
	      end = size - 1;
	    }

	    // add range only on valid ranges
	    if (
	      // eslint-disable-next-line no-self-compare
	      start === start && // fast path of isNaN(number)
	      // eslint-disable-next-line no-self-compare
	      end === end && // fast path of isNaN(number)
	      start > -1 &&
	      start <= end
	    ) {
	      // add range
	      ranges.push({
	        start,
	        end,
	        index: j++
	      });
	    }

	    if (commaIdx === len) {
	      break
	    }
	    prevIdx = commaIdx++;
	    dashIdx = values.indexOf('-', commaIdx);
	    commaIdx = values.indexOf(',', commaIdx);
	  }

	  // unsatisfiable
	  if (
	    j < 2
	  ) {
	    return ranges
	  }

	  ranges.sort(sortByRangeStart);

	  il = j;
	  j = 0;
	  i = 1;
	  while (i < il) {
	    const range = ranges[i++];
	    const current = ranges[j];

	    if (range.start > current.end + 1) {
	      // next range
	      ranges[++j] = range;
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end;
	      current.index > range.index && (current.index = range.index);
	    }
	  }

	  // trim ordered array
	  ranges.length = j + 1;

	  // generate combined range
	  ranges.sort(sortByRangeIndex);

	  return ranges
	}

	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */

	function sortByRangeIndex (a, b) {
	  return a.index - b.index
	}

	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */

	function sortByRangeStart (a, b) {
	  return a.start - b.start
	}

	parseBytesRange.parseBytesRange = parseBytesRange$1;
	return parseBytesRange;
}

var parseTokenList = {};

var hasRequiredParseTokenList;

function requireParseTokenList () {
	if (hasRequiredParseTokenList) return parseTokenList;
	hasRequiredParseTokenList = 1;

	/**
	 * Parse a HTTP token list.
	 *
	 * @param {string} str
	 * @private
	 */

	const slice = String.prototype.slice;

	function parseTokenList$1 (str, cb) {
	  let end = 0;
	  let start = 0;
	  let result;

	  // gather tokens
	  for (let i = 0, len = str.length; i < len; i++) {
	    switch (str.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        if (start !== end) {
	          result = cb(slice.call(str, start, end));
	          if (result !== undefined) {
	            return result
	          }
	        }
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  if (start !== end) {
	    return cb(slice.call(str, start, end))
	  }
	}

	parseTokenList.parseTokenList = parseTokenList$1;
	return parseTokenList;
}

var createHttpError = {};

var httpErrors = {exports: {}};

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

var depd_1;
var hasRequiredDepd;

function requireDepd () {
	if (hasRequiredDepd) return depd_1;
	hasRequiredDepd = 1;
	/**
	 * Module dependencies.
	 */

	var relative = path.relative;

	/**
	 * Module exports.
	 */

	depd_1 = depd;

	/**
	 * Get the path to base files on.
	 */

	var basePath = process.cwd();

	/**
	 * Determine if namespace is contained in the string.
	 */

	function containsNamespace (str, namespace) {
	  var vals = str.split(/[ ,]+/);
	  var ns = String(namespace).toLowerCase();

	  for (var i = 0; i < vals.length; i++) {
	    var val = vals[i];

	    // namespace contained
	    if (val && (val === '*' || val.toLowerCase() === ns)) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Convert a data descriptor to accessor descriptor.
	 */

	function convertDataDescriptorToAccessor (obj, prop, message) {
	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	  var value = descriptor.value;

	  descriptor.get = function getter () { return value };

	  if (descriptor.writable) {
	    descriptor.set = function setter (val) { return (value = val) };
	  }

	  delete descriptor.value;
	  delete descriptor.writable;

	  Object.defineProperty(obj, prop, descriptor);

	  return descriptor
	}

	/**
	 * Create arguments string to keep arity.
	 */

	function createArgumentsString (arity) {
	  var str = '';

	  for (var i = 0; i < arity; i++) {
	    str += ', arg' + i;
	  }

	  return str.substr(2)
	}

	/**
	 * Create stack string from stack.
	 */

	function createStackString (stack) {
	  var str = this.name + ': ' + this.namespace;

	  if (this.message) {
	    str += ' deprecated ' + this.message;
	  }

	  for (var i = 0; i < stack.length; i++) {
	    str += '\n    at ' + stack[i].toString();
	  }

	  return str
	}

	/**
	 * Create deprecate for namespace in caller.
	 */

	function depd (namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required')
	  }

	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);
	  var file = site[0];

	  function deprecate (message) {
	    // call to self as log
	    log.call(deprecate, message);
	  }

	  deprecate._file = file;
	  deprecate._ignored = isignored(namespace);
	  deprecate._namespace = namespace;
	  deprecate._traced = istraced(namespace);
	  deprecate._warned = Object.create(null);

	  deprecate.function = wrapfunction;
	  deprecate.property = wrapproperty;

	  return deprecate
	}

	/**
	 * Determine if event emitter has listeners of a given type.
	 *
	 * The way to do this check is done three different ways in Node.js >= 0.8
	 * so this consolidates them into a minimal set using instance methods.
	 *
	 * @param {EventEmitter} emitter
	 * @param {string} type
	 * @returns {boolean}
	 * @private
	 */

	function eehaslisteners (emitter, type) {
	  var count = typeof emitter.listenerCount !== 'function'
	    ? emitter.listeners(type).length
	    : emitter.listenerCount(type);

	  return count > 0
	}

	/**
	 * Determine if namespace is ignored.
	 */

	function isignored (namespace) {
	  if (process.noDeprecation) {
	    // --no-deprecation support
	    return true
	  }

	  var str = process.env.NO_DEPRECATION || '';

	  // namespace ignored
	  return containsNamespace(str, namespace)
	}

	/**
	 * Determine if namespace is traced.
	 */

	function istraced (namespace) {
	  if (process.traceDeprecation) {
	    // --trace-deprecation support
	    return true
	  }

	  var str = process.env.TRACE_DEPRECATION || '';

	  // namespace traced
	  return containsNamespace(str, namespace)
	}

	/**
	 * Display deprecation message.
	 */

	function log (message, site) {
	  var haslisteners = eehaslisteners(process, 'deprecation');

	  // abort early if no destination
	  if (!haslisteners && this._ignored) {
	    return
	  }

	  var caller;
	  var callFile;
	  var callSite;
	  var depSite;
	  var i = 0;
	  var seen = false;
	  var stack = getStack();
	  var file = this._file;

	  if (site) {
	    // provided site
	    depSite = site;
	    callSite = callSiteLocation(stack[1]);
	    callSite.name = depSite.name;
	    file = callSite[0];
	  } else {
	    // get call site
	    i = 2;
	    depSite = callSiteLocation(stack[i]);
	    callSite = depSite;
	  }

	  // get caller of deprecated thing in relation to file
	  for (; i < stack.length; i++) {
	    caller = callSiteLocation(stack[i]);
	    callFile = caller[0];

	    if (callFile === file) {
	      seen = true;
	    } else if (callFile === this._file) {
	      file = this._file;
	    } else if (seen) {
	      break
	    }
	  }

	  var key = caller
	    ? depSite.join(':') + '__' + caller.join(':')
	    : undefined;

	  if (key !== undefined && key in this._warned) {
	    // already warned
	    return
	  }

	  this._warned[key] = true;

	  // generate automatic message from call site
	  var msg = message;
	  if (!msg) {
	    msg = callSite === depSite || !callSite.name
	      ? defaultMessage(depSite)
	      : defaultMessage(callSite);
	  }

	  // emit deprecation if listeners exist
	  if (haslisteners) {
	    var err = DeprecationError(this._namespace, msg, stack.slice(i));
	    process.emit('deprecation', err);
	    return
	  }

	  // format and write message
	  var format = process.stderr.isTTY
	    ? formatColor
	    : formatPlain;
	  var output = format.call(this, msg, caller, stack.slice(i));
	  process.stderr.write(output + '\n', 'utf8');
	}

	/**
	 * Get call site location as array.
	 */

	function callSiteLocation (callSite) {
	  var file = callSite.getFileName() || '<anonymous>';
	  var line = callSite.getLineNumber();
	  var colm = callSite.getColumnNumber();

	  if (callSite.isEval()) {
	    file = callSite.getEvalOrigin() + ', ' + file;
	  }

	  var site = [file, line, colm];

	  site.callSite = callSite;
	  site.name = callSite.getFunctionName();

	  return site
	}

	/**
	 * Generate a default message from the site.
	 */

	function defaultMessage (site) {
	  var callSite = site.callSite;
	  var funcName = site.name;

	  // make useful anonymous name
	  if (!funcName) {
	    funcName = '<anonymous@' + formatLocation(site) + '>';
	  }

	  var context = callSite.getThis();
	  var typeName = context && callSite.getTypeName();

	  // ignore useless type name
	  if (typeName === 'Object') {
	    typeName = undefined;
	  }

	  // make useful type name
	  if (typeName === 'Function') {
	    typeName = context.name || typeName;
	  }

	  return typeName && callSite.getMethodName()
	    ? typeName + '.' + funcName
	    : funcName
	}

	/**
	 * Format deprecation message without color.
	 */

	function formatPlain (msg, caller, stack) {
	  var timestamp = new Date().toUTCString();

	  var formatted = timestamp +
	    ' ' + this._namespace +
	    ' deprecated ' + msg;

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    at ' + stack[i].toString();
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' at ' + formatLocation(caller);
	  }

	  return formatted
	}

	/**
	 * Format deprecation message with color.
	 */

	function formatColor (msg, caller, stack) {
	  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
	    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
	    ' \x1b[0m' + msg + '\x1b[39m'; // reset

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
	  }

	  return formatted
	}

	/**
	 * Format call site location.
	 */

	function formatLocation (callSite) {
	  return relative(basePath, callSite[0]) +
	    ':' + callSite[1] +
	    ':' + callSite[2]
	}

	/**
	 * Get the stack as array of call sites.
	 */

	function getStack () {
	  var limit = Error.stackTraceLimit;
	  var obj = {};
	  var prep = Error.prepareStackTrace;

	  Error.prepareStackTrace = prepareObjectStackTrace;
	  Error.stackTraceLimit = Math.max(10, limit);

	  // capture the stack
	  Error.captureStackTrace(obj);

	  // slice this function off the top
	  var stack = obj.stack.slice(1);

	  Error.prepareStackTrace = prep;
	  Error.stackTraceLimit = limit;

	  return stack
	}

	/**
	 * Capture call site stack from v8.
	 */

	function prepareObjectStackTrace (obj, stack) {
	  return stack
	}

	/**
	 * Return a wrapped function in a deprecation message.
	 */

	function wrapfunction (fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function')
	  }

	  var args = createArgumentsString(fn.length);
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  site.name = fn.name;

	  // eslint-disable-next-line no-new-func
	  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
	    '"use strict"\n' +
	    'return function (' + args + ') {' +
	    'log.call(deprecate, message, site)\n' +
	    'return fn.apply(this, arguments)\n' +
	    '}')(fn, log, this, message, site);

	  return deprecatedfn
	}

	/**
	 * Wrap property in a deprecation message.
	 */

	function wrapproperty (obj, prop, message) {
	  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
	    throw new TypeError('argument obj must be object')
	  }

	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

	  if (!descriptor) {
	    throw new TypeError('must call property on owner object')
	  }

	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable')
	  }

	  var deprecate = this;
	  var stack = getStack();
	  var site = callSiteLocation(stack[1]);

	  // set site name
	  site.name = prop;

	  // convert data descriptor
	  if ('value' in descriptor) {
	    descriptor = convertDataDescriptorToAccessor(obj, prop);
	  }

	  var get = descriptor.get;
	  var set = descriptor.set;

	  // wrap getter
	  if (typeof get === 'function') {
	    descriptor.get = function getter () {
	      log.call(deprecate, message, site);
	      return get.apply(this, arguments)
	    };
	  }

	  // wrap setter
	  if (typeof set === 'function') {
	    descriptor.set = function setter () {
	      log.call(deprecate, message, site);
	      return set.apply(this, arguments)
	    };
	  }

	  Object.defineProperty(obj, prop, descriptor);
	}

	/**
	 * Create DeprecationError for deprecation
	 */

	function DeprecationError (namespace, message, stack) {
	  var error = new Error();
	  var stackString;

	  Object.defineProperty(error, 'constructor', {
	    value: DeprecationError
	  });

	  Object.defineProperty(error, 'message', {
	    configurable: true,
	    enumerable: false,
	    value: message,
	    writable: true
	  });

	  Object.defineProperty(error, 'name', {
	    enumerable: false,
	    configurable: true,
	    value: 'DeprecationError',
	    writable: true
	  });

	  Object.defineProperty(error, 'namespace', {
	    configurable: true,
	    enumerable: false,
	    value: namespace,
	    writable: true
	  });

	  Object.defineProperty(error, 'stack', {
	    configurable: true,
	    enumerable: false,
	    get: function () {
	      if (stackString !== undefined) {
	        return stackString
	      }

	      // prepare stack trace
	      return (stackString = createStackString.call(this, stack))
	    },
	    set: function setter (val) {
	      stackString = val;
	    }
	  });

	  return error
	}
	return depd_1;
}

var setprototypeof;
var hasRequiredSetprototypeof;

function requireSetprototypeof () {
	if (hasRequiredSetprototypeof) return setprototypeof;
	hasRequiredSetprototypeof = 1;
	/* eslint no-proto: 0 */
	setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf (obj, proto) {
	  obj.__proto__ = proto;
	  return obj
	}

	function mixinProperties (obj, proto) {
	  for (var prop in proto) {
	    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
	      obj[prop] = proto[prop];
	    }
	  }
	  return obj
	}
	return setprototypeof;
}

var require$$0 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var statuses;
var hasRequiredStatuses;

function requireStatuses () {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;

	/**
	 * Module dependencies.
	 * @private
	 */

	var codes = require$$0;

	/**
	 * Module exports.
	 * @public
	 */

	statuses = status;

	// status code to message map
	status.message = codes;

	// status message (lower-case) to code map
	status.code = createMessageToStatusCodeMap(codes);

	// array of status codes
	status.codes = createStatusCodeList(codes);

	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	};

	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	};

	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	};

	/**
	 * Create a map of message to status code.
	 * @private
	 */

	function createMessageToStatusCodeMap (codes) {
	  var map = {};

	  Object.keys(codes).forEach(function forEachCode (code) {
	    var message = codes[code];
	    var status = Number(code);

	    // populate map
	    map[message.toLowerCase()] = status;
	  });

	  return map
	}

	/**
	 * Create a list of all status codes.
	 * @private
	 */

	function createStatusCodeList (codes) {
	  return Object.keys(codes).map(function mapCode (code) {
	    return Number(code)
	  })
	}

	/**
	 * Get the status code for given message.
	 * @private
	 */

	function getStatusCode (message) {
	  var msg = message.toLowerCase();

	  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
	    throw new Error('invalid status message: "' + message + '"')
	  }

	  return status.code[msg]
	}

	/**
	 * Get the status message for given code.
	 * @private
	 */

	function getStatusMessage (code) {
	  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
	    throw new Error('invalid status code: ' + code)
	  }

	  return status.message[code]
	}

	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {number}
	 * @public
	 */

	function status (code) {
	  if (typeof code === 'number') {
	    return getStatusMessage(code)
	  }

	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string')
	  }

	  // '403'
	  var n = parseInt(code, 10);
	  if (!isNaN(n)) {
	    return getStatusMessage(n)
	  }

	  return getStatusCode(code)
	}
	return statuses;
}

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var toidentifier;
var hasRequiredToidentifier;

function requireToidentifier () {
	if (hasRequiredToidentifier) return toidentifier;
	hasRequiredToidentifier = 1;

	/**
	 * Module exports.
	 * @public
	 */

	toidentifier = toIdentifier;

	/**
	 * Trasform the given string into a JavaScript identifier
	 *
	 * @param {string} str
	 * @returns {string}
	 * @public
	 */

	function toIdentifier (str) {
	  return str
	    .split(' ')
	    .map(function (token) {
	      return token.slice(0, 1).toUpperCase() + token.slice(1)
	    })
	    .join('')
	    .replace(/[^ _0-9a-z]/gi, '')
	}
	return toidentifier;
}

/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredHttpErrors;

function requireHttpErrors () {
	if (hasRequiredHttpErrors) return httpErrors.exports;
	hasRequiredHttpErrors = 1;
	(function (module) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var deprecate = requireDepd()('http-errors');
		var setPrototypeOf = requireSetprototypeof();
		var statuses = requireStatuses();
		var inherits = requireInherits();
		var toIdentifier = requireToidentifier();

		/**
		 * Module exports.
		 * @public
		 */

		module.exports = createError;
		module.exports.HttpError = createHttpErrorConstructor();
		module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);

		// Populate exports for all constructors
		populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

		/**
		 * Get the code class of a status code.
		 * @private
		 */

		function codeClass (status) {
		  return Number(String(status).charAt(0) + '00')
		}

		/**
		 * Create a new HTTP Error.
		 *
		 * @returns {Error}
		 * @public
		 */

		function createError () {
		  // so much arity going on ~_~
		  var err;
		  var msg;
		  var status = 500;
		  var props = {};
		  for (var i = 0; i < arguments.length; i++) {
		    var arg = arguments[i];
		    var type = typeof arg;
		    if (type === 'object' && arg instanceof Error) {
		      err = arg;
		      status = err.status || err.statusCode || status;
		    } else if (type === 'number' && i === 0) {
		      status = arg;
		    } else if (type === 'string') {
		      msg = arg;
		    } else if (type === 'object') {
		      props = arg;
		    } else {
		      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
		    }
		  }

		  if (typeof status === 'number' && (status < 400 || status >= 600)) {
		    deprecate('non-error status code; use only 4xx or 5xx status codes');
		  }

		  if (typeof status !== 'number' ||
		    (!statuses.message[status] && (status < 400 || status >= 600))) {
		    status = 500;
		  }

		  // constructor
		  var HttpError = createError[status] || createError[codeClass(status)];

		  if (!err) {
		    // create error
		    err = HttpError
		      ? new HttpError(msg)
		      : new Error(msg || statuses.message[status]);
		    Error.captureStackTrace(err, createError);
		  }

		  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
		    // add properties to generic error
		    err.expose = status < 500;
		    err.status = err.statusCode = status;
		  }

		  for (var key in props) {
		    if (key !== 'status' && key !== 'statusCode') {
		      err[key] = props[key];
		    }
		  }

		  return err
		}

		/**
		 * Create HTTP error abstract base class.
		 * @private
		 */

		function createHttpErrorConstructor () {
		  function HttpError () {
		    throw new TypeError('cannot construct abstract class')
		  }

		  inherits(HttpError, Error);

		  return HttpError
		}

		/**
		 * Create a constructor for a client error.
		 * @private
		 */

		function createClientErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ClientError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ClientError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ClientError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ClientError, HttpError);
		  nameFunc(ClientError, className);

		  ClientError.prototype.status = code;
		  ClientError.prototype.statusCode = code;
		  ClientError.prototype.expose = true;

		  return ClientError
		}

		/**
		 * Create function to test is a value is a HttpError.
		 * @private
		 */

		function createIsHttpErrorFunction (HttpError) {
		  return function isHttpError (val) {
		    if (!val || typeof val !== 'object') {
		      return false
		    }

		    if (val instanceof HttpError) {
		      return true
		    }

		    return val instanceof Error &&
		      typeof val.expose === 'boolean' &&
		      typeof val.statusCode === 'number' && val.status === val.statusCode
		  }
		}

		/**
		 * Create a constructor for a server error.
		 * @private
		 */

		function createServerErrorConstructor (HttpError, name, code) {
		  var className = toClassName(name);

		  function ServerError (message) {
		    // create the error object
		    var msg = message != null ? message : statuses.message[code];
		    var err = new Error(msg);

		    // capture a stack trace to the construction point
		    Error.captureStackTrace(err, ServerError);

		    // adjust the [[Prototype]]
		    setPrototypeOf(err, ServerError.prototype);

		    // redefine the error message
		    Object.defineProperty(err, 'message', {
		      enumerable: true,
		      configurable: true,
		      value: msg,
		      writable: true
		    });

		    // redefine the error name
		    Object.defineProperty(err, 'name', {
		      enumerable: false,
		      configurable: true,
		      value: className,
		      writable: true
		    });

		    return err
		  }

		  inherits(ServerError, HttpError);
		  nameFunc(ServerError, className);

		  ServerError.prototype.status = code;
		  ServerError.prototype.statusCode = code;
		  ServerError.prototype.expose = false;

		  return ServerError
		}

		/**
		 * Set the name of a function, if possible.
		 * @private
		 */

		function nameFunc (func, name) {
		  var desc = Object.getOwnPropertyDescriptor(func, 'name');

		  if (desc && desc.configurable) {
		    desc.value = name;
		    Object.defineProperty(func, 'name', desc);
		  }
		}

		/**
		 * Populate the exports object with constructors for every error class.
		 * @private
		 */

		function populateConstructorExports (exports, codes, HttpError) {
		  codes.forEach(function forEachCode (code) {
		    var CodeError;
		    var name = toIdentifier(statuses.message[code]);

		    switch (codeClass(code)) {
		      case 400:
		        CodeError = createClientErrorConstructor(HttpError, name, code);
		        break
		      case 500:
		        CodeError = createServerErrorConstructor(HttpError, name, code);
		        break
		    }

		    if (CodeError) {
		      // export the constructor
		      exports[code] = CodeError;
		      exports[name] = CodeError;
		    }
		  });
		}

		/**
		 * Get a class name from a name identifier.
		 * @private
		 */

		function toClassName (name) {
		  return name.substr(-5) !== 'Error'
		    ? name + 'Error'
		    : name
		} 
	} (httpErrors));
	return httpErrors.exports;
}

var hasRequiredCreateHttpError;

function requireCreateHttpError () {
	if (hasRequiredCreateHttpError) return createHttpError;
	hasRequiredCreateHttpError = 1;

	const createError = requireHttpErrors();

	/**
	 * Create a HttpError object from simple arguments.
	 *
	 * @param {number} status
	 * @param {Error|object} err
	 * @private
	 */

	function createHttpError$1 (status, err) {
	  if (!err) {
	    return createError(status)
	  }

	  return err instanceof Error
	    ? createError(status, err, { expose: false })
	    : createError(status, err)
	}

	createHttpError.createHttpError = createHttpError$1;
	return createHttpError;
}

var hasRequiredSend$1;

function requireSend$1 () {
	if (hasRequiredSend$1) return send;
	hasRequiredSend$1 = 1;

	const fs = require$$0$f;
	const path = require$$1$4;
	const stream = require$$1$5;
	const debug = require$$0$3.debuglog('send');

	const decode = requireFastDecodeUriComponent();
	const escapeHtml = requireEscapeHtml();
	const mime = requireMime();
	const ms = requireDist();

	const { collapseLeadingSlashes } = requireCollapseLeadingSlashes();
	const { containsDotFile } = requireContainsDotFile();
	const { contentRange } = requireContentRange();
	const { createHtmlDocument } = requireCreateHtmlDocument();
	const { isUtf8MimeType } = requireIsUtf8MimeType();
	const { normalizeList } = requireNormalizeList();
	const { parseBytesRange } = requireParseBytesRange();
	const { parseTokenList } = requireParseTokenList();
	const { createHttpError } = requireCreateHttpError();

	/**
	 * Path function references.
	 * @private
	 */

	const extname = path.extname;
	const join = path.join;
	const normalize = path.normalize;
	const resolve = path.resolve;
	const sep = path.sep;

	/**
	 * Stream function references.
	 * @private
	 */
	const Readable = stream.Readable;

	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */

	const BYTES_RANGE_REGEXP = /^ *bytes=/;

	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */

	const MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */

	const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;

	const ERROR_RESPONSES = {
	  400: createHtmlDocument('Error', 'Bad Request'),
	  403: createHtmlDocument('Error', 'Forbidden'),
	  404: createHtmlDocument('Error', 'Not Found'),
	  412: createHtmlDocument('Error', 'Precondition Failed'),
	  416: createHtmlDocument('Error', 'Range Not Satisfiable'),
	  500: createHtmlDocument('Error', 'Internal Server Error')
	};

	const validDotFilesOptions = [
	  'allow',
	  'ignore',
	  'deny'
	];

	function normalizeMaxAge (_maxage) {
	  let maxage;
	  if (typeof _maxage === 'string') {
	    maxage = ms.parse(_maxage);
	  } else {
	    maxage = Number(_maxage);
	  }

	  // eslint-disable-next-line no-self-compare
	  if (maxage !== maxage) {
	    // fast path of isNaN(number)
	    return 0
	  }

	  return Math.min(Math.max(0, maxage), MAX_MAXAGE)
	}

	function normalizeOptions (options) {
	  options = options ?? {};

	  const acceptRanges = options.acceptRanges !== undefined
	    ? Boolean(options.acceptRanges)
	    : true;

	  const cacheControl = options.cacheControl !== undefined
	    ? Boolean(options.cacheControl)
	    : true;

	  const contentType = options.contentType !== undefined
	    ? Boolean(options.contentType)
	    : true;

	  const etag = options.etag !== undefined
	    ? Boolean(options.etag)
	    : true;

	  const dotfiles = options.dotfiles !== undefined
	    ? validDotFilesOptions.indexOf(options.dotfiles)
	    : 1; // 'ignore'
	  if (dotfiles === -1) {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
	  }

	  const extensions = options.extensions !== undefined
	    ? normalizeList(options.extensions, 'extensions option')
	    : [];

	  const immutable = options.immutable !== undefined
	    ? Boolean(options.immutable)
	    : false;

	  const index = options.index !== undefined
	    ? normalizeList(options.index, 'index option')
	    : ['index.html'];

	  const lastModified = options.lastModified !== undefined
	    ? Boolean(options.lastModified)
	    : true;

	  const maxage = normalizeMaxAge(options.maxAge ?? options.maxage);

	  const maxContentRangeChunkSize = options.maxContentRangeChunkSize !== undefined
	    ? Number(options.maxContentRangeChunkSize)
	    : null;

	  const root = options.root
	    ? resolve(options.root)
	    : null;

	  const highWaterMark = Number.isSafeInteger(options.highWaterMark) && options.highWaterMark > 0
	    ? options.highWaterMark
	    : null;

	  return {
	    acceptRanges,
	    cacheControl,
	    contentType,
	    etag,
	    dotfiles,
	    extensions,
	    immutable,
	    index,
	    lastModified,
	    maxage,
	    maxContentRangeChunkSize,
	    root,
	    highWaterMark,
	    start: options.start,
	    end: options.end
	  }
	}

	function normalizePath (_path, root) {
	  // decode the path
	  let path = decode(_path);
	  if (path == null) {
	    return { statusCode: 400 }
	  }

	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    return { statusCode: 400 }
	  }

	  let parts;
	  if (root !== null) {
	    // normalize
	    if (path) {
	      path = normalize('.' + sep + path);
	    }

	    // malicious path
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      return { statusCode: 403 }
	    }

	    // explode path parts
	    parts = path.split(sep);

	    // join / normalize from optional root dir
	    path = normalize(join(root, path));
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path);
	      return { statusCode: 403 }
	    }

	    // explode path parts
	    parts = normalize(path).split(sep);

	    // resolve the path
	    path = resolve(path);
	  }

	  return { path, parts }
	}

	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {boolean}
	 * @private
	 */

	function hasTrailingSlash (path) {
	  return path[path.length - 1] === '/'
	}

	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	function isConditionalGET (request) {
	  return request.headers['if-match'] ||
	    request.headers['if-unmodified-since'] ||
	    request.headers['if-none-match'] ||
	    request.headers['if-modified-since']
	}

	function isNotModifiedFailure (request, headers) {
	  // Always return stale when Cache-Control: no-cache
	  // to support end-to-end reload requests
	  // https://tools.ietf.org/html/rfc2616#section-14.9.4
	  if (
	    'cache-control' in request.headers &&
	    request.headers['cache-control'].indexOf('no-cache') !== -1
	  ) {
	    return false
	  }

	  // if-none-match
	  if ('if-none-match' in request.headers) {
	    const ifNoneMatch = request.headers['if-none-match'];

	    if (ifNoneMatch === '*') {
	      return true
	    }

	    const etag = headers.ETag;

	    if (typeof etag !== 'string') {
	      return false
	    }

	    const etagL = etag.length;
	    const isMatching = parseTokenList(ifNoneMatch, function (match) {
	      const mL = match.length;

	      if (
	        (etagL === mL && match === etag) ||
	        (etagL > mL && 'W/' + match === etag)
	      ) {
	        return true
	      }
	    });

	    if (isMatching) {
	      return true
	    }

	    /**
	     * A recipient MUST ignore If-Modified-Since if the request contains an
	     * If-None-Match header field; the condition in If-None-Match is considered
	     * to be a more accurate replacement for the condition in If-Modified-Since,
	     * and the two are only combined for the sake of interoperating with older
	     * intermediaries that might not implement If-None-Match.
	     *
	     * @see RFC 9110 section 13.1.3
	     */
	    return false
	  }

	  // if-modified-since
	  if ('if-modified-since' in request.headers) {
	    const ifModifiedSince = request.headers['if-modified-since'];
	    const lastModified = headers['Last-Modified'];

	    if (!lastModified || (Date.parse(lastModified) <= Date.parse(ifModifiedSince))) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Check if the request preconditions failed.
	 *
	 * @return {boolean}
	 * @private
	 */

	function isPreconditionFailure (request, headers) {
	  // if-match
	  const ifMatch = request.headers['if-match'];
	  if (ifMatch) {
	    const etag = headers.ETag;

	    if (ifMatch !== '*') {
	      const isMatching = parseTokenList(ifMatch, function (match) {
	        if (
	          match === etag ||
	          'W/' + match === etag
	        ) {
	          return true
	        }
	      }) || false;

	      if (isMatching !== true) {
	        return true
	      }
	    }
	  }

	  // if-unmodified-since
	  if ('if-unmodified-since' in request.headers) {
	    const ifUnmodifiedSince = request.headers['if-unmodified-since'];
	    const unmodifiedSince = Date.parse(ifUnmodifiedSince);
	    // eslint-disable-next-line no-self-compare
	    if (unmodifiedSince === unmodifiedSince) { // fast path of isNaN(number)
	      const lastModified = Date.parse(headers['Last-Modified']);
	      if (
	        // eslint-disable-next-line no-self-compare
	        lastModified !== lastModified ||// fast path of isNaN(number)
	        lastModified > unmodifiedSince
	      ) {
	        return true
	      }
	    }
	  }

	  return false
	}

	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	function isRangeFresh (request, headers) {
	  if (!('if-range' in request.headers)) {
	    return true
	  }

	  const ifRange = request.headers['if-range'];

	  // if-range as etag
	  if (ifRange.indexOf('"') !== -1) {
	    const etag = headers.ETag;
	    return (etag && ifRange.indexOf(etag) !== -1) || false
	  }

	  const ifRangeTimestamp = Date.parse(ifRange);
	  // eslint-disable-next-line no-self-compare
	  if (ifRangeTimestamp !== ifRangeTimestamp) { // fast path of isNaN(number)
	    return false
	  }

	  // if-range as modified date
	  const lastModified = Date.parse(headers['Last-Modified']);

	  return (
	    // eslint-disable-next-line no-self-compare
	    lastModified !== lastModified || // fast path of isNaN(number)
	    lastModified <= ifRangeTimestamp
	  )
	}

	// we provide stat function that will always resolve
	// without throwing
	function tryStat (path) {
	  return new Promise((resolve) => {
	    fs.stat(path, function onstat (error, stat) {
	      resolve({ error, stat });
	    });
	  })
	}

	function sendError (statusCode, err) {
	  const headers = {};

	  // add error headers
	  if (err && err.headers) {
	    for (const headerName in err.headers) {
	      headers[headerName] = err.headers[headerName];
	    }
	  }

	  const doc = ERROR_RESPONSES[statusCode];

	  // basic response
	  headers['Content-Type'] = 'text/html; charset=utf-8';
	  headers['Content-Length'] = doc[1];
	  headers['Content-Security-Policy'] = "default-src 'none'";
	  headers['X-Content-Type-Options'] = 'nosniff';

	  return {
	    statusCode,
	    headers,
	    stream: Readable.from(doc[0]),
	    // metadata
	    type: 'error',
	    metadata: { error: createHttpError(statusCode, err) }
	  }
	}

	function sendStatError (err) {
	  // POSIX throws ENAMETOOLONG and ENOTDIR, Windows only ENOENT
	  /* c8 ignore start */
	  switch (err.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOTDIR':
	    case 'ENOENT':
	      return sendError(404, err)
	    default:
	      return sendError(500, err)
	  }
	  /* c8 ignore stop */
	}

	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */

	function sendNotModified (headers, path, stat) {
	  debug('not modified');

	  delete headers['Content-Encoding'];
	  delete headers['Content-Language'];
	  delete headers['Content-Length'];
	  delete headers['Content-Range'];
	  delete headers['Content-Type'];

	  return {
	    statusCode: 304,
	    headers,
	    stream: Readable.from(''),
	    // metadata
	    type: 'file',
	    metadata: { path, stat }
	  }
	}

	function sendFileDirectly (request, path, stat, options) {
	  let len = stat.size;
	  let offset = options.start ?? 0;

	  let statusCode = 200;
	  const headers = {};

	  debug('send "%s"', path);

	  // set header fields
	  if (options.acceptRanges) {
	    debug('accept ranges');
	    headers['Accept-Ranges'] = 'bytes';
	  }

	  if (options.cacheControl) {
	    let cacheControl = 'public, max-age=' + Math.floor(options.maxage / 1000);

	    if (options.immutable) {
	      cacheControl += ', immutable';
	    }

	    debug('cache-control %s', cacheControl);
	    headers['Cache-Control'] = cacheControl;
	  }

	  if (options.lastModified) {
	    const modified = stat.mtime.toUTCString();
	    debug('modified %s', modified);
	    headers['Last-Modified'] = modified;
	  }

	  if (options.etag) {
	    const etag = 'W/"' + stat.size.toString(16) + '-' + stat.mtime.getTime().toString(16) + '"';
	    debug('etag %s', etag);
	    headers.ETag = etag;
	  }

	  // set content-type
	  if (options.contentType) {
	    let type = mime.getType(path) || mime.default_type;
	    debug('content-type %s', type);
	    if (type && isUtf8MimeType(type)) {
	      type += '; charset=utf-8';
	    }
	    if (type) {
	      headers['Content-Type'] = type;
	    }
	  }

	  // conditional GET support
	  if (isConditionalGET(request)) {
	    if (isPreconditionFailure(request, headers)) {
	      return sendError(412)
	    }

	    if (isNotModifiedFailure(request, headers)) {
	      return sendNotModified(headers, path, stat)
	    }
	  }

	  // adjust len to start/end options
	  len = Math.max(0, len - offset);
	  if (options.end !== undefined) {
	    const bytes = options.end - offset + 1;
	    if (len > bytes) len = bytes;
	  }

	  // Range support
	  if (options.acceptRanges) {
	    const rangeHeader = request.headers.range;

	    if (
	      rangeHeader !== undefined &&
	      BYTES_RANGE_REGEXP.test(rangeHeader)
	    ) {
	      // If-Range support
	      if (isRangeFresh(request, headers)) {
	        // parse
	        const ranges = parseBytesRange(len, rangeHeader);

	        // unsatisfiable
	        if (ranges.length === 0) {
	          debug('range unsatisfiable');

	          // Content-Range
	          headers['Content-Range'] = contentRange('bytes', len);

	          // 416 Requested Range Not Satisfiable
	          return sendError(416, {
	            headers: { 'Content-Range': headers['Content-Range'] }
	          })
	          // valid (syntactically invalid/multiple ranges are treated as a regular response)
	        } else if (ranges.length === 1) {
	          debug('range %j', ranges);

	          // Content-Range
	          statusCode = 206;
	          if (options.maxContentRangeChunkSize) {
	            ranges[0].end = Math.min(ranges[0].end, ranges[0].start + options.maxContentRangeChunkSize - 1);
	          }
	          headers['Content-Range'] = contentRange('bytes', len, ranges[0]);

	          // adjust for requested range
	          offset += ranges[0].start;
	          len = ranges[0].end - ranges[0].start + 1;
	        }
	      } else {
	        debug('range stale');
	      }
	    }
	  }

	  // content-length
	  headers['Content-Length'] = len;

	  // HEAD support
	  if (request.method === 'HEAD') {
	    return {
	      statusCode,
	      headers,
	      stream: Readable.from(''),
	      // metadata
	      type: 'file',
	      metadata: { path, stat }
	    }
	  }

	  const stream = fs.createReadStream(path, {
	    highWaterMark: options.highWaterMark,
	    start: offset,
	    end: Math.max(offset, offset + len - 1)
	  });

	  return {
	    statusCode,
	    headers,
	    stream,
	    // metadata
	    type: 'file',
	    metadata: { path, stat }
	  }
	}

	function sendRedirect (path, options) {
	  if (hasTrailingSlash(options.path)) {
	    return sendError(403)
	  }

	  const loc = encodeURI(collapseLeadingSlashes(options.path + '/'));
	  const doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));

	  const headers = {};
	  headers['Content-Type'] = 'text/html; charset=utf-8';
	  headers['Content-Length'] = doc[1];
	  headers['Content-Security-Policy'] = "default-src 'none'";
	  headers['X-Content-Type-Options'] = 'nosniff';
	  headers.Location = loc;

	  return {
	    statusCode: 301,
	    headers,
	    stream: Readable.from(doc[0]),
	    // metadata
	    type: 'directory',
	    metadata: { requestPath: options.path, path }
	  }
	}

	async function sendIndex (request, path, options) {
	  let err;
	  for (let i = 0; i < options.index.length; i++) {
	    const index = options.index[i];
	    const p = join(path, index);
	    const { error, stat } = await tryStat(p);
	    if (error) {
	      err = error;
	      continue
	    }
	    if (stat.isDirectory()) continue
	    return sendFileDirectly(request, p, stat, options)
	  }

	  if (err) {
	    return sendStatError(err)
	  }

	  return sendError(404)
	}

	async function sendFile (request, path, options) {
	  const { error, stat } = await tryStat(path);
	  if (error && error.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	    let err = error;
	    // not found, check extensions
	    for (let i = 0; i < options.extensions.length; i++) {
	      const extension = options.extensions[i];
	      const p = path + '.' + extension;
	      const { error, stat } = await tryStat(p);
	      if (error) {
	        err = error;
	        continue
	      }
	      if (stat.isDirectory()) {
	        err = null;
	        continue
	      }
	      return sendFileDirectly(request, p, stat, options)
	    }
	    if (err) {
	      return sendStatError(err)
	    }
	    return sendError(404)
	  }
	  if (error) return sendStatError(error)
	  if (stat.isDirectory()) return sendRedirect(path, options)
	  return sendFileDirectly(request, path, stat, options)
	}

	async function send$1 (request, _path, options) {
	  const opts = normalizeOptions(options);
	  opts.path = _path;

	  const parsed = normalizePath(_path, opts.root);
	  const { path, parts } = parsed;
	  if (parsed.statusCode !== undefined) {
	    return sendError(parsed.statusCode)
	  }

	  // dotfile handling
	  if (
	    (
	      debug.enabled || // if debugging is enabled, then check for all cases to log allow case
	      opts.dotfiles !== 0 // if debugging is not enabled, then only check if 'deny' or 'ignore' is set
	    ) &&
	    containsDotFile(parts)
	  ) {
	    switch (opts.dotfiles) {
	      /* c8 ignore start */ /* unreachable, because NODE_DEBUG can not be set after process is running */
	      case 0: // 'allow'
	        debug('allow dotfile "%s"', path);
	        break
	      /* c8 ignore stop */
	      case 2: // 'deny'
	        debug('deny dotfile "%s"', path);
	        return sendError(403)
	      case 1: // 'ignore'
	      default:
	        debug('ignore dotfile "%s"', path);
	        return sendError(404)
	    }
	  }

	  // index file support
	  if (opts.index.length && hasTrailingSlash(_path)) {
	    return sendIndex(request, path, opts)
	  }

	  return sendFile(request, path, opts)
	}

	send.send = send$1;
	return send;
}

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredSend;

function requireSend () {
	if (hasRequiredSend) return send$1.exports;
	hasRequiredSend = 1;

	/**
	 * Module dependencies.
	 * @private
	 */
	const isUtf8MimeType = requireIsUtf8MimeType().isUtf8MimeType;
	const mime = requireMime();
	const send = requireSend$1().send;

	/**
	 * Module exports.
	 * @public
	 */

	send$1.exports = send;
	send$1.exports.default = send;
	send$1.exports.send = send;

	send$1.exports.isUtf8MimeType = isUtf8MimeType;
	send$1.exports.mime = mime;
	return send$1.exports;
}

var acceptNegotiator = {exports: {}};

var hasRequiredAcceptNegotiator;

function requireAcceptNegotiator () {
	if (hasRequiredAcceptNegotiator) return acceptNegotiator.exports;
	hasRequiredAcceptNegotiator = 1;

	function Negotiator (options) {
	  if (!new.target) {
	    return new Negotiator(options)
	  }

	  const {
	    supportedValues = [],
	    cache
	  } = (options && typeof options === 'object' && options) || {};

	  this.supportedValues = supportedValues;

	  this.cache = cache;
	}

	Negotiator.prototype.negotiate = function (header) {
	  if (typeof header !== 'string') {
	    return null
	  }
	  if (!this.cache) {
	    return negotiate(header, this.supportedValues)
	  }
	  if (!this.cache.has(header)) {
	    this.cache.set(header, negotiate(header, this.supportedValues));
	  }
	  return this.cache.get(header)
	};

	function negotiate (header, supportedValues) {
	  if (
	    !header ||
	    !Array.isArray(supportedValues) ||
	    supportedValues.length === 0
	  ) {
	    return null
	  }

	  if (header === '*') {
	    return supportedValues[0]
	  }

	  let preferredEncoding = null;
	  let preferredEncodingPriority = Infinity;
	  let preferredEncodingQuality = 0;

	  function processMatch (enc, quality) {
	    if (quality === 0 || preferredEncodingQuality > quality) {
	      return false
	    }

	    const encoding = (enc === '*' && supportedValues[0]) || enc;
	    const priority = supportedValues.indexOf(encoding);
	    if (priority === -1) {
	      return false
	    }

	    if (priority === 0 && quality === 1) {
	      preferredEncoding = encoding;
	      return true
	    } else if (preferredEncodingQuality < quality) {
	      preferredEncoding = encoding;
	      preferredEncodingPriority = priority;
	      preferredEncodingQuality = quality;
	    } else if (preferredEncodingPriority > priority) {
	      preferredEncoding = encoding;
	      preferredEncodingPriority = priority;
	      preferredEncodingQuality = quality;
	    }
	    return false
	  }

	  parse(header, processMatch);

	  return preferredEncoding
	}

	const BEGIN = 0;
	const TOKEN = 1;
	const QUALITY = 2;
	const END = 3;

	function parse (header, processMatch) {
	  let str = '';
	  let quality;
	  let state = BEGIN;
	  for (let i = 0, il = header.length; i < il; ++i) {
	    const char = header[i];

	    if (char === ' ' || char === '\t') {
	      continue
	    } else if (char === ';') {
	      if (state === TOKEN) {
	        state = QUALITY;
	        quality = '';
	      }
	      continue
	    } else if (char === ',') {
	      if (state === TOKEN) {
	        if (processMatch(str, 1)) {
	          state = END;
	          break
	        }
	        state = BEGIN;
	        str = '';
	      } else if (state === QUALITY) {
	        if (processMatch(str, parseFloat(quality) || 0)) {
	          state = END;
	          break
	        }
	        state = BEGIN;
	        str = '';
	        quality = '';
	      }
	      continue
	    } else if (
	      state === QUALITY
	    ) {
	      if (char === 'q' || char === '=') {
	        continue
	      } else if (
	        char === '.' ||
	        char === '1' ||
	        char === '0' ||
	        char === '2' ||
	        char === '3' ||
	        char === '4' ||
	        char === '5' ||
	        char === '6' ||
	        char === '7' ||
	        char === '8' ||
	        char === '9'
	      ) {
	        quality += char;
	        continue
	      }
	    } else if (state === BEGIN) {
	      state = TOKEN;
	      str += char;
	      continue
	    }
	    if (state === TOKEN) {
	      const prevChar = header[i - 1];
	      if (prevChar === ' ' || prevChar === '\t') {
	        str = '';
	      }
	      str += char;
	      continue
	    }
	    if (processMatch(str, parseFloat(quality) || 0)) {
	      state = END;
	      break
	    }
	    state = BEGIN;
	    str = char;
	    quality = '';
	  }

	  if (state === TOKEN) {
	    processMatch(str, 1);
	  } else if (state === QUALITY) {
	    processMatch(str, parseFloat(quality) || 0);
	  }
	}

	acceptNegotiator.exports = negotiate;
	acceptNegotiator.exports.default = negotiate;
	acceptNegotiator.exports.negotiate = negotiate;
	acceptNegotiator.exports.Negotiator = Negotiator;
	return acceptNegotiator.exports;
}

var contentDisposition = {exports: {}};

/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredContentDisposition;

function requireContentDisposition () {
	if (hasRequiredContentDisposition) return contentDisposition.exports;
	hasRequiredContentDisposition = 1;

	/**
	 * Module exports.
	 * @public
	 */

	contentDisposition.exports = contentDisposition$1;
	contentDisposition.exports.parse = parse;

	/**
	 * Module dependencies.
	 * @private
	 */

	var basename = path.basename;
	var Buffer = requireSafeBuffer().Buffer;

	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 * @private
	 */

	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match percent encoding escape.
	 * @private
	 */

	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;

	/**
	 * RegExp to match non-latin1 characters.
	 * @private
	 */

	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 * @private
	 */

	var QESC_REGEXP = /\\([\u0000-\u007f])/g; // eslint-disable-line no-control-regex

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 * @private
	 */

	var QUOTE_REGEXP = /([\\"])/g;

	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 * @private
	 */

	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 * @private
	 */

	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 * @private
	 */

	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @public
	 */

	function contentDisposition$1 (filename, options) {
	  var opts = options || {};

	  // get type
	  var type = opts.type || 'attachment';

	  // get parameters
	  var params = createparams(filename, opts.fallback);

	  // format into string
	  return format(new ContentDisposition(type, params))
	}

	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @private
	 */

	function createparams (filename, fallback) {
	  if (filename === undefined) {
	    return
	  }

	  var params = {};

	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string')
	  }

	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true;
	  }

	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean')
	  }

	  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string')
	  }

	  // restrict to file base name
	  var name = basename(filename);

	  // determine if name is suitable for quoted string
	  var isQuotedString = TEXT_REGEXP.test(name);

	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string'
	    ? fallback && getlatin1(name)
	    : basename(fallback);
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
	    params['filename*'] = name;
	  }

	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback
	      ? fallbackName
	      : name;
	  }

	  return params
	}

	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @private
	 */

	function format (obj) {
	  var parameters = obj.parameters;
	  var type = obj.type;

	  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  // start with normalized type
	  var string = String(type).toLowerCase();

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param;
	    var params = Object.keys(parameters).sort();

	    for (var i = 0; i < params.length; i++) {
	      param = params[i];

	      var val = param.substr(-1) === '*'
	        ? ustring(parameters[param])
	        : qstring(parameters[param]);

	      string += '; ' + param + '=' + val;
	    }
	  }

	  return string
	}

	/**
	 * Decode a RFC 5987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @private
	 */

	function decodefield (str) {
	  var match = EXT_VALUE_REGEXP.exec(str);

	  if (!match) {
	    throw new TypeError('invalid extended field value')
	  }

	  var charset = match[1].toLowerCase();
	  var encoded = match[2];
	  var value;

	  // to binary string
	  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);

	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary);
	      break
	    case 'utf-8':
	      value = Buffer.from(binary, 'binary').toString('utf8');
	      break
	    default:
	      throw new TypeError('unsupported charset in extended field')
	  }

	  return value
	}

	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function getlatin1 (val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(NON_LATIN1_REGEXP, '?')
	}

	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @public
	 */

	function parse (string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required')
	  }

	  var match = DISPOSITION_TYPE_REGEXP.exec(string);

	  if (!match) {
	    throw new TypeError('invalid type format')
	  }

	  // normalize type
	  var index = match[0].length;
	  var type = match[1].toLowerCase();

	  var key;
	  var names = [];
	  var params = {};
	  var value;

	  // calculate index to start at
	  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'
	    ? index - 1
	    : index;

	  // match parameters
	  while ((match = PARAM_REGEXP.exec(string))) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length;
	    key = match[1].toLowerCase();
	    value = match[2];

	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter')
	    }

	    names.push(key);

	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1);
	      value = decodefield(value);

	      // overwrite existing value
	      params[key] = value;
	      continue
	    }

	    if (typeof params[key] === 'string') {
	      continue
	    }

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(QESC_REGEXP, '$1');
	    }

	    params[key] = value;
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  return new ContentDisposition(type, params)
	}

	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @private
	 */

	function pdecode (str, hex) {
	  return String.fromCharCode(parseInt(hex, 16))
	}

	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @private
	 */

	function pencode (char) {
	  return '%' + String(char)
	    .charCodeAt(0)
	    .toString(16)
	    .toUpperCase()
	}

	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring (val) {
	  var str = String(val);

	  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
	}

	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function ustring (val) {
	  var str = String(val);

	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str)
	    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);

	  return 'UTF-8\'\'' + encoded
	}

	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 *
	 * @public
	 * @param {string} type
	 * @param {object} parameters
	 * @constructor
	 */

	function ContentDisposition (type, parameters) {
	  this.type = type;
	  this.parameters = parameters;
	}
	return contentDisposition.exports;
}

var dirList_1;
var hasRequiredDirList;

function requireDirList () {
	if (hasRequiredDirList) return dirList_1;
	hasRequiredDirList = 1;

	const os = require$$0$6;
	const path = require$$1$4;
	const fs = require$$5$1;
	const fastq = requireQueue();
	const fastqConcurrency = Math.max(1, os.cpus().length - 1);

	const dirList = {
	  _getExtendedInfo: async function (dir, info) {
	    const depth = dir.split(path.sep).length;
	    const files = await fs.readdir(dir);

	    const worker = async (filename) => {
	      const filePath = path.join(dir, filename);
	      let stats;
	      try {
	        stats = await fs.stat(filePath);
	      } catch {
	        return
	      }

	      if (stats.isDirectory()) {
	        info.totalFolderCount++;
	        filePath.split(path.sep).length === depth + 1 && info.folderCount++;
	        await dirList._getExtendedInfo(filePath, info);
	      } else {
	        info.totalSize += stats.size;
	        info.totalFileCount++;
	        filePath.split(path.sep).length === depth + 1 && info.fileCount++;
	        info.lastModified = Math.max(info.lastModified, stats.mtimeMs);
	      }
	    };
	    const queue = fastq.promise(worker, fastqConcurrency);
	    await Promise.all(files.map(filename => queue.push(filename)));
	  },

	  /**
	   * get extended info about a folder
	   * @param {string} folderPath full path fs dir
	   * @return {Promise<ExtendedInfo>}
	   */
	  getExtendedInfo: async function (folderPath) {
	    const info = {
	      totalSize: 0,
	      fileCount: 0,
	      totalFileCount: 0,
	      folderCount: 0,
	      totalFolderCount: 0,
	      lastModified: 0
	    };

	    await dirList._getExtendedInfo(folderPath, info);

	    return info
	  },

	  /**
	   * get files and dirs from dir, or error
	   * @param {string} dir full path fs dir
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @param {string} dotfiles
	   * note: can't use glob because don't get error on non existing dir
	   */
	  list: async function (dir, options, dotfiles) {
	    const entries = { dirs: [], files: [] };
	    let files = await fs.readdir(dir);
	    if (dotfiles === 'deny' || dotfiles === 'ignore') {
	      files = files.filter(file => file.charAt(0) !== '.');
	    }
	    if (files.length < 1) {
	      return entries
	    }

	    const worker = async (filename) => {
	      let stats;
	      try {
	        stats = await fs.stat(path.join(dir, filename));
	      } catch {
	        return
	      }
	      const entry = { name: filename, stats };
	      if (stats.isDirectory()) {
	        if (options.extendedFolderInfo) {
	          entry.extendedInfo = await dirList.getExtendedInfo(path.join(dir, filename));
	        }
	        entries.dirs.push(entry);
	      } else {
	        entries.files.push(entry);
	      }
	    };
	    const queue = fastq.promise(worker, fastqConcurrency);
	    await Promise.all(files.map(filename => queue.push(filename)));

	    entries.dirs.sort((a, b) => a.name.localeCompare(b.name));
	    entries.files.sort((a, b) => a.name.localeCompare(b.name));

	    return entries
	  },

	  /**
	   * send dir list content, or 404 on error
	   * @param {Fastify.Reply} reply
	   * @param {string} dir full path fs dir
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @param {string} route request route
	   * @param {string} dotfiles
	   */
	  send: async function ({ reply, dir, options, route, prefix, dotfiles }) {
	    if (reply.request.query.format === 'html' && typeof options.render !== 'function') {
	      throw new TypeError('The `list.render` option must be a function and is required with the URL parameter `format=html`')
	    }

	    let entries;
	    try {
	      entries = await dirList.list(dir, options, dotfiles);
	    } catch {
	      return reply.callNotFound()
	    }

	    const format = reply.request.query.format || options.format;
	    if (format !== 'html') {
	      if (options.jsonFormat !== 'extended') {
	        const nameEntries = { dirs: [], files: [] };
	        entries.dirs.forEach(entry => nameEntries.dirs.push(entry.name));
	        entries.files.forEach(entry => nameEntries.files.push(entry.name));

	        await reply.send(nameEntries);
	      } else {
	        await reply.send(entries);
	      }
	      return
	    }

	    const html = options.render(
	      entries.dirs.map(entry => dirList.htmlInfo(entry, route, prefix, options)),
	      entries.files.map(entry => dirList.htmlInfo(entry, route, prefix, options)));
	    await reply.type('text/html').send(html);
	  },

	  /**
	   * provide the html information about entry and route, to get name and full route
	   * @param entry file or dir name and stats
	   * @param {string} route request route
	   * @return {ListFile}
	   */
	  htmlInfo: function (entry, route, prefix, options) {
	    if (options.names?.includes(path.basename(route))) {
	      route = path.normalize(path.join(route, '..'));
	    }
	    return {
	      href: encodeURI(path.join(prefix, route, entry.name).replace(/\\/gu, '/')),
	      name: entry.name,
	      stats: entry.stats,
	      extendedInfo: entry.extendedInfo
	    }
	  },

	  /**
	   * say if the route can be handled by dir list or not
	   * @param {string} route request route
	   * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
	   * @return {boolean}
	   */
	  handle: function (route, options) {
	    return options.names?.includes(path.basename(route)) ||
	      // match trailing slash
	      ((options.names?.includes('/') && route[route.length - 1] === '/') ?? false)
	  },

	  /**
	   * get path from route and fs root paths, considering trailing slash
	   * @param {string} root fs root path
	   * @param {string} route request route
	   */
	  path: function (root, route) {
	    const _route = route[route.length - 1] === '/'
	      ? route + 'none'
	      : route;
	    return path.dirname(path.join(root, _route))
	  },

	  /**
	   * validate options
	   * @return {Error}
	   */
	  validateOptions: function (options) {
	    if (!options.list) {
	      return
	    }

	    if (Array.isArray(options.root)) {
	      return new TypeError('multi-root with list option is not supported')
	    }

	    if (options.list.format && options.list.format !== 'json' && options.list.format !== 'html') {
	      return new TypeError('The `list.format` option must be json or html')
	    }
	    if (options.list.names && !Array.isArray(options.list.names)) {
	      return new TypeError('The `list.names` option must be an array')
	    }
	    if (options.list.jsonFormat != null && options.list.jsonFormat !== 'names' && options.list.jsonFormat !== 'extended') {
	      return new TypeError('The `list.jsonFormat` option must be name or extended')
	    }
	    if (options.list.format === 'html' && typeof options.list.render !== 'function') {
	      return new TypeError('The `list.render` option must be a function and is required with html format')
	    }
	  }
	};

	dirList_1 = dirList;
	return dirList_1;
}

var hasRequired_static;

function require_static () {
	if (hasRequired_static) return _static.exports;
	hasRequired_static = 1;

	const path = require$$1$4;
	const { fileURLToPath } = require$$1$6;
	const { statSync } = require$$0$f;
	const { glob } = requireCommonjs();
	const fp = requirePlugin();
	const send = requireSend();
	const encodingNegotiator = requireAcceptNegotiator();
	const contentDisposition = requireContentDisposition();

	const dirList = requireDirList();

	const endForwardSlashRegex = /\/$/u;
	const asteriskRegex = /\*/gu;

	const supportedEncodings = ['br', 'gzip', 'deflate'];
	send.mime.default_type = 'application/octet-stream';

	async function fastifyStatic (fastify, opts) {
	  opts.root = normalizeRoot(opts.root);
	  checkRootPathForErrors(fastify, opts.root);

	  const setHeaders = opts.setHeaders;
	  if (setHeaders !== undefined && typeof setHeaders !== 'function') {
	    throw new TypeError('The `setHeaders` option must be a function')
	  }

	  const invalidDirListOpts = dirList.validateOptions(opts);
	  if (invalidDirListOpts) {
	    throw invalidDirListOpts
	  }

	  if (opts.dotfiles === undefined) {
	    opts.dotfiles = 'allow';
	  }

	  const sendOptions = {
	    root: opts.root,
	    acceptRanges: opts.acceptRanges,
	    contentType: opts.contentType,
	    cacheControl: opts.cacheControl,
	    dotfiles: opts.dotfiles,
	    etag: opts.etag,
	    extensions: opts.extensions,
	    immutable: opts.immutable,
	    index: opts.index,
	    lastModified: opts.lastModified,
	    maxAge: opts.maxAge
	  };

	  let prefix = opts.prefix ?? (opts.prefix = '/');

	  if (!opts.prefixAvoidTrailingSlash) {
	    prefix =
	      prefix[prefix.length - 1] === '/'
	        ? prefix
	        : prefix + '/';
	  }

	  // Set the schema hide property if defined in opts or true by default
	  const routeOpts = {
	    constraints: opts.constraints,
	    schema: {
	      hide: opts.schemaHide !== undefined ? opts.schemaHide : true
	    },
	    logLevel: opts.logLevel,
	    errorHandler (error, request, reply) {
	      if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {
	        reply.request.raw.destroy();
	        return
	      }

	      fastify.errorHandler(error, request, reply);
	    }
	  };

	  if (opts.decorateReply !== false) {
	    fastify.decorateReply('sendFile', function (filePath, rootPath, options) {
	      const opts = typeof rootPath === 'object' ? rootPath : options;
	      const root = typeof rootPath === 'string' ? rootPath : opts?.root;
	      pumpSendToReply(
	        this.request,
	        this,
	        filePath,
	        root || sendOptions.root,
	        0,
	        opts
	      );
	      return this
	    });

	    fastify.decorateReply(
	      'download',
	      function (filePath, fileName, options = {}) {
	        const { root, ...opts } =
	          typeof fileName === 'object' ? fileName : options;
	        fileName = typeof fileName === 'string' ? fileName : filePath;

	        // Set content disposition header
	        this.header('content-disposition', contentDisposition(fileName));

	        pumpSendToReply(this.request, this, filePath, root, 0, opts);

	        return this
	      }
	    );
	  }

	  if (opts.serve !== false) {
	    if (opts.wildcard && typeof opts.wildcard !== 'boolean') {
	      throw new TypeError('"wildcard" option must be a boolean')
	    }
	    if (opts.wildcard === undefined || opts.wildcard === true) {
	      fastify.route({
	        ...routeOpts,
	        method: ['HEAD', 'GET'],
	        path: prefix + '*',
	        handler (req, reply) {
	          pumpSendToReply(req, reply, '/' + req.params['*'], sendOptions.root);
	        }
	      });
	      if (opts.redirect === true && prefix !== opts.prefix) {
	        fastify.get(opts.prefix, routeOpts, (req, reply) => {
	          reply.redirect(getRedirectUrl(req.raw.url), 301);
	        });
	      }
	    } else {
	      const indexes = opts.index === undefined ? ['index.html'] : [].concat(opts.index);
	      const indexDirs = new Map();
	      const routes = new Set();

	      const roots = Array.isArray(sendOptions.root) ? sendOptions.root : [sendOptions.root];
	      for (let rootPath of roots) {
	        rootPath = rootPath.split(path.win32.sep).join(path.posix.sep);
	        !rootPath.endsWith('/') && (rootPath += '/');
	        const files = await glob('**/**', {
	          cwd: rootPath, absolute: false, follow: true, nodir: true, dot: opts.serveDotFiles, ignore: opts.globIgnore
	        });

	        for (let file of files) {
	          file = file.split(path.win32.sep).join(path.posix.sep);
	          const route = prefix + file;

	          if (routes.has(route)) {
	            continue
	          }

	          routes.add(route);

	          setUpHeadAndGet(routeOpts, route, `/${file}`, rootPath);

	          const key = path.posix.basename(route);
	          if (indexes.includes(key) && !indexDirs.has(key)) {
	            indexDirs.set(path.posix.dirname(route), rootPath);
	          }
	        }
	      }

	      for (const [dirname, rootPath] of indexDirs.entries()) {
	        const pathname = dirname + (dirname.endsWith('/') ? '' : '/');
	        const file = '/' + pathname.replace(prefix, '');
	        setUpHeadAndGet(routeOpts, pathname, file, rootPath);

	        if (opts.redirect === true) {
	          setUpHeadAndGet(routeOpts, pathname.replace(endForwardSlashRegex, ''), file.replace(endForwardSlashRegex, ''), rootPath);
	        }
	      }
	    }
	  }

	  const allowedPath = opts.allowedPath;

	  async function pumpSendToReply (
	    request,
	    reply,
	    pathname,
	    rootPath,
	    rootPathOffset = 0,
	    pumpOptions,
	    checkedEncodings
	  ) {
	    const pathnameOrig = pathname;
	    const options = Object.assign({}, sendOptions, pumpOptions);

	    if (rootPath) {
	      if (Array.isArray(rootPath)) {
	        options.root = rootPath[rootPathOffset];
	      } else {
	        options.root = rootPath;
	      }
	    }

	    if (allowedPath && !allowedPath(pathname, options.root, request)) {
	      return reply.callNotFound()
	    }

	    let encoding;
	    let pathnameForSend = pathname;

	    if (opts.preCompressed) {
	      /**
	       * We conditionally create this structure to track our attempts
	       * at sending pre-compressed assets
	       */
	      if (!checkedEncodings) {
	        checkedEncodings = new Set();
	      }

	      encoding = getEncodingHeader(request.headers, checkedEncodings);

	      if (encoding) {
	        if (pathname.endsWith('/')) {
	          pathname = findIndexFile(pathname, options.root, options.index);
	          if (!pathname) {
	            return reply.callNotFound()
	          }
	          pathnameForSend = pathnameForSend + pathname + '.' + getEncodingExtension(encoding);
	        } else {
	          pathnameForSend = pathname + '.' + getEncodingExtension(encoding);
	        }
	      }
	    }

	    // `send(..., path, ...)` will URI-decode path so we pass an encoded path here
	    const {
	      statusCode,
	      headers,
	      stream,
	      type,
	      metadata
	    } = await send(request.raw, encodeURI(pathnameForSend), options);
	    switch (type) {
	      case 'directory': {
	        const path = metadata.path;
	        if (opts.list) {
	          await dirList.send({
	            reply,
	            dir: path,
	            options: opts.list,
	            route: pathname,
	            prefix,
	            dotfiles: opts.dotfiles
	          }).catch((err) => reply.send(err));
	        }

	        if (opts.redirect === true) {
	          try {
	            reply.redirect(getRedirectUrl(request.raw.url), 301);
	          } /* c8 ignore start */ catch (error) {
	            // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack
	            await reply.send(error);
	          } /* c8 ignore stop */
	        } else {
	          // if is a directory path without a trailing slash, and has an index file, reply as if it has a trailing slash
	          if (!pathname.endsWith('/') && findIndexFile(pathname, options.root, options.index)) {
	            return pumpSendToReply(
	              request,
	              reply,
	              pathname + '/',
	              rootPath,
	              undefined,
	              undefined,
	              checkedEncodings
	            )
	          }

	          reply.callNotFound();
	        }
	        break
	      }
	      case 'error': {
	        if (
	          statusCode === 403 &&
	          (!options.index || !options.index.length) &&
	          pathnameForSend[pathnameForSend.length - 1] === '/'
	        ) {
	          if (opts.list) {
	            await dirList.send({
	              reply,
	              dir: dirList.path(opts.root, pathname),
	              options: opts.list,
	              route: pathname,
	              prefix,
	              dotfiles: opts.dotfiles
	            }).catch((err) => reply.send(err));
	            return
	          }
	        }

	        if (metadata.error.code === 'ENOENT') {
	        // when preCompress is enabled and the path is a directory without a trailing slash
	          if (opts.preCompressed && encoding) {
	            if (opts.redirect !== true) {
	              const indexPathname = findIndexFile(pathname, options.root, options.index);
	              if (indexPathname) {
	                return pumpSendToReply(
	                  request,
	                  reply,
	                  pathname + '/',
	                  rootPath,
	                  undefined,
	                  undefined,
	                  checkedEncodings
	                )
	              }
	            }
	          }

	          // if file exists, send real file, otherwise send dir list if name match
	          if (opts.list && dirList.handle(pathname, opts.list)) {
	            await dirList.send({
	              reply,
	              dir: dirList.path(opts.root, pathname),
	              options: opts.list,
	              route: pathname,
	              prefix,
	              dotfiles: opts.dotfiles
	            }).catch((err) => reply.send(err));
	            return
	          }

	          // root paths left to try?
	          if (Array.isArray(rootPath) && rootPathOffset < (rootPath.length - 1)) {
	            return pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset + 1)
	          }

	          if (opts.preCompressed && !checkedEncodings.has(encoding)) {
	            checkedEncodings.add(encoding);
	            return pumpSendToReply(
	              request,
	              reply,
	              pathnameOrig,
	              rootPath,
	              rootPathOffset,
	              undefined,
	              checkedEncodings
	            )
	          }

	          return reply.callNotFound()
	        }

	        // The `send` library terminates the request with a 404 if the requested
	        // path contains a dotfile and `send` is initialized with `{dotfiles:
	        // 'ignore'}`. `send` aborts the request before getting far enough to
	        // check if the file exists (hence, a 404 `NotFoundError` instead of
	        // `ENOENT`).
	        // https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L582
	        if (metadata.error.status === 404) {
	          return reply.callNotFound()
	        }

	        await reply.send(metadata.error);
	        break
	      }
	      case 'file': {
	        // reply.raw.statusCode by default 200
	        // when ever the user changed it, we respect the status code
	        // otherwise use send provided status code
	        const newStatusCode = reply.statusCode !== 200 ? reply.statusCode : statusCode;
	        reply.code(newStatusCode);
	        if (setHeaders !== undefined) {
	          setHeaders(reply.raw, metadata.path, metadata.stat);
	        }
	        reply.headers(headers);
	        if (encoding) {
	          reply.header('content-type', getContentType(pathname));
	          reply.header('content-encoding', encoding);
	        }
	        await reply.send(stream);
	        break
	      }
	    }
	  }

	  function setUpHeadAndGet (routeOpts, route, file, rootPath) {
	    const toSetUp = Object.assign({}, routeOpts, {
	      method: ['HEAD', 'GET'],
	      url: route,
	      handler: serveFileHandler
	    });
	    toSetUp.config = toSetUp.config || {};
	    toSetUp.config.file = file;
	    toSetUp.config.rootPath = rootPath;
	    fastify.route(toSetUp);
	  }

	  async function serveFileHandler (req, reply) {
	    // TODO: remove the fallback branch when bump major
	    /* c8 ignore next */
	    const routeConfig = req.routeOptions?.config || req.routeConfig;
	    return pumpSendToReply(req, reply, routeConfig.file, routeConfig.rootPath)
	  }
	}

	function normalizeRoot (root) {
	  if (root === undefined) {
	    return root
	  }
	  if (root instanceof URL && root.protocol === 'file:') {
	    return fileURLToPath(root)
	  }
	  if (Array.isArray(root)) {
	    const result = [];
	    for (let i = 0, il = root.length; i < il; ++i) {
	      if (root[i] instanceof URL && root[i].protocol === 'file:') {
	        result.push(fileURLToPath(root[i]));
	      } else {
	        result.push(root[i]);
	      }
	    }

	    return result
	  }

	  return root
	}

	function checkRootPathForErrors (fastify, rootPath) {
	  if (rootPath === undefined) {
	    throw new Error('"root" option is required')
	  }

	  if (Array.isArray(rootPath)) {
	    if (!rootPath.length) {
	      throw new Error('"root" option array requires one or more paths')
	    }

	    if (new Set(rootPath).size !== rootPath.length) {
	      throw new Error(
	        '"root" option array contains one or more duplicate paths'
	      )
	    }

	    // check each path and fail at first invalid
	    rootPath.map((path) => checkPath(fastify, path));
	    return
	  }

	  if (typeof rootPath === 'string') {
	    return checkPath(fastify, rootPath)
	  }

	  throw new Error('"root" option must be a string or array of strings')
	}

	function checkPath (fastify, rootPath) {
	  if (typeof rootPath !== 'string') {
	    throw new TypeError('"root" option must be a string')
	  }
	  if (path.isAbsolute(rootPath) === false) {
	    throw new Error('"root" option must be an absolute path')
	  }

	  let pathStat;

	  try {
	    pathStat = statSync(rootPath);
	  } catch (e) {
	    if (e.code === 'ENOENT') {
	      fastify.log.warn(`"root" path "${rootPath}" must exist`);
	      return
	    }

	    throw e
	  }

	  if (pathStat.isDirectory() === false) {
	    throw new Error('"root" option must point to a directory')
	  }
	}

	function getContentType (path) {
	  const type = send.mime.getType(path) || send.mime.default_type;

	  if (!send.isUtf8MimeType(type)) {
	    return type
	  }
	  return `${type}; charset=utf-8`
	}

	function findIndexFile (pathname, root, indexFiles = ['index.html']) {
	  if (Array.isArray(indexFiles)) {
	    return indexFiles.find(filename => {
	      const p = path.join(root, pathname, filename);
	      try {
	        const stats = statSync(p);
	        return !stats.isDirectory()
	      } catch {
	        return false
	      }
	    })
	  }
	  /* c8 ignore next */
	  return false
	}

	// Adapted from https://github.com/fastify/fastify-compress/blob/665e132fa63d3bf05ad37df3c20346660b71a857/index.js#L451
	function getEncodingHeader (headers, checked) {
	  if (!('accept-encoding' in headers)) return

	  // consider the no-preference token as gzip for downstream compat
	  const header = headers['accept-encoding'].toLowerCase().replace(asteriskRegex, 'gzip');

	  return encodingNegotiator.negotiate(
	    header,
	    supportedEncodings.filter((enc) => !checked.has(enc))
	  )
	}

	function getEncodingExtension (encoding) {
	  switch (encoding) {
	    case 'br':
	      return 'br'

	    case 'gzip':
	      return 'gz'
	  }
	}

	function getRedirectUrl (url) {
	  let i = 0;
	  // we detect how many slash before a valid path
	  for (; i < url.length; ++i) {
	    if (url[i] !== '/' && url[i] !== '\\') break
	  }
	  // turns all leading / or \ into a single /
	  url = '/' + url.substr(i);
	  try {
	    const parsed = new URL(url, 'http://localhost.com/');
	    const parsedPathname = parsed.pathname;
	    return parsedPathname + (parsedPathname[parsedPathname.length - 1] !== '/' ? '/' : '') + (parsed.search || '')
	  } /* c8 ignore start */ catch {
	    // the try-catch here is actually unreachable, but we keep it for safety and prevent DoS attack
	    const err = new Error(`Invalid redirect URL: ${url}`);
	    err.statusCode = 400;
	    throw err
	  } /* c8 ignore stop */
	}

	_static.exports = fp(fastifyStatic, {
	  fastify: '5.x',
	  name: '@fastify/static'
	});
	_static.exports.default = fastifyStatic;
	_static.exports.fastifyStatic = fastifyStatic;
	return _static.exports;
}

var serialize_1;
var hasRequiredSerialize;

function requireSerialize () {
	if (hasRequiredSerialize) return serialize_1;
	hasRequiredSerialize = 1;

	function serialize (value) {
	  switch (typeof value) {
	    case 'bigint':
	      return value.toString() + 'n'
	    case 'boolean':
	      return value ? 'true' : 'false'
	    case 'function':
	      return value.toString()
	    case 'number':
	      return '' + value
	    case 'object':
	      if (value === null) {
	        return 'null'
	      } else if (Array.isArray(value)) {
	        return serializeArray(value)
	      } else if (value instanceof RegExp) {
	        return `/${value.source}/${value.flags}`
	      } else if (value instanceof Date) {
	        return `new Date(${value.getTime()})`
	      } else if (value instanceof Set) {
	        return `new Set(${serializeArray(Array.from(value))})`
	      } else if (value instanceof Map) {
	        return `new Map(${serializeArray(Array.from(value))})`
	      } else {
	        return serializeObject(value)
	      }
	    case 'string':
	      return JSON.stringify(value)
	    case 'symbol':
	      return serializeSymbol(value)
	    case 'undefined':
	      return 'undefined'
	  }
	}
	const symbolRE = /Symbol\((.+)\)/;
	function serializeSymbol (value) {
	  return symbolRE.test(value.toString())
	    ? `Symbol("${value.toString().match(symbolRE)[1]}")`
	    : 'Symbol()'
	}

	function serializeArray (value) {
	  let result = '[';
	  const il = value.length;
	  const last = il - 1;
	  for (let i = 0; i < il; ++i) {
	    result += serialize(value[i]);
	    i !== last && (result += ',');
	  }
	  return result + ']'
	}

	function serializeObject (value) {
	  let result = '{';
	  const keys = Object.keys(value);
	  let i = 0;
	  const il = keys.length;
	  const last = il - 1;
	  for (; i < il; ++i) {
	    const key = keys[i];
	    result += `"${key}":${serialize(value[key])}`;
	    i !== last && (result += ',');
	  }
	  return result + '}'
	}

	serialize_1 = serialize;
	return serialize_1;
}

var swaggerInitializer_1;
var hasRequiredSwaggerInitializer;

function requireSwaggerInitializer () {
	if (hasRequiredSwaggerInitializer) return swaggerInitializer_1;
	hasRequiredSwaggerInitializer = 1;

	const serialize = requireSerialize();

	function swaggerInitializer (opts) {
	  const hasLogo = opts.logo && opts.logo.content !== undefined;
	  const logoBase64 = hasLogo && Buffer.from(opts.logo.content).toString('base64');
	  const logoData = hasLogo && `data:${opts.logo.type};base64,${logoBase64}`;
	  const logoHref = hasLogo && opts.logo.href;
	  const logoTarget = hasLogo && opts.logo.target;

	  return `window.onload = function () {
    function waitForElement(selector) {
      return new Promise(resolve => {
          if (document.querySelector(selector)) {
              return resolve(document.querySelector(selector));
          }

          const observer = new MutationObserver(mutations => {
              if (document.querySelector(selector)) {
                  observer.disconnect();
                  resolve(document.querySelector(selector));
              }
          });

          // If you get "parameter 1 is not of type 'Node'" error, see https://stackoverflow.com/a/77855838/492336
          observer.observe(document.body, {
              childList: true,
              subtree: true
          });
      });
    }
    function resolveUrl(url) {
      let currentHref = window.location.href;
      currentHref = currentHref.split('#', 1)[0];
      currentHref = currentHref.endsWith('/') ? currentHref : currentHref + '/';
      const anchor = document.createElement('a');
      anchor.href = currentHref + url;
      return anchor.href
    }

    const config = ${serialize(opts.uiConfig)}
    const resConfig = Object.assign({}, {
      dom_id: '#swagger-ui',
      deepLinking: true,
      presets: [
        SwaggerUIBundle.presets.apis,
        SwaggerUIStandalonePreset
      ],
      plugins: [
        SwaggerUIBundle.plugins.DownloadUrl
      ],
      layout: "StandaloneLayout",
      validatorUrl: ${serialize(opts.validatorUrl || null)},
    }, config, {
      url: resolveUrl('./json'),
      oauth2RedirectUrl: resolveUrl('./static/oauth2-redirect.html')
    });

    const ui = SwaggerUIBundle(resConfig)

    ${logoData
	? `
    if (resConfig.layout === 'StandaloneLayout') {
      // Replace the logo
      waitForElement('#swagger-ui > section > div.topbar > div > div > a').then((link) => {
        const img = document.createElement('img')
        img.height = 40
        img.src = '${logoData}'
        ${logoHref ? `img.href = '${logoHref}'` : 'img.href = resolveUrl(\'/\')'}
        ${logoTarget ? `img.target = '${logoTarget}'` : ''}
        link.innerHTML = ''
        link.appendChild(img)
      })
    }`
	: ''}

    ui.initOAuth(${serialize(opts.initOAuth)})
  }`
	}

	swaggerInitializer_1 = swaggerInitializer;
	return swaggerInitializer_1;
}

var indexHtml_1;
var hasRequiredIndexHtml;

function requireIndexHtml () {
	if (hasRequiredIndexHtml) return indexHtml_1;
	hasRequiredIndexHtml = 1;

	function indexHtml (opts) {
	  let routePrefix = opts.prefix;
	  if (opts.indexPrefix) {
	    routePrefix = `${opts.indexPrefix.replace(/\/$/, '')}/${opts.prefix.replace(/^\//, '')}`;
	  }
	  return (url) => {
	    const hasTrailingSlash = /\/$/.test(url);
	    const prefix = hasTrailingSlash ? `.${opts.staticPrefix}` : `${routePrefix}${opts.staticPrefix}`;
	    return `<!-- HTML for static distribution bundle build -->
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="UTF-8">
      <title>${opts.theme?.title || 'Swagger UI'}</title>
      <link rel="stylesheet" type="text/css" href="${prefix}/swagger-ui.css" />
      <link rel="stylesheet" type="text/css" href="${prefix}/index.css" />
      ${opts.theme && opts.theme.css ? opts.theme.css.map(css => `<link rel="stylesheet" type="text/css" href="${prefix}/theme/${css.filename}" />\n`).join('') : ''}
      ${opts.theme && opts.theme.favicon
	    ? opts.theme.favicon.map(favicon => `<link rel="${favicon.rel}" type="${favicon.type}" href="${prefix}/theme/${favicon.filename}" sizes="${favicon.sizes}" />\n`).join('')
	    : `
      <link rel="icon" type="image/png" href="${prefix}/favicon-32x32.png" sizes="32x32" />
      <link rel="icon" type="image/png" href="${prefix}/favicon-16x16.png" sizes="16x16" />
      `}
      </head>

      <body>
      <div id="swagger-ui"></div>
      <script src="${prefix}/swagger-ui-bundle.js" charset="UTF-8"> </script>
      <script src="${prefix}/swagger-ui-standalone-preset.js" charset="UTF-8"> </script>
      <script src="${prefix}/swagger-initializer.js" charset="UTF-8"> </script>
      ${opts.theme && opts.theme.js ? opts.theme.js.map(js => `<script src="${prefix}/theme/${js.filename}" charset="UTF-8"> </script>\n`).join('') : ''}
      </body>
      </html>
      `
	  }
	}

	indexHtml_1 = indexHtml;
	return indexHtml_1;
}

var routes;
var hasRequiredRoutes;

function requireRoutes () {
	if (hasRequiredRoutes) return routes;
	hasRequiredRoutes = 1;

	const path = require$$1$4;
	const yaml = require$$1;
	const fastifyStatic = require_static();
	const rfdc = requireRfdc()();
	const swaggerInitializer = requireSwaggerInitializer();
	const indexHtml = requireIndexHtml();

	// URI prefix to separate static assets for swagger UI
	const staticPrefix = '/static';

	function fastifySwagger (fastify, opts, done) {
	  let staticCSP = false;
	  if (opts.staticCSP === true) {
	    const csp = fastify.swaggerCSP;
	    staticCSP = `default-src 'self'; base-uri 'self'; font-src 'self' https: data:; frame-ancestors 'self'; img-src 'self' data: validator.swagger.io; object-src 'none'; script-src 'self' ${csp.script.join(' ')}; script-src-attr 'none'; style-src 'self' https: ${csp.style.join(' ')}; upgrade-insecure-requests;`;
	  }
	  if (typeof opts.staticCSP === 'string') {
	    staticCSP = opts.staticCSP;
	  }
	  if (typeof opts.staticCSP === 'object' && opts.staticCSP !== null) {
	    staticCSP = '';
	    Object.keys(opts.staticCSP).forEach(function (key) {
	      const value = Array.isArray(opts.staticCSP[key]) ? opts.staticCSP[key].join(' ') : opts.staticCSP[key];
	      staticCSP += `${key.toLowerCase()} ${value}; `;
	    });
	  }

	  if (typeof staticCSP === 'string' || typeof opts.transformStaticCSP === 'function') {
	    fastify.addHook('onSend', function (_request, reply, _payload, done) {
	      // set static csp when it is passed
	      if (typeof staticCSP === 'string') {
	        reply.header('content-security-policy', staticCSP.trim());
	      }
	      // mutate the header when it is passed
	      const header = reply.getHeader('content-security-policy');
	      if (header && typeof opts.transformStaticCSP === 'function') {
	        reply.header('content-security-policy', opts.transformStaticCSP(header));
	      }
	      done();
	    });
	  }

	  const hooks = Object.create(null);
	  if (opts.hooks) {
	    const additionalHooks = [
	      'onRequest',
	      'preHandler'
	    ];
	    for (const hook of additionalHooks) {
	      hooks[hook] = opts.hooks[hook];
	    }
	  }

	  if (opts.theme) {
	    const themePrefix = `${staticPrefix}/theme`;
	    if (opts.theme.css) {
	      for (const cssFile of opts.theme.css) {
	        fastify.route({
	          url: `${themePrefix}/${cssFile.filename}`,
	          method: 'GET',
	          schema: { hide: true },
	          ...hooks,
	          handler: (_req, reply) => {
	            reply
	              .header('content-type', 'text/css; charset=UTF-8')
	              .send(cssFile.content);
	          }
	        });
	      }
	    }

	    if (opts.theme.js) {
	      for (const jsFile of opts.theme.js) {
	        fastify.route({
	          url: `${themePrefix}/${jsFile.filename}`,
	          method: 'GET',
	          schema: { hide: true },
	          ...hooks,
	          handler: (_req, reply) => {
	            reply
	              .header('content-type', 'application/javascript; charset=utf-8')
	              .send(jsFile.content);
	          }
	        });
	      }
	    }

	    if (opts.theme.favicon) {
	      for (const favicon of opts.theme.favicon) {
	        fastify.route({
	          url: `${themePrefix}/${favicon.filename}`,
	          method: 'GET',
	          schema: { hide: true },
	          ...hooks,
	          handler: (_req, reply) => {
	            reply
	              .header('content-type', favicon.type)
	              .send(favicon.content);
	          }
	        });
	      }
	    }
	  }

	  const indexHtmlContent = indexHtml({ ...opts, staticPrefix });

	  fastify.route({
	    url: '/',
	    method: 'GET',
	    schema: { hide: true },
	    ...hooks,
	    handler: (req, reply) => {
	      reply
	        .header('content-type', 'text/html; charset=utf-8')
	        .send(indexHtmlContent(req.url)); // trailing slash alters the relative urls generated in the html
	    }
	  });

	  fastify.route({
	    url: `${staticPrefix}/index.html`,
	    method: 'GET',
	    schema: { hide: true },
	    ...hooks,
	    handler: (req, reply) => {
	      reply.redirect(req.url.replace(/\/static\/index\.html$/, '/'));
	    }
	  });

	  const swaggerInitializerContent = swaggerInitializer(opts);

	  fastify.route({
	    url: `${staticPrefix}/swagger-initializer.js`,
	    method: 'GET',
	    schema: { hide: true },
	    ...hooks,
	    handler: (_req, reply) => {
	      reply
	        .header('content-type', 'application/javascript; charset=utf-8')
	        .send(swaggerInitializerContent);
	    }
	  });

	  const hasTransformSpecificationFn = typeof opts.transformSpecification === 'function';
	  const shouldCloneSwaggerObject = opts.transformSpecificationClone ?? true;
	  const transformSpecification = opts.transformSpecification;
	  fastify.route({
	    url: '/json',
	    method: 'GET',
	    schema: { hide: true },
	    ...hooks,
	    handler: hasTransformSpecificationFn
	      ? shouldCloneSwaggerObject
	        ? function (req, reply) {
	          reply.send(transformSpecification(rfdc(fastify.swagger()), req, reply));
	        }
	        : function (req, reply) {
	          reply.send(transformSpecification(fastify.swagger(), req, reply));
	        }
	      : function (_req, reply) {
	        reply.send(fastify.swagger());
	      }
	  });

	  fastify.route({
	    url: '/yaml',
	    method: 'GET',
	    schema: { hide: true },
	    ...hooks,
	    handler: hasTransformSpecificationFn
	      ? shouldCloneSwaggerObject
	        ? function (req, reply) {
	          reply
	            .type('application/x-yaml')
	            .send(yaml.stringify(transformSpecification(rfdc(fastify.swagger()), req, reply)));
	        }
	        : function (req, reply) {
	          reply
	            .type('application/x-yaml')
	            .send(yaml.stringify(transformSpecification(fastify.swagger(), req, reply)));
	        }
	      : function (_req, reply) {
	        reply
	          .type('application/x-yaml')
	          .send(fastify.swagger({ yaml: true }));
	      }
	  });

	  // serve swagger-ui with the help of @fastify/static
	  fastify.register(fastifyStatic, {
	    root: opts.baseDir || path.join(__dirname, '..', 'static'),
	    prefix: staticPrefix,
	    decorateReply: false
	  });

	  if (opts.baseDir) {
	    fastify.register(fastifyStatic, {
	      root: opts.baseDir,
	      serve: false
	    });

	    // Handler for external documentation files passed via $ref
	    fastify.route({
	      url: '/*',
	      method: 'GET',
	      schema: { hide: true },
	      ...hooks,
	      handler: function (req, reply) {
	        const file = req.params['*'];
	        reply.sendFile(file);
	      }
	    });
	  }

	  done();
	}

	routes = fastifySwagger;
	return routes;
}

var hasRequiredSwaggerUi;

function requireSwaggerUi () {
	if (hasRequiredSwaggerUi) return swaggerUi.exports;
	hasRequiredSwaggerUi = 1;

	const fsPromises = require$$5$1;
	const path = require$$1$4;
	const fp = requirePlugin();
	const csp = require$$3;

	async function fastifySwaggerUi (fastify, opts) {
	  fastify.decorate('swaggerCSP', csp);

	  // if no logo is provided, read default static logo
	  let logoContent = opts.logo;
	  if (logoContent === undefined) {
	    const bufferLogoContent = await fsPromises.readFile(path.join(__dirname, './static/logo.svg'));
	    logoContent = { type: 'image/svg+xml', content: bufferLogoContent };
	  }

	  await fastify.register(requireRoutes(), {
	    ...opts,
	    prefix: opts.routePrefix || '/documentation',
	    uiConfig: opts.uiConfig || {},
	    initOAuth: opts.initOAuth || {},
	    hooks: opts.uiHooks,
	    theme: opts.theme || {},
	    logo: logoContent
	  });
	}

	swaggerUi.exports = fp(fastifySwaggerUi, {
	  fastify: '5.x',
	  name: '@fastify/swagger-ui',
	  dependencies: ['@fastify/swagger']
	});
	swaggerUi.exports.default = fastifySwaggerUi;
	swaggerUi.exports.fastifySwaggerUi = fastifySwaggerUi;
	return swaggerUi.exports;
}

var swaggerUiExports = requireSwaggerUi();
var fastifySwaggerUi = /*@__PURE__*/getDefaultExportFromCjs(swaggerUiExports);

const pkgJson = {
  "name": "rpc-proxy",
  "version": "1.0.5",
  "description": "Reverse RPC Proxy for EVM chains"};

const JsonRpcReqSchema = {
  oneOf: [
    {
      type: "array",
      minItems: 1,
      maxItems: 100,
      items: {
        type: "object",
        properties: {
          jsonrpc: { type: "string" },
          id: { type: ["string", "number"] },
          method: { type: "string" },
          params: {}
        },
        required: ["jsonrpc", "id", "method"]
      }
    },
    {
      type: "object",
      properties: {
        jsonrpc: { type: "string" },
        id: { type: ["string", "number"] },
        method: { type: "string" },
        params: {}
      },
      required: ["jsonrpc", "id", "method"]
    }
  ]
};
const JsonRpcRespSchema = {
  description: "JSONRPC 2.0 Response",
  oneOf: [
    {
      type: "array",
      minItems: 1,
      maxItems: 100,
      items: {
        type: "object",
        properties: {
          jsonrpc: { type: "string" },
          id: { type: ["string", "number"] },
          result: {},
          error: {}
        },
        required: ["jsonrpc", "id"]
      }
    },
    {
      type: "object",
      properties: {
        jsonrpc: { type: "string" },
        id: { type: ["string", "number"] },
        result: {},
        error: {}
      },
      required: ["jsonrpc", "id"]
    }
  ]
};
const BlockRespSchema = {
  description: "Health Block Response",
  type: "object",
  properties: {
    hash: { type: "string" },
    number: { type: ["string", "number"] },
    timestamp: { type: ["string", "number"] },
    parentHash: { type: "string" },
    parentBeaconBlockRoot: { type: "string" },
    nonce: { type: "string" },
    difficulty: { type: "string" },
    gasLimit: { type: ["string", "number"] },
    gasUsed: { type: ["string", "number"] },
    blobGasUsed: { type: ["string", "number"] },
    excessBlobGas: { type: ["string", "number"] },
    miner: { type: "string" },
    prevRandao: { type: "string" },
    extraData: { type: "string" },
    baseFeePerGas: { type: ["string", "number"] },
    stateRoot: { type: "string" },
    receiptsRoot: { type: "string" },
    transactions: {
      type: "array",
      items: { type: "string" }
    }
  }
};
const ErrorObjectSchema = {
  type: "object",
  properties: {
    error: {}
  }
};

const whitelistedSet = /* @__PURE__ */ new Set([
  "eth_blobBaseFee",
  "eth_blockNumber",
  "eth_call",
  "eth_callMany",
  "eth_chainId",
  "eth_estimateGas",
  "eth_feeHistory",
  "eth_gasPrice",
  "eth_getAccount",
  "eth_getBalance",
  "eth_getBlockByHash",
  "eth_getBlockByNumber",
  "eth_getBlockReceipts",
  "eth_getBlockTransactionCountByHash",
  "eth_getBlockTransactionCountByNumber",
  "eth_getCode",
  "eth_getLogs",
  "eth_getProof",
  "eth_getStorageAt",
  "eth_getTransactionByBlockHashAndIndex",
  "eth_getTransactionByBlockNumberAndIndex",
  "eth_getTransactionByHash",
  "eth_getTransactionCount",
  "eth_getTransactionReceipt",
  "eth_getUncleCountByBlockHash",
  "eth_getUncleCountByBlockNumber",
  "eth_maxPriorityFeePerGas",
  "eth_simulateV1",
  "eth_syncing",
  "eth_sendRawTransaction",
  "net_version",
  "web3_clientVersion",
  "web3_sha3"
]);
const traceSet = /* @__PURE__ */ new Set([
  "trace_block",
  "trace_call",
  "trace_callMany",
  "trace_filter",
  "trace_rawTransaction",
  "trace_replayBlockTransactions",
  "trace_replayTransaction",
  "trace_transaction",
  "debug_getBadBlocks",
  "debug_storageRangeAt",
  "debug_getTrieFlushInterval",
  "debug_traceBlock",
  "debug_traceBlockByHash",
  "debug_traceBlockByNumber",
  "debug_traceCall",
  "debug_traceTransaction"
]);
const filterSet = /* @__PURE__ */ new Set([
  "eth_getFilterChanges",
  "eth_getFilterLogs",
  "eth_newBlockFilter",
  "eth_newFilter",
  "eth_newPendingTransactionFilter",
  "eth_uninstallFilter"
]);
const rangeSet = /* @__PURE__ */ new Set(["eth_getLogs", "eth_newFilter"]);
const subscribeSet = /* @__PURE__ */ new Set(["eth_subscribe", "eth_unsubscribe"]);

const textEncoder = new TextEncoder();
async function existsAsync(file) {
  try {
    await promises.stat(file);
    return true;
  } catch {
    return false;
  }
}
function concatBytes(...arrays) {
  const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);
  const merged = new Uint8Array(totalSize);
  arrays.forEach((array, i, arrays2) => {
    const offset = arrays2.slice(0, i).reduce((acc, e) => acc + e.length, 0);
    merged.set(array, offset);
  });
  return merged;
}
function bytesToHex(bytes) {
  return "0x" + Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hexString) {
  if (hexString.slice(0, 2) === "0x") {
    hexString = hexString.slice(2);
  }
  if (hexString.length % 2 !== 0) {
    hexString = "0" + hexString;
  }
  return Uint8Array.from(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
}
function rBytes(length = 32) {
  return require$$1$7.webcrypto.getRandomValues(new Uint8Array(length));
}
async function digest(buf, algorithm = "SHA-256") {
  return bytesToHex(new Uint8Array(await require$$1$7.webcrypto.subtle.digest(algorithm, buf)));
}
async function createID() {
  return (await digest(concatBytes(rBytes(16), hexToBytes(Date.now().toString(16))), "SHA-1")).substr(
    0,
    18
  );
}
async function hashOrigin(ip) {
  return (await digest(textEncoder.encode(ip), "SHA-1")).substr(0, 18);
}

function markNewError(code = -32603, message = "Internal error") {
  return markError({ jsonrpc: "2.0", id: 0, method: "" }, code, message);
}
function markError(reqs, code = -32603, message = "Internal error") {
  if (Array.isArray(reqs)) {
    return reqs.map((req) => ({
      jsonrpc: req.jsonrpc,
      id: req.id,
      error: {
        code,
        message
      }
    }));
  }
  return {
    jsonrpc: reqs.jsonrpc,
    id: reqs.id,
    error: {
      code,
      message
    }
  };
}
function rewriteTag(blockTag, lastKnownBlock) {
  if (typeof blockTag === "number") {
    return blockTag;
  } else if (typeof blockTag === "undefined") {
    return 0;
  } else if (blockTag === "earliest") {
    return 0;
  } else if (blockTag === "latest") {
    return lastKnownBlock;
  } else if (blockTag === "pending") {
    return lastKnownBlock;
  } else if (blockTag === "finalized") {
    return lastKnownBlock;
  } else if (blockTag === "safe") {
    return lastKnownBlock;
  }
  return Number(blockTag);
}
function filterGetLogParam(maxBlockRange, param, lastKnownBlock) {
  return param.filter((p) => {
    if (p.blockHash) {
      return false;
    }
    const [fromBlock, toBlock] = [
      rewriteTag(p.fromBlock, lastKnownBlock),
      rewriteTag(p.toBlock, lastKnownBlock)
    ];
    if (toBlock - fromBlock > maxBlockRange) {
      return true;
    }
    return false;
  }).length === 0;
}
async function filterGetLogs(request, reqs) {
  if (!request.maxBlockRange) {
    return true;
  }
  const lastBlockNumber = await request.getSavedBlockNumber();
  if (!lastBlockNumber) {
    return true;
  }
  if (Array.isArray(reqs)) {
    return reqs.filter((r) => {
      if (r.method === "eth_getLogs" || r.method === "eth_newFilter") {
        if (!filterGetLogParam(
          request.maxBlockRange,
          r.params,
          lastBlockNumber
        )) {
          return true;
        }
      }
      return false;
    }).length === 0;
  }
  return filterGetLogParam(request.maxBlockRange, reqs.params, lastBlockNumber);
}
async function filterRequest(request, reqs) {
  const { hOrigin, logger, supportSubscribe, backend } = request;
  const origin = await hOrigin;
  try {
    if (Array.isArray(reqs)) {
      const uniqueIds = [...new Set(reqs.map((r) => r.id))];
      const uniqueMethods = [...new Set(reqs.map((r) => r.method))];
      if (uniqueIds.length !== reqs.length) {
        logger?.debug("FILTER", `${origin}: ${reqs.length} reqs filtered with id`);
        return markError(reqs, -32601, "Batch should have unique ids");
      }
      if (origin && request.rateLimit) {
        if (!await request.rateLimit(origin, reqs.length)) {
          logger?.debug("LIMITED", `${origin}: Rate limited`);
          return markError(reqs, -32029, "Rate limited");
        }
      }
      if (uniqueMethods.filter(
        (method) => !(subscribeSet.has(method) && supportSubscribe) && !(traceSet.has(method) && backend.trace) && !(filterSet.has(method) && backend.filter) && !whitelistedSet.has(method)
      ).length) {
        logger?.debug(
          "FILTER",
          `${origin}: ${reqs.length} reqs filtered ( ${uniqueMethods.join(", ")} )`
        );
        return markError(reqs, -32601, "Request contains unsupported method");
      }
      if (uniqueMethods.filter((method) => rangeSet.has(method)).length) {
        if (!await filterGetLogs(request, reqs)) {
          logger?.debug(
            "FILTER",
            `${origin}: ${reqs.length} reqs filtered with invalid eth_getLogs params`
          );
          return markError(reqs, -32601, "Request contains invalid block params");
        }
      }
      logger?.debug("PROXY", `${origin}: ${reqs.length} reqs ( ${uniqueMethods.join(", ")} )`);
      return await request.sendUpstream(reqs);
    }
    if (origin && request.rateLimit) {
      if (!await request.rateLimit(origin, 1)) {
        logger?.debug("LIMITED", `${origin}: Rate limited`);
        return markError(reqs, -32029, "Rate limited");
      }
    }
    if (!(subscribeSet.has(reqs.method) && supportSubscribe) && !(traceSet.has(reqs.method) && backend.trace) && !(filterSet.has(reqs.method) && backend.filter) && !whitelistedSet.has(reqs.method)) {
      logger?.debug("FILTER", `${origin}: request filtered with ${reqs.method} method`);
      return markError(reqs, -32601, "Request contains unsupported method");
    }
    if (rangeSet.has(reqs.method)) {
      if (!await filterGetLogs(request, reqs)) {
        logger?.debug("FILTER", `${origin}: request filtered with invalid eth_getLogs params`);
        return markError(reqs, -32601, "Request contains invalid block params");
      }
    }
    logger?.debug("PROXY", `${origin}: ${reqs.method}`);
    return await request.sendUpstream(reqs);
  } catch {
    logger?.debug("FILTER", `${origin}: Unknown filter error`);
    return markNewError(-32603, "Unknown filter error");
  }
}
class BasicRequest {
  maxBlockRange;
  backend;
  hOrigin;
  rateLimit;
  blockFunc;
  logger;
  supportSubscribe;
  constructor({ maxBlockRange, backend, origin, rateLimit, blockFunc, logger }) {
    this.maxBlockRange = maxBlockRange;
    this.backend = backend;
    this.hOrigin = origin ? hashOrigin(origin) : new Promise((resolve) => resolve(""));
    this.rateLimit = rateLimit;
    this.blockFunc = blockFunc;
    this.logger = logger;
    this.supportSubscribe = false;
  }
  async send(reqs) {
    return filterRequest(this, reqs);
  }
  async sendUpstream(reqs) {
    return filterRequest(this, reqs);
  }
  async getBlockNumber() {
    const { result, error } = await this.sendUpstream({
      jsonrpc: "2.0",
      id: 0,
      method: "eth_blockNumber"
    });
    if (error) {
      throw new Error(JSON.stringify(error));
    }
    return Number(result);
  }
  async getSavedBlockNumber() {
    return this.blockFunc ? await this.blockFunc(this.backend.chain) : 0;
  }
  async getBlock() {
    const { result, error } = await this.sendUpstream({
      jsonrpc: "2.0",
      id: 0,
      method: "eth_getBlockByNumber",
      params: ["latest", false]
    });
    if (error) {
      throw new Error(JSON.stringify(error));
    }
    return result;
  }
}

class PostRequest extends BasicRequest {
  async sendUpstream(req) {
    if (!req) {
      return {};
    }
    if (Array.isArray(req) && !req.length) {
      return [];
    }
    const resp = await fetch(this.backend.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(req),
      signal: AbortSignal.timeout(this.backend.timeout * 1e3)
    });
    if (!resp.ok) {
      const methods = Array.isArray(req) ? [...new Set(req.map((r) => r.method))].join(", ") : req.method;
      this.logger?.debug(
        "PROXY",
        `${await this.hOrigin}: Upstream returned ${resp.status} error ( ${methods} )`
      );
      return markError(req, -32e3, `Upstream request returned ${resp.status}`);
    }
    return await resp.json();
  }
}

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;

	const { Duplex } = require$$0$e;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream = createWebSocketStream;
	return stream;
}

requireStream();

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants = {
	  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = require('bufferutil');

	    bufferUtil.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };

	    bufferUtil.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$0$d;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation = {exports: {}};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation.exports;
	hasRequiredValidation = 1;

	const { isUtf8 } = require$$0$8;

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	validation.exports = {
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');

	    validation.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$e;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();

	const FastBuffer = Buffer[Symbol.species];

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else {
	        data = fragments;
	      }

	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver = Receiver;
	return receiver;
}

requireReceiver();

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;

	const { Duplex } = require$$0$e;
	const { randomFillSync } = require$$1$7;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER } = requireConstants();
	const { isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._deflating = false;
	    this._queue = [];
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          /* istanbul ignore else  */
	          if (randomPool === undefined) {
	            //
	            // This is lazily initialized because server-sent frames must not
	            // be masked so it may never be used.
	            //
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }

	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }

	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    if (perMessageDeflate) {
	      const opts = {
	        [kByteLength]: byteLength,
	        fin: options.fin,
	        generateMask: this._generateMask,
	        mask: options.mask,
	        maskBuffer: this._maskBuffer,
	        opcode,
	        readOnly,
	        rsv1
	      };

	      if (this._deflating) {
	        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	      } else {
	        this.dispatch(data, this._compress, opts, cb);
	      }
	    } else {
	      this.sendFrame(
	        Sender.frame(data, {
	          [kByteLength]: byteLength,
	          fin: options.fin,
	          generateMask: this._generateMask,
	          mask: options.mask,
	          maskBuffer: this._maskBuffer,
	          opcode,
	          readOnly,
	          rsv1: false
	        }),
	        cb
	      );
	    }
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._deflating = true;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        if (typeof cb === 'function') cb(err);

	        for (let i = 0; i < this._queue.length; i++) {
	          const params = this._queue[i];
	          const callback = params[params.length - 1];

	          if (typeof callback === 'function') callback(err);
	        }

	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._deflating = false;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (!this._deflating && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {Buffer[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender = Sender;
	return sender;
}

requireSender();

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;

	const { kForOnEventAttribute, kListener } = requireConstants();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension = { format, parse };
	return extension;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const EventEmitter = require$$0$7;
	const https = require$$1$8;
	const http = require$$2$2;
	const net = require$$3$3;
	const tls = require$$4;
	const { randomBytes, createHash } = require$$1$7;
	const { Duplex, Readable } = require$$0$e;
	const { URL } = require$$7;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * This deviates from the WHATWG interface since ws doesn't support the
	   * required default "blob" type (instead we define a custom "nodebuffer"
	   * type).
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    this._sender = new Sender(socket, this._extensions, options.generateMask);
	    this._receiver = receiver;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    //
	    // Specify a timeout for the closing handshake to complete.
	    //
	    this._closeTimer = setTimeout(
	      this._socket.destroy.bind(this._socket),
	      closeTimeout
	    );
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  websocket.emit('error', err);
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket;
}

var websocketExports = requireWebsocket();
var WebSocket = /*@__PURE__*/getDefaultExportFromCjs(websocketExports);

var subprotocol;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol;
	hasRequiredSubprotocol = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol = { parse };
	return subprotocol;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$7;
	const http = require$$2$2;
	const { Duplex } = require$$0$e;
	const { createHash } = require$$1$7;

	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 8 && version !== 13) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message);
	  }
	}
	return websocketServer;
}

requireWebsocketServer();

function sendWS(request, req) {
  return new Promise(async (resolve, reject) => {
    const id = Array.isArray(req) ? req.map((r) => r.id).join(",") : req.id;
    const origin = await request.hOrigin;
    if (request.queue.findIndex((q) => q.id === id) !== -1) {
      request.logger?.debug("FILTER", `${origin}: WS request contains duplidated id`);
      resolve(markError(req, -32601, "Request contains duplidated id"));
      return;
    }
    const queue = {
      id,
      resolve,
      reject,
      resolved: false
    };
    queue.timeout = setTimeout(() => {
      if (!queue.resolved) {
        request.logger?.debug(
          "PROXY",
          `${origin}: WS request timed out after ${request.backend.timeout * 1e3} ms`
        );
        queue.reject(new Error("Request timeout"));
        queue.resolved = true;
      }
    }, request.backend.timeout * 1e3);
    request.queue.push(queue);
    (await request.ws)?.send(JSON.stringify(req), (err) => {
      if (err) {
        reject(err);
      }
    });
  });
}
function connectWSRpc(request) {
  return new Promise((resolve, reject) => {
    if (!request.backend.wsUrl) {
      reject(new Error("Invalid WS URL"));
      return;
    }
    const ws = new WebSocket(request.backend.wsUrl);
    ws.onclose = () => {
      request.onDisconnect?.();
    };
    ws.onerror = () => {
      ws.close();
    };
    ws.onopen = () => {
      resolve(ws);
    };
    ws.onmessage = (d) => {
      try {
        const data = d?.data ? JSON.parse(d.data) : null;
        if (!data) {
          return;
        }
        const id = Array.isArray(data) ? data.map((r) => r.id).join(",") : data.id;
        const queue = request.queue.find((r) => r.id === id);
        if (!queue) {
          request.onSubscribe?.(data);
          return;
        }
        queue.resolve(data);
        queue.resolved = true;
        request.queue = request.queue.filter((q) => !q.resolved);
      } catch {
      }
    };
  });
}
class WebSocketRequest extends BasicRequest {
  wid;
  checked;
  ws;
  onDisconnect;
  onSubscribe;
  queue;
  constructor(params) {
    super(params);
    this.wid = params.wid;
    this.checked = true;
    this.queue = [];
    this.supportSubscribe = true;
  }
  async connect() {
    if (!this.ws) {
      this.ws = connectWSRpc(this);
    }
    return this.ws;
  }
  async terminate() {
    if (!this.ws) {
      return;
    }
    (await this.ws).terminate();
  }
  async sendUpstream(req) {
    await this.connect();
    return await sendWS(this, req);
  }
}

const __dirname$1 = path.dirname(require$$7.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('start.cjs', document.baseURI).href))));
const swaggerUiDir = path.join(__dirname$1, "../node_modules/@fastify/swagger-ui/static");
async function initProxy(proxy) {
  const { config, logger, app, reqSchema, forkId } = proxy;
  process$1.on("message", (msg) => {
    const queue = proxy.msgQueue.find((q) => q.id === msg.id);
    if (!queue) {
      return;
    }
    queue.resolve(msg.result);
    queue.resolved = true;
    proxy.msgQueue = proxy.msgQueue.filter((q) => !q.resolved);
  });
  function sendMessage(msg) {
    return new Promise(async (resolve, reject) => {
      if (!process$1.send) {
        reject(new Error("Not cluster"));
        return;
      }
      const id = await createID();
      const queue = {
        id,
        resolve,
        reject,
        resolved: false
      };
      queue.timeout = setTimeout(() => {
        if (!queue.resolved) {
          queue.reject(new Error("Request timeout"));
          queue.resolved = true;
        }
      }, 10 * 1e3);
      proxy.msgQueue.push(queue);
      process$1.send({
        id,
        ...msg
      });
    });
  }
  function setRateLimit(key, type, score, session) {
    return sendMessage({
      type,
      key,
      score,
      session
    });
  }
  function getBlockNumber(chain) {
    return sendMessage({
      type: "getBlockNumber",
      chain
    });
  }
  async function handleReq(req, reply, backend) {
    try {
      const reqBody = req.body;
      const request = new PostRequest({
        maxBlockRange: config.maxBlockRange,
        backend,
        origin: req.ip,
        rateLimit: (origin, count) => {
          return setRateLimit(origin, "addCount", count);
        },
        blockFunc: (chain) => {
          return getBlockNumber(chain);
        },
        logger
      });
      reply.send(await request.send(reqBody));
    } catch {
      logger.debug("PROXY", "Unknown POST error");
      reply.send(markNewError(void 0, "Unknown POST error"));
    }
  }
  async function handleHealth(req, reply, backend) {
    try {
      const request = new PostRequest({
        maxBlockRange: config.maxBlockRange,
        backend,
        origin: req.ip,
        rateLimit: (origin, count) => {
          return setRateLimit(origin, "addCount", count);
        },
        blockFunc: (chain) => {
          return getBlockNumber(chain);
        },
        logger
      });
      const block = await request.getBlock();
      const isHealthy = Number(block?.timestamp || 0) + config.healthyAge > Math.floor(Date.now() / 1e3);
      reply.code(isHealthy ? 200 : 502).send(block);
    } catch {
      logger.debug("PROXY", "Unknown /health error");
      reply.code(502).send({ error: "Unknown /health error" });
    }
  }
  function handleWS(socket, req, backend) {
    try {
      if (!backend.wsUrl) {
        socket.send("WS backend unavailable");
        socket.terminate();
        return;
      }
      if (!socket.request) {
        socket.request = (async () => {
          const wid = await createID();
          const request = new WebSocketRequest({
            wid,
            maxBlockRange: config.maxBlockRange,
            backend,
            origin: req.ip,
            rateLimit: (origin2, count) => {
              return setRateLimit(origin2, "addCount", count);
            },
            blockFunc: (chain) => {
              return getBlockNumber(chain);
            },
            logger
          });
          const origin = await request.hOrigin;
          if (!await setRateLimit(origin, "addSession", void 0, wid)) {
            logger.debug("LIMITED", `${origin}: Connection limited`);
            socket.send(JSON.stringify(markNewError(-32029, "Connection limited")));
            socket.terminate();
            return request;
          }
          await request.connect();
          logger.debug("PROXY", `${origin}: New socket ${wid} connected`);
          proxy.sockets.add(socket);
          request.onDisconnect = () => {
            (async () => {
              socket.terminate();
              setRateLimit(origin, "removeSession", void 0, wid);
              proxy.sockets.delete(socket);
            })();
          };
          request.onSubscribe = (data) => {
            socket.send(JSON.stringify(data));
          };
          return request;
        })();
      }
      socket.on("message", (e) => {
        (async () => {
          try {
            const request = await socket.request;
            const parsedData = JSON.parse(
              Buffer.isBuffer(e) ? e.toString() : e
            );
            if (!reqSchema(parsedData)) {
              logger.debug("FILTER", `${await request.hOrigin}: Invalid WS data`);
              socket.send(JSON.stringify(markNewError(-32600, "Invalid data")));
              socket.terminate();
              return;
            }
            socket.send(JSON.stringify(await request.send(parsedData)));
          } catch {
            logger.debug("PROXY", "Unknown WS input data error");
            socket.send(JSON.stringify(markNewError(void 0, "Unknown WS input data error")));
          }
        })();
      });
      socket.on("pong", () => {
        (async () => {
          const request = await socket.request;
          request.checked = true;
        })();
      });
      socket.on("error", () => {
        (async () => {
          const request = await socket.request;
          socket.terminate();
          request.terminate();
          setRateLimit(await request.hOrigin, "removeSession", void 0, request.wid);
          proxy.sockets.delete(socket);
        })();
      });
      socket.on("close", () => {
        (async () => {
          const request = await socket.request;
          const origin = await request.hOrigin;
          logger.debug("PROXY", `${origin}: Socket ${request.wid} disconnected`);
          request.terminate();
          setRateLimit(origin, "removeSession", void 0, request.wid);
          proxy.sockets.delete(socket);
        })();
      });
    } catch {
      socket.terminate();
    }
  }
  await app.register(corsExports.fastifyCors, {
    // Allow all origins (for development)
    origin: true,
    // For production, specify: origin: ['https://your-frontend.com']
    maxAge: 1728e3
  });
  await app.register(websocketExports$1.fastifyWebsocket, {
    options: {
      maxPayload: config.maxBodySize
    }
  });
  if (config.swaggerApi) {
    const { protocol, host } = new URL(config.swaggerApi);
    app.register(fastifySwagger, {
      swagger: {
        info: {
          title: pkgJson.name,
          description: pkgJson.description,
          version: pkgJson.version
        },
        host,
        schemes: [protocol.replaceAll(":", "")],
        consumes: ["application/json"],
        produces: ["application/json"]
      }
    });
    const logoExists = await existsAsync(path.join(swaggerUiDir, "./logo.svg"));
    await app.register(fastifySwaggerUi, {
      routePrefix: "/docs",
      baseDir: logoExists ? swaggerUiDir : void 0,
      logo: logoExists ? {
        type: "image/svg+xml",
        content: await promises.readFile(path.join(swaggerUiDir, "./logo.svg"))
      } : void 0
    });
  }
  app.route({
    method: "GET",
    url: "/",
    handler: (_, reply) => {
      if (config.redirect) {
        reply.redirect(config.redirect);
        return;
      }
      reply.send("RPC Proxy Server");
    }
  });
  for (const [chain, backends] of Object.entries(config.backendGroup)) {
    app.post(
      `/${chain}`,
      {
        schema: {
          description: "Listen / Forward ETH JSONRPC POST requests",
          summary: "JSONRPC handler",
          body: JsonRpcReqSchema,
          response: {
            200: JsonRpcRespSchema
          }
        }
      },
      (req, reply) => {
        handleReq(req, reply, backends[0]);
      }
    );
    app.get(
      `/${chain}/health`,
      {
        schema: {
          description: "Health checking endpoint for JSONRPC backend",
          summary: "Health handler",
          response: {
            200: BlockRespSchema,
            502: ErrorObjectSchema
          }
        }
      },
      (req, reply) => {
        handleHealth(req, reply, backends[0]);
      }
    );
    app.route({
      method: "GET",
      url: `/${chain}`,
      handler: (_, reply) => {
        if (config.redirect) {
          reply.redirect(config.redirect);
          return;
        }
        reply.send("RPC Proxy Server");
      },
      wsHandler: (socket, req) => {
        handleWS(socket, req, backends[0]);
      }
    });
    if (forkId === 0) {
      logger.debug("ROUTER", `Router 0 Listening on /${chain}`);
    }
  }
  app.listen({ port: config.port, host: config.host }, (err, address) => {
    if (err) {
      logger.error(`ROUTER ${forkId}`, "Error from router");
      console.log(err);
      process$1.exit(1);
    }
    logger.debug("ROUTER", `Router ${forkId} listening on ${address}`);
  });
  setInterval(async () => {
    for (const socket of proxy.sockets.values()) {
      try {
        const request = await socket.request;
        if (!request.checked) {
          socket.terminate();
          proxy.sockets.delete(socket);
          return;
        }
        request.checked = false;
        socket.ping();
      } catch {
      }
    }
  }, 60 * 1e3);
}
class Proxy {
  config;
  logger;
  app;
  reqSchema;
  forkId;
  sockets;
  msgQueue;
  constructor(config, forkId = 0) {
    this.config = config;
    this.logger = new Logger(config);
    this.app = fastifyExports.fastify({
      ajv: {
        customOptions: {
          allowUnionTypes: true
        }
      },
      bodyLimit: config.maxBodySize,
      trustProxy: config.reverseProxy
    });
    this.reqSchema = new ajvExports.Ajv({ allowUnionTypes: true }).compile(JsonRpcReqSchema);
    this.forkId = forkId;
    this.sockets = /* @__PURE__ */ new Set();
    this.msgQueue = [];
    initProxy(this);
  }
}

class RateLimiter {
  config;
  logger;
  // Counter for rate limits (reset on every configured interval)
  counts;
  allCounts;
  allLimits;
  // Counter for sessions (ws) (reset on every day)
  sessions;
  constructor(config) {
    this.config = config;
    this.logger = new Logger(config);
    this.counts = {};
    this.allCounts = 0;
    this.allLimits = 0;
    this.sessions = {};
    setInterval(() => {
      this.logger.info(
        "PROXY",
        `Reqs: ${this.allCounts} ( ${Math.floor(this.allCounts / config.interval)} req/s ), Limits: ${this.allLimits}, Users: ${Object.keys(this.counts).length}, Conns: ${Object.keys(this.sessions).length}`
      );
      this.counts = {};
      this.allCounts = 0;
      this.allLimits = 0;
    }, config.interval * 1e3);
    setInterval(() => {
      this.sessions = {};
    }, 86400 * 1e3);
  }
  addCount(key, count = 1) {
    if (!this.counts[key]) {
      this.counts[key] = 0;
    }
    this.counts[key] += count;
    this.allCounts += count;
    if (this.counts[key] > this.config.ratelimit) {
      this.allLimits += count;
      return false;
    }
    return true;
  }
  addSession(key, session) {
    if (!this.sessions[key]) {
      this.sessions[key] = /* @__PURE__ */ new Set();
    }
    if (!this.sessions[key].has(session)) {
      this.sessions[key].add(session);
    }
    if (this.sessions[key].size > this.config.concurrency) {
      return false;
    }
    return true;
  }
  removeSession(key, session) {
    if (this.sessions[key]?.has(session)) {
      this.sessions[key].delete(session);
    }
    if (!this.sessions[key]?.size) {
      delete this.sessions[key];
    }
    return true;
  }
}

async function refreshBlocks(lastBlocks, backendGroup) {
  await Promise.all(
    Object.entries(backendGroup).map(async ([chain, backends]) => {
      try {
        lastBlocks.blocks[chain] = await new PostRequest({ backend: backends[0] }).getBlockNumber();
      } catch {
      }
    })
  );
}
class LastBlocks {
  blocks;
  blocksPromise;
  constructor(config) {
    this.blocks = {};
    if (config.blockRefresh) {
      this.blocksPromise = refreshBlocks(this, config.backendGroup);
      setInterval(() => refreshBlocks(this, config.backendGroup), config.blockRefresh * 1e3);
    }
  }
}

if (cluster.isWorker) {
  const config = JSON.parse(process$1.env.config);
  const forkId = Number(process$1.env.forkId);
  switch (process$1.env.workerType) {
    case "proxy":
      new Proxy(config, forkId);
      break;
  }
} else if (cluster.isPrimary) {
  start();
}
function createServerWorker(config, logger, lastBlock, rateLimiter, forkId) {
  const worker = cluster.fork({
    workerType: "proxy",
    forkId,
    config: JSON.stringify(config)
  });
  worker.on("exit", (code) => {
    logger.debug("WORKER", `Worker ${forkId} exit with ${code}, spawning replacement...`);
    setTimeout(() => {
      createServerWorker(config, logger, lastBlock, rateLimiter, forkId);
    }, 2e3);
  }).on("message", (msg) => {
    if (msg.type === "addCount") {
      const { id, key, score } = msg;
      worker.send({
        id,
        result: rateLimiter.addCount(key, score)
      });
    } else if (msg.type === "addSession") {
      const { id, key, session } = msg;
      worker.send({
        id,
        result: rateLimiter.addSession(key, session)
      });
    } else if (msg.type === "removeSession") {
      const { id, key, session } = msg;
      worker.send({
        id,
        result: rateLimiter.removeSession(key, session)
      });
    } else if (msg.type === "getBlockNumber") {
      const { id, chain } = msg;
      worker.send({
        id,
        result: lastBlock.blocks[chain]
      });
    }
  });
}
async function start() {
  const config = getConfig();
  const logger = new Logger(config);
  const lastBlock = new LastBlocks(config);
  const rateLimiter = new RateLimiter(config);
  console.log(config);
  await lastBlock.blocksPromise;
  console.log(lastBlock.blocks);
  let i = 0;
  while (i < config.workers) {
    createServerWorker(config, logger, lastBlock, rateLimiter, i);
    ++i;
  }
  logger.debug("SPAWNER", `Spawned ${i} website workers`);
}
